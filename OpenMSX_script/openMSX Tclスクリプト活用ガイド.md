# openMSX Tclスクリプト活用ガイド

openMSXでスクリプトを活用する際に困りそうな項目をまとめたガイドです。

## 1. 配置と自動読み込み・手動読み込み
openMSXで実行するスクリプトファイルは、**拡張子を必ず `.tcl` にする必要があります。** これ以外の拡張子では、システムの自動読み込みやコンソールでの補完機能が働きません。

### 1.1 ファイル名先頭のアンダースコア (_) の意味
ファイル名の先頭文字によって、起動時の挙動が決定します。
- **_ なし (例: `init.tcl`)**
    - **挙動**: 起動時にシステムが自動で読み込み（source）、即実行されます。
    - **用途**: キーの `bind` 設定、起動時の初期化、常に使うメインコマンド。
- **_ あり (例: `_library.tcl`)**
    - **挙動**: 起動時は無視されます（手動またはオートロード用）。
    - **用途**: ライブラリ、特定の時だけ使う重いツール。

### 1.2 配置パス（機種・環境依存を排除）
スクリプト内では物理パスを直接書かず、必ずシステム変数を使用します。

- **推奨パス（正式）**: `[file join $env(OPENMSX_USER_DATA) share scripts]`
- **簡略記法（スラッシュ区切り）**: `$env(OPENMSX_USER_DATA)/share/scripts`
- **各OSの実際のパス（参考値）**:
    - **Windows**: `C:\Users\ユーザー名\Documents\openMSX\share\scripts`
    - **macOS**: `/Users/ユーザー名/Library/Application Support/openMSX/share/scripts`
    - **Linux**: `~/.openMSX/share/scripts`

### 1.3 source命令による直接読み込み
自動読み込みの対象外（`_`付きや別フォルダ）のファイルを読み込むには、コンソールで `source` 命令を使用します。
- `source {C:/path/to/script.tcl}` : 指定したファイルを即座に実行します。
- スクリプト開発中に修正を反映させたい場合、何度でも `source` することで最新の状態に更新できます。

## 2. コンソール (F10) の時短テクニック
openMSXのコンソールは非常に強力なシェル機能を備えています。開発の要です。

- **タブ補完 (Tab)**: コマンド名、変数名、ファイルパスを補完します。
- **履歴操作 (Up / Down)**: 上下矢印キーで、過去に入力したコマンドを呼び出せます。
- **履歴検索 (Ctrl + R)**: 過去の入力履歴からキーワードで検索できます。
- **行頭・行末移動**: `Ctrl + A` で行頭へ、`Ctrl + E` で行末へジャンプします。
- **画面スクロール (PageUp / PageDown)**: コンソールのログを遡って確認できます。
- **即時反映**: ファイル書き換え後は `source [パス]` でリロードするのが基本サイクルです。
- **状態確認**: コンソールで単に `set 変数名` と打てば、現在の値が表示されます。

## 3. 移植性を高めるパス操作と環境変数
どのOS（Windows/Mac/Linux）でも動かすための必須作法です。

- **OSの差を吸収する `file join`**
    - `set path [file join $dir "data" "test.dsk"]`
- **スクリプト自身の場所を取得**
    - `set base [file dirname [info script]]`
    - 自身の隣にあるファイルを相対的に指す際に必須です。
- **システム変数の活用**
    - `$env(OPENMSX_USER_DATA)`: ユーザー設定・保存用フォルダを取得。
    - `$env(OPENMSX_SYSTEM_DATA)`: openMSX本体のインストールフォルダを取得。

## 4. Tclの「マジックワード」と特殊記号
初心者が特につまずきやすい、TclおよびopenMSXスクリプト特有の記述ルールです。

### 4.1 基本コマンド
- **`set` / `unset`**: 変数の代入と削除。
- **`incr`**: 数値を加算。 `incr count` (1増やす)、 `incr count 5` (5増やす)
- **`puts`**: コンソールへの文字列出力。デバッグの基本です。
- **`expr`**: 計算命令。 `set a [expr {$b + 1}]` （これを通さないと計算されません）

### 4.2 記号の意味
- **`$` (変数展開)**: 変数の中身を参照します。 `set b $a`
- **`[` `]` (コマンド置換)**: カッコ内を先に実行し、その結果を外側に渡します。
- **`{ }` (グループ化・非展開)**: 中身を一塊として扱い、内部の変数展開は行いません。
- **`"` `"` (グループ化・展開)**: 中身を一塊として扱い、内部の変数（`$`）を展開します。
- **`\` (エスケープ / 行継続)**:
    - 特殊記号をただの文字として扱う（例: `\$`）。
    - 行末に置くことで、長い命令を次の行へ継続させます。

### 4.3 データの扱いと注意点
- **16進数**: `0x` を付けた値（例: `0xD000`）は数値として計算可能です。比較は `[expr {$addr == 0xD000}]` 内で行います。
- **リスト操作**: `lindex` (取得)、`lappend` (追加)。メモリデータの加工に多用します。
- **制御構造のスペース**: `if` や `for` の条件式 `{ }` の前後には必ずスペースが必要です。

## 5. 名前空間 (namespace) と正しいヘルプ・コールバックの実装
他の機能を破壊せず、公式コマンドのように振る舞わせるための記述方法です。

### 5.1 名前空間の目的・利点と注意点
名前空間を使用することで、安全でメンテナンス性の高いスクリプトが作成できます。

- **【利点】競合の防止**: 自分専用の領域を確保し、他のスクリプトやエミュレータ本体の関数を誤って上書きする事故を防ぎます。
- **【利点】モジュール化**: 関連する変数と関数を一括管理でき、コードの可読性が向上します。
- **【重要】variable と set の使い分け**: 
    - 通常の変数代入には `set` を使いますが、名前空間内の `proc`（関数）から共通変数にアクセスする場合は、まず `variable 変数名` と宣言する必要があります。
    - **比較**: `variable` を書かずに `set count 1` とだけ書くと、それは関数内だけで有効な「ローカル変数」になり、関数が終わると値が消えてしまいます。名前空間に値を保持したい場合は、必ず `variable` で明示してください。
- **【注意】再読み込み時の挙動**: `source` でリロードすると `variable` で初期化した値は上書きされます。状態を保持したい場合は `if {![info exists count]} { variable count 0 }` のように記述します。
- **【利点】コールバックの参照**: `namespace code` を使うことで、外部イベントから自作関数を確実に実行させることができます。

### 5.2 基本的な namespace 構造例

```tcl
namespace eval MyTool {
    # 状態を保持したい場合の初期化例
    if {![info exists count]} { variable count 0 }

    proc increment {} {
        # ここで variable を宣言することで、下の set が名前空間の count を指す
        variable count
        set count [expr {$count + 1}]
        puts "現在のカウント: $count"
    }

    # 公開したい関数を指定
    namespace export increment
}
```

### 5.3 エイリアス（別名）による名前衝突の回避
`increment` のような一般的な名前をエクスポートすると、他の環境と衝突するリスクがあります。これを防ぐために `interp alias` を使用して、安全で短い「別名」を定義します。

**変更適用後の全コード例：**
```tcl
namespace eval MyTool {
    variable count 0

    proc increment {} {
        variable count
        set count [expr {$count + 1}]
        puts "現在のカウント: $count"
    }
}

# インポートは使わず、特定の関数に短い「別名」を付ける
# コンソールからは mt_inc で呼び出し可能になります
interp alias {} mt_inc {} MyTool::increment

# ヘルプの登録も別名に対して行う
set_help_text mt_inc "MyToolのカウントを1増やします（別名版）。"
```
**理由：**
1. **既存コマンドの保護**: 同名のコマンドが存在していても、環境を壊さずに共存できます。
2. **タイピングの短縮**: `MyTool::increment` と打つ手間を省けます。
3. **安全な公開**: 強引な上書き（import -force）を避け、環境に優しいツールになります。

### 5.4 名前衝突をより強固に回避する設計
さらに安全性を高めるには、名前空間自体にユニークなプレフィックス（著者名等）を付けます。

```tcl
# 著者名やプロジェクト名を冠した名前空間
namespace eval Uniskie_PowerTool {
    variable data 0
    proc show {} { ... }
}
```
このようにすることで、名前空間が意図せず他人の空間と「マージ（統合）」されて、内部変数が書き換えられる事故を物理的に防げます。

## 6. 公式スクリプトに学ぶ「逆引き」実践カタログ
`share/scripts` 内の公式ファイル（主に `_` 付き）は、最高の機能サンプル集です。

### 6.1 サウンド・ミキサー制御
- `_mixer_widgets.tcl`: `mixer` コマンドによる音量・バランス制御の基本。
- `vgm_recorder.tcl`: 音源チップごとの録音・チャンネル管理の自動化。
- `_music_keyboard.tcl`: `debug read` でチップ内部を読み、鳴っている音階を取得。
- `_sound_log.tcl`: 特定の音源のみをファイルに記録する手法。

### 6.2 デバッグ・解析・出力
- `_show_poked.tcl`: `debug set_watchpoint` によるメモリ変化監視の決定版。
- `_disasm.tcl`: `debug disasm` による実行中コードの逆アセンブル出力。
- `_vdp.tcl`: VDPレジスタの状態読み出し。
- `_reg_display.tcl`: CPUレジスタ値をリアルタイムに取得・表示。
- `_screenshot.tcl`: スクリーンショットの管理、PNG/BMP形式指定の制御。

### 6.3 画面表示 (OSD)
- `_osd_widgets.tcl`: `osd create` でFPS、メッセージ、メーターを表示。
- `_leds.tcl`: LED状態（CapsLock等）に連動して描画を更新。
- `_visualmsx.tcl`: 独自のグラフィカルUIを構築する高度な例。

### 6.4 自動化・イベント制御
- `_autofire.tcl`: `after`（周期実行）による連射実装。
- `_autopause.tcl`: フォーカス外れ等のイベント検知・制御。
- `_reverse.tcl`: リバース（巻き戻し）機能との同期制御。
- `_callback.tcl`: 画面更新やステートロード等のイベントに対するコールバック登録。
- `_training.tcl`: ユーザー入力をリストに記録し、繰り返し再生。

### 6.5 lazy.tcl による効率的なコマンド管理
- **役割**: openMSXの起動時間を短縮するための仕組みです。
- **動作**: 起動時にすべてを読み込まず、コマンドが呼ばれた瞬間に該当ファイルをロードします。自作スクリプトを `_` 付きで保存することで、この仕組みの恩恵を受けられます。

## 7. 運用のアドバイス（最短ルート）
1. やりたい事に近い公式スクリプトを `share/scripts` から探し、キーワード検索する。
2. その `proc` の中身をコピーし、自分の `namespace eval` 内にペーストして改造する。
3. OS依存を避けるため `$env(OPENMSX_USER_DATA)` と `file join`（またはスラッシュ区切り）を使う。
4. 起動時に読み込まれるよう `_` なしの名前で `share/scripts` 内に保存し、コンソールで調整する。