<a name="contents"></a>

# コンテンツ

[はじめに](#introduction)

1. [プログラマブルペリフェラルインターフェース](#chapter_1)
    + [PPIポートA（I/OポートA8H）](#ppi_port_a)
    + [エクスパンダー](#expanders)
    + [PPIポートB（I/OポートA9H）](#ppi_port_b)
    + [PPIポートC（I/OポートAAH）](#ppi_port_c)
    + [PPIモードポート（I/OポートABH）](#ppi_mode_port)
2. [ビデオ ディスプレイ プロセッサ](#chapter_2)
    + [データポート（I/Oポート98H）](#data_port)
    + [コマンドポート（I/Oポート99H）](#command_port)
    + [アドレスレジスタ](#address_register)
    + [VDPステータスレジスタ](#vdp_status_register)
    + [VDPモードレジスタ](#vdp_mode_registers)
    + [モードレジスタ0](#mode_register_0)
    + [モードレジスタ1](#mode_register_1)
    + [モードレジスタ2](#mode_register_2)
    + [モードレジスタ3](#mode_register_3)
    + [モードレジスタ4](#mode_register_4)
    + [モードレジスタ5](#mode_register_5)
    + [モードレジスタ6](#mode_register_6)
    + [モードレジスタ7](#mode_register_7)
    + [画面モード](#screen_modes)
    + [40x24テキストモード](#40x24_text_mode)
    + [32x24テキストモード](#32x24_text_mode)
    + [グラフィックモード](#graphics_mode)
    + [マルチカラーモード](#multicolour_mode)
    + [スプライト](#スプライト)
3. [プログラマブルサウンドジェネレータ](#chapter_3)
    + [アドレスポート（I/OポートA0H）](#address_port)
    + [データ書き込みポート（I/OポートA1H）](#data_write_port)
    + [データ読み取りポート（I/OポートA2H）](#data_read_port)
    + [レジスタ0と1](#registers_0_and_1)
    + [レジスタ2と3](#registers_2_and_3)
    + [レジスタ4と5](#registers_4_and_5)
    + [レジスタ6](#register_6)
    + [レジスタ7](#register_7)
    + [レジスタ8](#register_8)
    + [レジスタ9](#register_9)
    + [レジスタ10](#register_10)
    + [レジスタ11と12](#registers_11_and_12)
    + [レジスタ13](#register_13)
    + [レジスタ14](#register_14)
    + [レジスタ15](#register_15)
4. [ROM BIOS](#chapter_4)
    + [データ領域](#data_areas)
    + [用語](#用語)
5. [ROM BASICインタープリタ](#chapter_5)
6. [メモリマップ](#chapter_6)
    + [ワークスペースエリア](#workspace_area)
    + [ザ・フック](#the_hooks)
7. [マシンコードプログラム](#chapter_7)
    + [キーボードマトリックス](#keyboard_matrix)
    + [40列グラフィックテキスト](#40_column_graphics_text)
    + [文字列バブルソート](#string_bubble_sort)
    + [グラフィック画面ダンプ](#graphics_screen_dump)
    + [キャラクターエディター](#character_editor)

コンテンツの著作権は 1985 Avalon Software に帰属します<br>
アイバーレーン、カウリー、ミッドドックス、UB8 2JD

MSX は Microsoft Corp. の商標です。<br>
Z80 は Zilog Corp. の商標です。<br>
ACADEMY は Alfred の商標です。

<br><br><br>

<a name="introduction"></a>

# 導入


## <a name="aims"></a>目的

本書はMSXコンピュータとその動作原理について解説しています。技術的および商業的な理由から、MSXコンピュータメーカーはエンドユーザーに対し、自社マシンの設計に関する情報を限定的にしか提供していません。通常、Microsoft MSX BASICの詳細な説明とシステムハードウェアの概要が記載されています。このレベルの資料は一般ユーザーにとっては十分ですが、より高度なプログラミングを行うユーザーにとっては、どうしても情報が不足してしまう可能性があります。

本書の目的は、MSX標準のハードウェアとソフトウェアについて、最も要求の厳しいユーザーであるマシンコードプログラマーを満足させるのに十分なレベルで詳細に解説することです。プログラミング入門書ではなく、必然的に技術的な内容となっています。本書では、読者が既にZ80マイクロプロセッサのマシンコードレベルを理解しているか、あるいは他の方法で習得する予定であることを前提としています。Z80に関する汎用書籍は既に数多く出版されているため、その特性について説明しても、広く入手可能な情報と重複するだけとなります。

<a name="organization"></a>

## Organization

MSX 標準では、MSX コンピュータの主要な機能コンポーネントとして以下を規定しています。

1. Zilog Z80マイクロプロセッサ
2. Intel 8255 プログラマブル・ペリフェラル・インターフェース
3. Texas 9929 ビデオ ディスプレイ プロセッサ
4. General Instrument 8910 プログラマブルサウンドジェネレータ
5. 32 KB MSX ベーシック ROM
6. 最低8KBのRAM

MSXコンピュータの設計には明らかに多数の追加コンポーネントが含まれていますが、それらはすべて小規模でプログラム不可能なものであり、したがってユーザーからは「見えない」ものです。メーカーは一般的に、これらの小規模コンポーネントの選択に関してかなりの自由度を持っています。プログラム可能なコンポーネントは変更できないため、プログラマーにとってはすべてのMSXマシンが同一です。

[第1章](chapter_1)、[2章](chapter_2)、[3章](chapter_3)では、それぞれプログラマブル・ペリフェラル・インターフェース、ビデオ・ディスプレイ・プロセッサ、プログラマブル・サウンド・ジェネレータの動作について説明します。これら3つのデバイスは、Z80と標準的なMSXマシン上の周辺ハードウェア間のインターフェースを提供します。これらはすべて、Z80のI/O（入出力）バス上に存在します。

[第4章](chapter_4)では、MSX ROMの最初の部分に含まれるソフトウェアについて説明します。ROMのこのセクションは、マシンのハードウェアを細部まで制御することに関係しており、ROM BIOS（Basic Input Output System）と呼ばれます。キーボードやビデオドライバなど、マシンコードプログラマに必要なほとんどの機能がすぐに利用できるように構成されています。

[第5章](chapter_5)では、ROMの残りの部分に含まれるソフトウェア、Microsoft MSX BASICインタープリタについて説明します。このプログラムは主にテキスト駆動型であるため、プログラマにとってはあまり役に立ちませんが、詳しく調べてみると、メーカーが文書化していない点が数多くあることがわかります。

[第6章](chapter_6)では、システムメモリの構成について解説します。特に、F380HからFFFFHまでのRAM領域であるワークスペース領域に焦点を当てます。この領域はBIOSとBASICインタープリタによってスクラッチパッドとして使用され、あらゆるアプリケーションプログラムに役立つ多くの情報が含まれています。

[第 7 章](#chapter_7) では、ROM 機能を活用して設計の労力を最小限に抑えるマシン コード プログラムの例をいくつか示します。

本書には欠陥は一切ございません。もし欠陥があるとお気づきでしたら、ぜひ著者までご連絡ください。本書はウォーキング・ナイトメアに捧げられています。

<br><br><br>

<a name="chapter_1"></a>

# 1. プログラマブルペリフェラルインターフェース

8255 PPIは、A、B、Cと呼ばれる3つの8ビットデータポートとモードポートで構成される汎用パラレルインターフェースデバイスです。Z80からは4つのI/Oポートとして認識され、キーボード、メモリスイッチハードウェア、カセットモーター、カセット出力、Caps Lock LED、キークリックオーディオ出力を制御できます。PPIが初期化されると、特定のハードウェアへのアクセスは、関連するI/Oポートへの書き込みまたは読み取りのみで可能になります。

<a name="ppi_port_a"></a>

## PPIポートA（I/OポートA8H）

<a name="figure1"></a>![][CH01F01]

**図1:** プライマリスロットレジスタ

この出力ポートは、MSX用語ではプライマリスロットレジスタと呼ばれ、メモリスイッチングハードウェアを制御するために使用されます。Z80マイクロプロセッサは64KBのメモリにしか直接アクセスできません。この制限は現在では厳しすぎると考えられており、最近のパーソナルコンピュータのいくつかではこれを克服する手段が採用されています。

MSXマシンは同一アドレスに複数のメモリデバイスを搭載でき、Z80は必要に応じていずれか1つを切り替えることができます。プロセッサのアドレス空間は、プライマリスロット0～3と呼ばれる4つの独立した64KB領域に「横方向に」複製されているとみなされます。各領域は、通常のZ80バス信号に加えて、独自のスロット選択信号を受信します。プライマリスロットレジスタの内容によって、どのスロット選択信号がアクティブになり、どのプライマリスロットが選択されるかが決まります。

柔軟性を高めるため、Z80アドレス空間の各16KB「ページ」は、異なるプライマリスロットから選択できます。[図1](#figure1)に示すように、各ページのプライマリスロット番号を定義するには、プライマリスロットレジスタの2ビットが必要です。

MSX ROMが電源投入時に最初に行う処理は、各スロットのページ2と3（8000H～FFFFH）にあるRAMを検索することです。次に、プライマリスロットレジスタが設定され、該当するスロットが選択されます。これにより、RAMが永続的に使用可能になります。MSXマシンのメモリ構成は、BASIC文でプライマリスロットレジスタの設定を表示することで確認できます。
```
    PRINT RIGHT$("0000000"+BIN$(INP(&HA8)),8)
```
例えば、Toshiba HX10では「10100000」が生成されますが、ページ3と2（RAM）はどちらもプライマリスロット2から、ページ1と0（MSX ROM）はプライマリスロット0から取得されます。MSX ROMは、電源投入時にハードウェアによって選択されるスロットであるため、メーカーは常にプライマリスロット0に配置する必要があります。その他のメモリデバイス（RAMや追加ROMなど）は、メーカーによって任意のスロットに配置できます。

典型的な英国製マシンは、MSX ROMを搭載したプライマリスロットを1つ、64KBのRAMを搭載したプライマリスロットを1つ、そして外部コネクタ用のスロットを2つ備えています。ほとんどの日本製マシンはこれらの外部スロットそれぞれにカートリッジタイプのコネクタを備えていますが、英国製マシンは通常、カートリッジコネクタとIDCコネクタをそれぞれ1つずつ備えています。

<a name="expanders"></a>

## エクスパンダー

システムメモリは、エクスパンダインターフェースを使用することで、理論上最大16個の64KB領域まで拡張できます。エクスパンダをプライマリスロットに挿入すると、プライマリスロット1個ではなく、0～3の番号が付けられた4個の64KBセカンダリスロットが使用可能になります。各エクスパンダには、セカンダリスロットレジスタと呼ばれる独自のローカルハードウェアが搭載されており、どのセカンダリスロットをプライマリスロットに表示するかを選択します。従来と同様に、異なるセカンダリスロットからページを選択できます。

<a name="figure2"></a>![][CH01F02]

**図2:** セカンダリスロットレジスタ

各セカンダリスロットレジスタは、実際には8ビットの読み書きラッチですが、エクスパンダハードウェアによってプライマリスロットのメモリ位置FFFFHとして認識されます。特定のエクスパンダ上でこの位置にアクセスするには、通常、まずそのプライマリスロットのページ3（C000H～FFFFH）をプロセッサアドレス空間に切り替える必要があります。その後、セカンダリスロットレジスタを変更し、必要に応じてページ3を元のプライマリスロット設定に戻します。エクスパンダ内のメモリアクセスは、やや複雑なプロセスになる場合があります。

プライマリスロットに正しくアクセスするには、そこに通常のRAMが搭載されているか、それともエクスパンダが搭載されているかを判断する何らかの方法が必要であることは明らかです。これを実現するために、セカンダリスロットレジスタは、リードバック時にその内容を反転するように設計されています。電源投入時には、各プライマリスロットのRAM検索メモリ位置FFFFHが検査され、正常に動作しているか、それともスロットにエクスパンダが搭載されているかが判断されます。これらのテストの結果は、後で使用するためにワークスペース領域のシステムリソースマップ[EXPTBL](#exptbl)に保存されます。これは、セカンダリスロットレジスタに実際に設定値が格納されている場合、テストを実行するのが困難なため、電源投入時に実行されます。

メモリの切り替えは、特にエクスパンダの制御に必要な階層的なメカニズムを考慮すると、明らかに細心の注意を要する領域です。プログラムが実行中のページ、あるいはスタックを含むページ（使用中の場合）を切り替えないように注意が必要です。MSX ROMのBIOSセクションには、マシンコードプログラマがプロセスを簡素化するための標準ルーチンが多数用意されています。

BASICインタープリタ自体には、拡張ROMにアクセスする方法が4つあります。最初の3つは、ページ1（4000H～7FFFH）に配置されたマシンコードROMで使用されます。

1. フック([第6章](chapter_6))
2. 「`CALL`」ステートメント（[第5章](#chapter_5)）。
3. 追加のデバイス名([第5章](#chapter_5))。

BASICインタープリタは、電源投入時のROMサーチ中にページ2（8000H～BFFFH）で検出されたBASICプログラムROMを実行することもできます。BASICインタープリタは、他のメモリデバイスの背後に隠れたRAMを使用することはできません。この制限は、既存のプログラムを新しい、より複雑なマシン向けに移植することがいかに難しいかを反映しています。IBM PCで利用可能なMicrosoft BASICのバージョンにも同様の状況があります。1MBのメモリ空間のうち、プログラムの保存に使用できるのはわずか64KBです。

<a name="ppi_port_b"></a>

## PPIポートB（I/OポートA9H）

<a name="figure3"></a>![][CH01F03]

**図3**

この入力ポートは、キーボードの現在選択されている行から8ビットの列データを読み取るために使用されます。MSXキーボードは、11行×8列の常開スイッチからなるソフトウェアスキャン方式のマトリックスです。現在のマシンでは通常、キーは0行目から8行目までしか配置されていません。キーの押下から文字コードへの変換は、MSX ROM割り込みハンドラによって実行されます。この処理については[第4章](chapter_4)で説明します。

<a name="ppi_port_c"></a>

## PPI ポート C (I/O ポート AAH)

<a name="figure4"></a>![][CH01F04]

**図4**

この出力ポートは様々な機能を制御します。4つのキーボード行選択ビットは、0から10までの11行のキーボード行のうち、どの行をPPIポートBで読み取るかを選択します。

Cas Motor ビットはカセット モーター リレーの状態を決定します: 0 = オン、1 = オフ。

Cas Outビットはフィルタリングと減衰を経て、MIC信号としてカセットDINソケットに送られます。カセットトーン生成はすべてソフトウェアで実行されます。

Cap LED ビットは Caps Lock LED の状態を決定します: 0 = オン、1 = オフ。

キークリック出力は減衰され、プログラマブルサウンドジェネレーターからのオーディオ出力とミックスされます。実際に音を生成するには、このビットのオン/オフを切り替える必要があります。

ROM BIOSには、このポートで利用可能なすべての機能にアクセスするための標準ルーチンが用意されていることに注意してください。可能な限り、ハードウェアを直接操作するよりも、これらのルーチンを使用することをお勧めします。

<a name="ppi_mode_port"></a>

## PPIモードポート（I/OポートABH）

<a name="figure5"></a>![][CH01F05]

**図5:** PPIモードの選択

このポートはPPIの動作モードを設定するために使用されます。MSXハードウェアは特定の構成でのみ動作するように設計されているため、いかなる状況においてもこのポートを変更しないでください。詳細は完全性のためにのみ提供されています。

PPIモードを変更するにはビット7を1にする必要があります。ビット7が0の場合、PPIは[図6](#figure6)に示す単一ビットのセット/リセット機能を実行します。

A&CモードビットはポートAの動作モードとポートCの上位4ビットのみを決定します: 00=通常モード(MSX)、01=ストローブモード、10=双方向モード

A Dir モードはポート A の方向を決定します: 0 = 出力 (MSX)、1 = 入力。

C Dir ビットはポート C の上位 4 ビットのみの方向を決定します: 0 = 出力 (MSX)、1 = 入力。

B および C モード ビットは、ポート B の動作モードとポート C の下位 4 ビットのみを決定します。0 = 通常モード (MSX)、1 = ストローブ モード。

B Dir ビットはポート B の方向を決定します: 0 = 出力、1 = 入力 (MSX)。

C DirビットはポートCの下位4ビットのみの方向を決定します: 0=出力(MSX)、1=入力

<a name="figure6"></a>![][CH01F06]

**図6:** PPIビットのセット/リセット

PPIモードポートは、ビット7が0のときにポートCの任意のビットを直接セットまたはリセットするために使用できます。0から7までのビット番号によって、どのビットが影響を受けるかが決まります。新しい値はセット/リセットビットによって決まります：0=リセット、1=セット。このモードの利点は、単一の出力を簡単に変更できることです。例えば、Caps Lock LEDはBASICステートメント「OUT &HAB,12」で点灯し、「OUT &HAB,13」で消灯できます。

<br><br><br>

<a name="chapter_2"></a>

# 2. ビデオディスプレイプロセッサ

9929 VDPには、ビデオ表示を生成するために必要なすべての回路が搭載されています。Z80からは、[データポート](#data_port)と[コマンドポート](#command_port)と呼ばれる2つのI/Oポートとして認識されます。VDPには16KBのVRAM（ビデオRAM）が搭載されており、その内容が画面イメージを定義しますが、Z80からは直接アクセスできません。そのため、VRAMの内容を変更したり、VDPのさまざまな動作条件を設定したりするために、2つのI/Oポートを使用する必要があります。

<a name="data_port"></a>

## データポート（I/Oポート98H）

データポートは、VRAMへの単一バイトの読み取りまたは書き込みに使用されます。VDPは、VRAM内の特定の位置を指す内部アドレスレジスタを備えています。データポートを読み取ると、そのVRAM位置からバイトが入力され、データポートに書き込むと、そのVRAM位置に格納されます。読み取りまたは書き込み後、[アドレスレジスタ](#address_register)は自動的にインクリメントされ、次のVRAM位置を指します。データポートへの連続した読み取りまたは書き込みによって、連続するバイトにアクセスできます。

<a name="command_port"></a>

## コマンドポート（I/Oポート99H）

コマンド ポートは次の 3 つの目的で使用されます。

1. [データ ポート](#data_port) [アドレス レジスタ](#address_register)を設定します。
2. [VDPステータスレジスタ](#vdp_status_register)を読み取ります。
3. [VDP モード レジスタ](#vdp_mode_registers) の 1 つに書き込みます。

<a name="address_register"></a>

## アドレスレジスタ

[データポート](#data_port)アドレスレジスタは、後続のアクセスが読み取りか書き込みかに応じて異なる方法で設定する必要があります。アドレスレジスタは、まずLSB（最下位バイト）を[コマンドポート](#command_port)に書き込み、次にMSB（最上位バイト）を書き込むことで、0000Hから3FFFHまでの任意の値に設定できます。MSBのビット6と7は、VDPによって、アドレスレジスタが後続の読み取り用か書き込み用かを判断するために使用されます。

<a name="figure7"></a>![][CH02F07]

**図7:** VDPアドレスの設定

LSBとMSBの書き込みの間にVDPへの他のアクセスが行われないようにすることが重要です。そうしないと同期が崩れてしまいます。MSX ROM割り込みハンドラはバックグラウンドタスクとして[VDPステータスレジスタ](#vdp_status_register)を継続的に読み取っているため、必要に応じて割り込みを無効にする必要があります。

<a name="vdp_status_register"></a>

## VDPステータスレジスタ

[コマンドポート](#command_port)を読み取ると、VDPステータスレジスタの内容が入力されます。このレジスタには、以下のような様々なフラグが含まれています。

<a name="figure8"></a>![][CH02F08]

**図8:** VDPステータスレジスタ

第 5 スプライト番号ビットには、第 5 スプライト フラグをトリガーするスプライトの番号 (0 ～ 31) が含まれます。

一致フラグは通常0ですが、スプライトに1つ以上の重なり合うピクセルがある場合は1に設定されます。ステータスレジスタを読み出すと、このフラグは0にリセットされます。一致フラグは、ビデオフレーム中に各ピクセルが生成されるたびにのみチェックされます。UKマシンでは、これは20ミリ秒ごとに行われます。高速で移動するスプライトがチェックの間に互いに重なり合う場合、一致フラグは設定されません。

5番目のスプライトフラグは通常0ですが、ピクセルラインに4つ以上のスプライトがある場合は1に設定されます。ステータスレジスタを読み出すと、このフラグは0にリセットされます。

フレームフラグは通常0ですが、ビデオフレームの最後のアクティブラインの終了時に1にセットされます。フレームレートが50HzのUKマシンでは、このフラグは20msごとに発生します。ステータスレジスタを読み出すと、このフラグは0にリセットされます。VDPからは、同じレートでZ80割り込みを生成する関連出力信号があり、これがMSX ROM割り込みハンドラを駆動します。

<a name="vdp_mode_registers"></a>

## VDPモードレジスタ

VDPには、0から7までの番号が付けられた8つの書き込み専用レジスタがあり、これらがVDPの全般的な動作を制御します。特定のレジスタを設定するには、まずデータバイトを書き込み、次にレジスタ選択バイトを[コマンドポート](#command_port)に書き込みます。レジスタ選択バイトの下位3ビットにはレジスタ番号（10000RRR）が含まれます。モードレジスタは書き込み専用で、読み出すことはできないため、MSX ROMはRAMのワークスペース領域（[第6章](chapter_6)）に8つのレジスタの正確なコピーを保持します。VDP機能にMSX ROM標準ルーチンを使用することで、このレジスタイメージが正しく更新されます。

<a name="mode_register_0"></a>

## モードレジスタ 0

<a name="figure9"></a>![][CH02F09]

**図9**

外部 VDP ビットは、外部 VDP 入力を有効にするか無効にするかを決定します: 0 = 無効、1 = 有効。

M3 ビットは 3 つの VDP モード選択ビットの 1 つです。[モード レジスタ 1](#mode_register_1) を参照してください。

<a name="mode_register_1"></a>

## モードレジスタ1

<a name="figure10"></a>![][CH02F10]

**図10**

拡大ビットは、スプライトのサイズが通常か 2 倍かを決定します: 0 = 通常、1 = 2 倍。

サイズ ビットは、各スプライト パターンが 8x8 ビットになるか 16x16 ビットになるかを決定します: 0=8x8、1=16x16。

M1 ビットと M2 ビットは、[モード レジスタ 0](#mode_register_0) の M3 ビットと組み合わせて VDP の動作モードを決定します。

```
M1 M2 M3
0  0  0  32x24 Text Mode
0  0  1  Graphics Mode
0  1  0  Multicolour Mode
1  0  0  40x24 Text Mode
```

割り込み有効ビットは、VDP からの割り込み出力信号を有効または無効にします。0 = 無効、1 = 有効。

ブランクビットは、ビデオディスプレイ全体の有効/無効を切り替えるために使用されます。0=無効、1=有効。ディスプレイがブランク状態の場合、画面は境界線と同じ色になります。

4/16K ビットは、VDP VRAM アドレス指定特性を 4 KB または 16 KB チップに適合するように変更します: 0=4 KB、1=16 KB。

<a name="mode_register_2"></a>

## モードレジスタ2

<a name="figure11"></a>![][CH02F11]

**図11**

モードレジスタ2は、VDP VRAM内のネームテーブルの開始アドレスを定義します。使用可能な4ビットは、完全なアドレスの00BB BB00 0000 0000の位置のみを指定するため、レジスタの内容が0FHの場合、ベースアドレスは3C00Hになります。

<a name="mode_register_3"></a>

## モードレジスタ3

<a name="figure12"></a>![][CH02F12]

**図12**

モードレジスタ3は、VDP VRAM内のカラーテーブルの開始アドレスを定義します。使用可能な8ビットは、アドレス全体のうち00BB BBBB BB00 0000の位置のみを指定するため、レジスタの内容がFFHの場合、ベースアドレスは3FC0Hになります。[グラフィックモード](#graphics_mode)では、ビット7のみが有効であるため、ベースアドレスは0000Hまたは2000Hになります。ビット0～6は必ず1にしてください。

<a name="mode_register_4"></a>

## モードレジスタ4

<a name="figure13"></a>![][CH02F13]

**図13**

モードレジスタ4は、VDP VRAM内の文字パターンテーブルの開始アドレスを定義します。使用可能な3ビットは、アドレス全体のうち00BB B000 0000 0000の位置のみを指定するため、レジスタの内容が07Hの場合、ベースアドレスは3800Hになります。[グラフィックモード](#graphics_mode)ではビット2のみが有効であるため、ベースアドレスは0000Hまたは2000Hになります。ビット0とビット1は必ず1にしてください。

<a name="mode_register_5"></a>

## モードレジスタ5

<a name="figure14"></a>![][CH02F14]

**図14**

モードレジスタ5は、VDP VRAM内のスプライト属性テーブルの開始アドレスを定義します。使用可能な7ビットは、フルアドレスの00BB BBBB B000 0000の位置のみを指定するため、レジスタの内容が7FHの場合、ベースアドレスは3F80Hになります。

<a name="mode_register_6"></a>

## モードレジスタ6

<a name="figure15"></a>![][CH02F15]

**図15**

モードレジスタ6は、VDP VRAM内のスプライトパターンテーブルの開始アドレスを定義します。使用可能な3ビットは、アドレス全体のうち00BB B000 0000 0000の位置のみを指定するため、レジスタの内容が07Hの場合、ベースアドレスは3800Hになります。

<a name="mode_register_7"></a>

## モードレジスタ7

<a name="figure16"></a>![][CH02F16]

**図16**

ボーダーカラービットは、4つのVDPモードすべてにおいて、アクティブビデオ領域を囲む領域の色を決定します。また、[40x24テキストモード](#40x24_text_mode)では、画面上のすべての0ピクセルの色も決定します。ボーダー領域は実際には画面全体に広がっていますが、アクティブ領域では、その上にあるピクセルが透明である場合にのみ表示されることに注意してください。

テキストカラー1ビットは、[40x24テキストモード](#40x24_text_mode)におけるすべての1ピクセルの色を決定します。他の3つのモードでは、カラーテーブルの使用により柔軟性が高められるため、テキストカラー1ビットは効果がありません。VDPカラーコードは以下のとおりです。

```
0 Transparent   4 Dark Blue      8 Red              12 Dark Green
1 Black         5 Light Blue     9 Bright Red       13 Purple
2 Green         6 Dark Red      10 Yellow           14 Grey
3 Light Green   7 Sky Blue      11 Light Yellow     15 White
```

<a name="screen_modes"></a>

## 画面モード

VDPには4つの動作モードがあり、それぞれがわずかに異なる機能を提供します。一般的に、解像度が高くなると、VRAMサイズと更新の複雑さが増します。専用アプリケーションでは、これらのハードウェアとソフトウェアのコストは重要な考慮事項です。MSXマシンではこれらは重要ではありません。そのため、特定のモードへの標準化がもっと図られなかったのは残念です。[グラフィックモード](#graphics_mode)は、わずかな制約を除けば、他のモードのすべての機能を十分に実行できます。

VDPの使用において更なる困難が生じているのは、その設計において、ほとんどのテレビで採用されているオーバースキャンが十分に考慮されていなかったためです。その結果、画面端の文字が欠落してしまうため、ビデオ関連のMSXソフトウェアはすべて特殊な画面サイズを前提とせざるを得なくなりました。英国製のMSX機は通常、[40x24テキストモード](#40x24_text_mode)で利用可能な中央の37文字のみを使用します。一方、NTSC（米国テレビ規格委員会）ビデオ出力を備えた日本のMSX機は、中央の39文字を使用します。

プログラマーの観点から見ると、VDPの中心的な要素はネームテーブルです。これは、VRAMに保持されるシングルバイト文字コードのシンプルなリストです。[40x24テキストモード](#40x24_text_mode)では960バイト、[32x24テキストモード](#32x24_text_mode)、[グラフィックスモード](#graphics_mode)、[マルチカラーモード](#multicolour_mode)では768バイトの長さです。ネームテーブルの各位置は、画面上の特定の位置に対応しています。

VDPはビデオフレーム中に、ネームテーブルからベース文字コードから順に各文字コードを読み取ります。各文字コードが読み取られるたびに、対応する8×8のピクセルパターンが文字パターンテーブルで検索され、画面に表示されます。このように、ネームテーブルの文字コードまたは文字パターンテーブルのピクセルパターンを変更することで、画面の外観を変更できます。

VDP にはハードウェア カーソル機能がないため、必要な場合はソフトウェアで生成する必要があることに注意してください。

<a name="40x24_text_mode"></a>

## 40x24 テキストモード

名前テーブルは、0000H から 03BFH までの 960 バイトの VRAM を占有します。

<a name="figure17"></a>![][CH02F17]

**図17:** 40x24 名前テーブル

パターンテーブルは、VRAMの0800Hから0FFFHまでの2KBを占有します。各8バイトブロックには、文字コードのピクセルパターンが含まれます。

<a name="figure18"></a>![][CH02F18]

**図18:** 文字パターンブロック（図では65番 = 'A'）

最初のブロックには文字コード0のパターンが、2番目のブロックには文字コード1のパターンが、そして文字コード255まで続きます。このモードでは、実際に表示されるのは左端の6ピクセルのみであることに注意してください。このモードにおける0と1のピクセルの色は、VDP [モードレジスタ7](#mode_register_7)によって定義され、初期値は青と白です。

<a name="32x24_text_mode"></a>

## 32x24 テキストモード

名前テーブルは、VRAMの1800Hから1AFFHまでの768バイトを占有します。[40x24テキストモード](#40x24_text_mode)と同様に、通常の操作では文字コードをテーブル内の必要な位置に配置します。「`VPOKE`」ステートメントを使用すると、画面レイアウトに慣れることができます。

<a name="figure19"></a>![][CH02F19]

**図19:** 32x24 名前テーブル

文字パターンテーブルは、VRAMの0000Hから07FFHまでの2KBを占有します。その構造は[40x24テキストモード](#40x24_text_mode)と同じで、8x8パターンの8ピクセルすべてが表示されます。

境界の色は VDP [モード レジスタ 7](#mode_register_7) で定義され、初期値は青です。追加のテーブルであるカラー テーブルが、0 と 1 のピクセルの色を決定します。これは、VRAM の 2000H から 201FH までの 32 バイトを占めます。カラー テーブルの各エントリは、8 つの文字コードのグループの 0 と 1 のピクセルの色を定義します。下位 4 ビットが 0 のピクセルの色を定義し、上位 4 ビットが 1 のピクセルの色を定義します。テーブルの最初のエントリは文字コード 0 から 7 の色を定義し、2 番目は文字コード 8 から 15 の色を定義し、これを 32 エントリ定義します。MSX ROM はすべてのエントリを同じ値 (青と白) に初期化し、個別に変更する機能は提供していません。

<a name="graphics_mode"></a>

## グラフィックモード

名前テーブルは、VRAMの1800Hから1AFFHまでの768バイトを占有します。これは[32x24テキストモード](#32x24_text_mode)と同じです。テーブルは、文字コードシーケンス0から255を3回繰り返して初期化され、その後はそのまま残されます。このモードでは、通常動作中に変更されるのは文字パターンテーブルです。

文字パターン テーブルは、0000H から 17FFH までの 6 KB の VRAM を占有します。その構造はテキスト モードと同じですが、文字セットは含まれず、すべて 0 ピクセルに初期化されます。文字パターン テーブルの最初の 2 KB は名前テーブルの最初の 3 分の 1 の文字コードによってアドレス指定され、次の 2 KB は名前テーブルの中央の 3 分の 1 によって、最後の 2 KB は名前テーブルの最後の 3 分の 1 によってアドレス指定されます。名前テーブルの連続パターンのため、文字パターン テーブル全体はビデオ フレーム中に線形に読み出されます。画面上に点を設定するには、文字パターン テーブル内の対応するビットがどこにあるかを計算し、それをオンにする必要があります。X、Y 座標をアドレスに変換する BASIC プログラムについては、[第 4 章](chapter_4) の [MAPXYC](#mapxyc) 標準ルーチンを参照してください。

<a name="figure20"></a>![][CH02F20]

**図20:** グラフィックス文字パターンテーブル

境界の色は VDP [モード レジスタ 7](#mode_register_7) によって定義され、初期値は青です。カラー テーブルは、VRAM の 2000H から 37FFH までの 6 KB を占有します。文字パターン テーブルからカラー テーブルへはバイト単位で正確にマッピングされますが、0 ピクセルと 1 ピクセルの色を定義するには 1 バイト全体が必要になるため、色の解像度はピクセルの解像度よりも低くなります。カラー テーブル エントリの下位 4 ビットは、対応する 8 ピクセル ライン上のすべての 0 ピクセルの色を定義します。上位 4 ビットは 1 ピクセルの色を定義します。カラー テーブルは、テーブル全体で 0 ピクセルの色と 1 ピクセルの色が青になるように初期化されます。両方の色は同じなので、文字パターン テーブルでビットが設定されたときに 1 つの色を変更する必要があります。

<a name="multicolour_mode"></a>

## マルチカラーモード

名前テーブルはVRAMの0800Hから0AFFHまでの768バイトを占有し、画面マッピングは[32x24テキストモード](#32x24_text_mode)と同じです。テーブルは以下の文字コードパターンで初期化されます。

```
00H to 1FH (Repeated four times)
20H to 3FH (Repeated four times)
40H to 5FH (Repeated four times)
60H to 7FH (Repeated four times)
80H to 9FH (Repeated four times)
A0H to BFH (Repeated four times)
```

[グラフィック モード](#graphics_mode) と同様に、これは単なる文字コード「ドライバー」パターンであり、通常の操作中に変更される文字パターン テーブルです。

文字パターンテーブルは、VRAMの0000Hから05FFHまでの1536バイトを占有します。他のモードと同様に、各文字コードは文字パターンテーブル内の8バイトのブロックにマッピングされます。このモードでは解像度が低いため、8x8パターンを定義するのに実際に必要なのはパターンブロックの2バイトのみです。

<a name="figure21"></a>![][CH02F21]

**図21:** マルチカラーパターンブロック

[図 21](#figure21) からわかるように、2バイトブロックの各4ビットセクションにはカラーコードが含まれており、8x8ピクセルパターンの1象限の色を定義します。パターンブロックの8バイト全体を利用できるように、特定の文字コードは、その文字コードの画面上の位置（つまり、名前テーブル内の位置）に応じて異なる2バイトセクションを使用します。

```
Video row 0, 4, 8, 12, 16, 20   Uses bytes 0 and 1
Video row 1, 5, 9, 13, 17, 21   Uses bytes 2 and 3
Video row 2, 6, 10, 14, 18, 22  Uses bytes 4 and 5
Video row 3, 7, 11, 15, 19, 23  Uses bytes 6 and 7
```

名前テーブルが上記に示す文字コードの特殊ドライバ シーケンスで埋められると、文字パターン テーブルはビデオ フレーム中に線形に読み取られます。

<a name="figure22"></a>![][CH02F22]

**図22:** マルチカラー文字パターンテーブル

境界線の色はVDP [モードレジスタ7](#mode_register_7) によって定義され、初期値は青です。文字パターンテーブルの内容によって直接定義されるため、別途カラーテーブルは存在しません。文字パターンテーブルは初期値として青で塗りつぶされています。

<a name="sprites"></a>

## スプライト

VDPは[40x24テキストモード](#40x24_text_mode)を除くすべてのモードで32個のスプライトを制御できます。スプライトの扱いはすべてのモードで同一であり、キャラクター関連のアクティビティとは独立しています。

スプライト属性テーブルは、VRAMの1B00Hから1B7FHまでの128バイトを占有します。テーブルには4バイトのブロックが32個含まれており、各ブロックはスプライトごとに1つずつ割り当てられます。最初のブロックはスプライト0（「最上位」のスプライト）を制御し、2番目のブロックはスプライト1、というようにスプライト31までを制御します。各ブロックのフォーマットは以下のとおりです。

<a name="figure23"></a>![][CH02F23]

**図23:** スプライト属性ブロック

バイト 0 は、スプライトの左上ピクセルの垂直 (Y) 座標を指定します。座標系は、画面の最上ピクセル ラインの -1 (FFH) から最下ラインの 190 (BEH) までです。-1 未満の値を使用すると、スプライトを画面の上からスライドさせることができます。必要な正確な値は、スプライトのサイズによって決まります。不思議なことに、MSX BASIC では、この座標系を通常のグラフィック範囲 (Y=0 ～ 191) と一致させる試みは行われていません。結果として、スプライトは、画面上で同等のグラフィック ポイントよりも常に 1 ピクセル下になります。スプライト属性ブロックに特別な垂直座標値 208 (D0H) を配置すると、VDP はスプライト属性テーブル内の後続のブロックをすべて無視することに注意してください。つまり、実質的に、それより下のスプライトは画面から消えることになります。

バイト1は、スプライトの左上ピクセルの水平座標（X）を指定します。座標系は、左端のピクセルが0、右端のピクセルが255（FFH）です。この座標系ではスプライトを左からスライドさせる機構がないため、バイト3の特別なビットがその目的で使用されます（後述）。

バイト2は、スプライトパターンテーブルで利用可能な256個の8x8ビットパターンから1つを選択します。VDP [モードレジスタ1](#mode_register_1)のサイズビットが設定されている場合、16x16ビットパターンがそれぞれ32バイトを占め、パターン番号の最下位2ビットは無視されます。したがって、パターン番号0、1、2、3はすべてパターン番号0を選択します。

バイト3の4つのカラーコードビットは、スプライトパターンの1ピクセルの色を定義します。0ピクセルは常に透明です。アーリークロックビットは通常0ですが、1に設定するとスプライトを32ピクセル左にシフトします。これは、水平方向に余分な座標がないため、スプライトが画面の左からスライドインできるようにするためです。

スプライトパターンテーブルは、VRAMの3800Hから3FFFHまでの2KBを占有します。このテーブルには、0から255までの番号が付けられた8x8ピクセルパターンが256個格納されています。VDP [モードレジスタ1](#mode_register_1)のサイズビットが0の場合（8x8スプライト）、各8バイトスプライトパターンブロックは[図18](#figure18)に示す文字パターンブロックと同じ構造になります。サイズビットが1の場合（16x16スプライト）、パターンを定義するには4つの8バイトブロックが必要です（以下の図を参照）。

<a name="figure24"></a>![][CH02F24]

**図24:** 16x16スプライトパターンブロック

<br><br><br>

<a name="chapter_3"></a>

# 3. プログラマブルサウンドジェネレーター

8910 PSGは、3つのサウンドチャンネルを制御するだけでなく、AとBと呼ばれる2つの8ビットデータポートを搭載しており、ジョイスティックとカセット入力を接続します。PSGはZ80からは[アドレスポート](#address_port)、[データ書き込みポート](#data_write_port)、[データ読み取りポート](#data_read_port)と呼ばれる3つのI/Oポートとして認識されます。

<a name="address_port"></a>

## アドレスポート（I/OポートA0H）

PSGには16個の内部レジスタがあり、これらがPSGの動作を完全に定義します。特定のレジスタを選択するには、このポートに0から15までの番号を書き込みます。一度選択されたレジスタには、2つのデータポートを介して繰り返しアクセスできます。

<a name="data_write_port"></a>

## データ書き込みポート（I/OポートA1H）

このポートは、[アドレス ポート](#address_port) によって選択された任意のレジスタへの書き込みに使用されます。

<a name="data_read_port"></a>

## データ読み取りポート（I/OポートA2H）

このポートは、[アドレス ポート](#address_port) によって選択されたレジスタを読み取るために使用されます。

<a name="registers_0_and_1"></a>

## レジスタ0と1

<a name="figure25"></a>![][CH03F25]

**図25**

これら2つのレジスタは、チャンネルAのトーンジェネレータの周波数を定義するために使用されます。可変周波数は、固定マスター周波数をレジスタ0と1に保持された数値で割ることによって生成されます。この数値は1～4095の範囲です。レジスタ0は下位8ビット、レジスタ1は上位4ビットを保持します。PSGは外部周波数1.7897725MHzを16分周し、111,861Hzのトーンジェネレータマスター周波数を生成します。したがって、トーンジェネレータの出力は、111,861Hz（1分周）から27.3Hz（4095分周）までの範囲になります。例えば、中央の「`A`」（440Hz）を生成する場合、レジスタ0と1の分周値は254になります。

<a name="registers_2_and_3"></a>

## レジスタ2と3

これら 2 つのレジスタは、チャネル A と同様にチャネル B のトーン ジェネレーターを制御します。

<a name="registers_4_and_5"></a>

## レジスタ4と5

これら 2 つのレジスタは、チャネル A と同様にチャネル C のトーン ジェネレーターを制御します。

<a name="register_6"></a>

## レジスタ6

<a name="figure26"></a>![][CH03F26]

**図26**

PSGには、3つの矩形波トーンジェネレータに加え、1つのノイズジェネレータが搭載されています。ノイズソースの基本周波数は、トーンジェネレータと同様の方法で制御できます。レジスタ6の下位5ビットには、1から31までの分周値が保持されます。ノイズジェネレータのマスター周波数は、従来通り111,861Hzです。

<a name="register_7"></a>

## レジスタ7

<a name="figure27"></a>![][CH03F27]

**図27**

このレジスタは、3つのチャンネルそれぞれについて、トーンジェネレータとノイズジェネレータの有効/無効を設定します。0=有効、1=無効。また、ジョイスティックとカセットが接続されるインターフェースポートAとBの方向も制御します。0=入力、1=出力。レジスタ7には常に10xxxxxxが格納されている必要があります。そうでないと、PSGのI/Oピンにアクティブなデバイスが接続されているため、PSGが損傷する可能性があります。BASICの「`SOUND`」ステートメントは、レジスタ7のこれらのビットを正しい値に強制的に設定できますが、マシンコードレベルでの保護はありません。

<a name="register_8"></a>

## レジスタ8

<a name="figure28"></a>![][CH03F28]

**図28**

4つの振幅ビットは、チャンネルAの振幅を最小0から最大15まで指定します。モードビットは、固定振幅または変調振幅を選択します。0=固定、1=変調。変調振幅を選択した場合、固定振幅値は無視され、チャンネルはエンベロープジェネレータの出力によって変調されます。

<a name="register_9"></a>

## レジスタ9

このレジスタは、チャネル A と同様にチャネル B の振幅を制御します。

<a name="register_10"></a>

## レジスタ10

このレジスタは、チャネル A と同様にチャネル C の振幅を制御します。

<a name="registers_11_and_12"></a>

## レジスタ11と12

<a name="figure29"></a>![][CH03F29]

**図29**

これら2つのレジスタは、振幅変調に使用される単一のエンベロープ・ジェネレータの周波数を制御します。トーン・ジェネレータの場合、この周波数はレジスタに分周値を設定することで決定されます。分周値は1～65535の範囲で設定でき、レジスタ11は下位8ビット、レジスタ12は上位8ビットを保持します。エンベロープ・ジェネレータのマスター周波数は6991Hzであるため、エンベロープ周波数は6991Hz（1分周）～0.11Hz（65535分周）の範囲となります。

<a name="register_13"></a>

## レジスタ13

<a name="figure30"></a>![][CH03F30]

**図30**

4 つのエンベロープ シェイプ ビットは、エンベロープ ジェネレーターによって生成される振幅変調エンベロープの形状を決定します。

<a name="figure31"></a>![][CH03F31]

**図31**

<a name="register_14"></a>

## レジスタ14

<a name="figure32"></a>![][CH03F32]

**図32**

このレジスタはPSGポートAの読み取りに使用されます。6つのジョイスティックビットは、ジョイスティック上の4つの方向スイッチと2つのトリガーボタンの状態を表します。0=押されている、1=押されていない。また、1つのジョイスティックの代わりに最大6つのパドルを接続することも可能です。ほとんどのMSXマシンには9ピンのジョイスティックコネクタが2つありますが、一度に読み取ることができるのは1つだけです。読み取り対象として選択されるコネクタは、[PSGレジスタ15](#register_15)のジョイスティック選択ビットによって決定されます。

キーボードモードビットは英国仕様のマシンでは使用されません。日本仕様のマシンでは、キーボードの文字セットを決定するためにジャンパーリンクに接続されています。

カセット入力は、カセットEAR出力からの信号を読み取るために使用されます。この信号はコンパレータを通過し、エッジが除去され、デジタルレベルに変換されますが、それ以外は処理されません。

<a name="register_15"></a>

## レジスタ 15

<a name="figure33"></a>![][CH03F33]

**図33**

このレジスタはPSGポートBへの出力に使用されます。下位4ビットはTTLオープンコレクタバッファを介して各ジョイスティックコネクタのピン6および7に接続されます。パドルまたはジョイスティックが接続されている場合、これらのピンは通常1に設定され、入力として機能します。タッチパッドが接続されている場合、ハンドシェイク出力として使用されます。

2つのパルスビットは、ジョイスティックコネクタ1または2に接続されたパドルに短い正方向のパルスを生成するために使用されます。各パドルには、パルス長を制御する可変抵抗器を備えた単安定タイマーが内蔵されています。タイマーがトリガーされると、単安定タイマーがタイムアウトするまでのカウントによって可変抵抗器の位置を判定できます。

ジョイスティック選択ビットは、入力用に PSG ポート A に接続されるジョイスティック コネクタを決定します。0 = コネクタ 1、1 = コネクタ 2。

カナLED出力は英国製マシンでは使用されません。日本製マシンではキーボードモードインジケーターの駆動に使用されます。

<br><br><br>

<a name="chapter_4"></a>

# 4. ROM BIOS

MSX ROMの設計は、マシンコードプログラムを効率的に開発し、確実に動作させる上で非常に重要です。BASICインタープリタ自体も含め、ほぼすべてのプログラムは、動作するために特定の基本関数セットを必要とします。これには、画面ドライバやプリンタドライバ、キーボードデコーダ、その他のハードウェア関連機能が含まれます。これらのルーチンをBASICインタープリタから分離することで、あらゆるアプリケーションプログラムで利用できるようになります。ROMの0000Hから268BHまでのセクションは、主にこれらのルーチンに割り当てられており、ROM BIOS（Basic Input Output System）と呼ばれています。

この章では、ROM BIOS内の認識可能なすべての個別ルーチンの機能について説明します。特に「標準」ルーチンに重点を置いています。これらのルーチンはMicrosoftによってドキュメント化されており、ハードウェアおよびソフトウェアの変更があっても一貫性が維持されることが保証されています。ROMの最初の数百バイトは、これらのルーチンへの固定位置エントリポイントを提供するZ80 JP命令で構成されています。将来のソフトウェアとの互換性を最大限に高めるには、アプリケーションプログラムはROMへの依存をこれらの場所のみに制限する必要があります。ROMの説明は、標準ルーチンへのエントリポイントのリストから始まります。各エントリポイントには簡単なコメントが付与され、詳細な説明はルーチン自体に記載されています。

<a name="data_areas"></a>

## データ領域

ほとんどのユーザーはROMをある程度逆アセンブルしたいと考えるでしょう（完全なリストは約400ページに及びます）。この作業を容易にするために、実行可能なZ80コードを含まないデータ領域を以下に示します。

```
0004H-0007H     185DH-1863H     4B3AH-4B4CH     73E4H-73E4H
002BH-002FH     1B97H-1BAAH     4C2FH-4C3FH     752EH-7585H
0508H-050DH     1BBFH-23BEH     555AH-5569H     7754H-7757H
092FH-097FH     2439H-2459H     5D83H-5DB0H     7BA3H-7BCAH
0DA5H-0EC4H     2CF1H-2E70H     6F76H-6F8EH     7ED8H-7F26H
1033H-105AH     3030H-3039H     70FFH-710CH     7F41H-7FB6H
1061H-10C1H     3710H-3719H     7182H-7195H     7FBEH-7FFFH
1233H-1252H     392EH-3FE1H     71A2H-71B5H
13A9H-1448H     43B5H-43C3H     71C7H-71DAH
160BH-1612H     46E6H-46E7H     72A6H-72B9H
```

これらのデータ領域はUK版ROM用であり、日本語版ROMにはキーボードデコーダーとビデオ文字セットに関して若干の違いがあることに注意してください。ROM間の差異はこれらの領域に限定されており、コードの大部分は両バージョンで同一です。

<a name="terminology"></a>

## 用語

この章では、標準ルーチンとワークスペース領域変数について頻繁に言及します。これらの言及は常に、Microsoft推奨の名称を大文字で使用します。例えば、「[FILVRM](#filvrm) 標準ルーチン」や「[SCRMOD](#scrmod) がセットされる」などです。名称が付いていないサブルーチンは、括弧で囲まれたアドレスで参照します。例えば、「画面がクリアされる ([0777H](#0777h))」などです。Z80ステータスフラグについて言及する場合は、アセンブリ言語の表記規則を使用します。例えば、「フラグC」はキャリーフラグがセットされていることを意味し、「フラグNZ」はゼロフラグがリセットされていることを意味します。「EI」と「DI」は、それぞれ割り込みが有効になっていることと無効になっていることを意味します。

|アドレス   |名前               |to                 |機能
|:---------:|:-----------------:|:-----------------:|--------------------------------------
|0000H      |[CHKRAM](#chkram)  |[02D7H](#02d7h)    |電源投入、RAMチェック
|0004H      |......             |.....              |2バイト、ROM文字セットのアドレス
|0006H      |......             |.....              |1バイト、VDP [データポート](#data_port)番号
|0007H      |......             |.....              |1バイト、VDP [データポート](#data_port)番号
|0008H      |[SYNCHR](#synchr)  |[2683H](#2683h)    |BASICプログラム文字をチェック
|000BH      |......             |.....              |NOP
|000CH      |[RDSLT](#rdslt)    |[01B6H](#01b6h)    |任意のスロットのRAMを読み取る
|000FH      |......             |.....              |NOP
|0010H      |[CHRGTR](#chrgtr)  |[2686H](#2686h)    |次のBASICプログラム文字を取得する
|0013H      |......             |.....              |NOP
|0014H      |[WRSLT](#wrslt)    |[01D1H](#01d1h)    |任意のスロットのRAMに書き込み
|0017H      |......             |.....              |NOP
|0018H      |[OUTDO](#outdo)    |[1B45H](#1b45h)    |現在のデバイスに出力
|001BH      |......             |.....              |NOP
|001CH      |[CALSLT](#calslt)  |[0217H](#0217h)    |任意のスロットのルーチンを呼び出す
|001FH      |......             |.....              |NOP
|0020H      |[DCOMPR](#dcompr)  |[146AH](#146ah)    |レジスタペアHLとDEを比較する
|0023H      |......             |.....              |NOP
|0024H      |[ENASLT](#enaslt)  |[025EH](#025eh)    |任意のスロットを永続的に有効にする
|0027H      |......             |.....              |NOP
|0028H      |[GETYPR](#getypr)  |[2689H](#2689h)    |BASICオペランド型を取得する
|002BH      |......             |.....              |5バイトのバージョン番号
|0030H      |[CALLF](#callf)    |[0205H](#0205h)    |任意のスロットのルーチンを呼び出す
|0033H      |......             |.....              |5つのNOP
|0038H      |[KEYINT](#keyint)  |[0C3CH](#0c3ch)    |割り込みハンドラ、キーボードスキャン
|003BH      |[INITIO](#initio)  |[049DH](#049dh)    |I/Oデバイスの初期化
|003EH      |[INIFNK](#inifnk)  |[139DH](#139dh)    |ファンクションキー文字列を初期化する
|0041H      |[DISSCR](#disscr)  |[0577H](#0577h)    |画面を無効にする
|0044H      |[ENASCR](#enascr)  |[0570H](#0570h)    |画面を有効にする
|0047H      |[WRTVDP](#wrtvdp)  |[057FH](#057fh)    |任意のVDPレジスタに書き込む
|004AH      |[RDVRM](#rdvrm)    |[07D7H](#07d7h)    |VRAMからバイトを読み取る
|004DH      |[WRTVRM](#wrtvrm)  |[07CDH](#07cdh)    |VRAMにバイトを書き込む
|0050H      |[SETRD](#setrd)    |[07ECH](#07ech)    |読み取り用のVDPをセットアップ
|0053H      |[SETWRT](#setwrt)  |[07DFH](#07dfh)    |書き込み用のVDPをセットアップ
|0056H      |[FILVRM](#filvrm)  |[0815H](#0815h)    |VRAMのブロックをデータバイトで埋める
|0059H      |[LDIRMV](#ldirmv)  |[070FH](#070fh)    |VRAMからメモリにブロックをコピー
|005CH      |[LDIRVM](#ldirvm)  |[0744H](#0744h)    |メモリからVRAMにブロックをコピー
|005FH      |[CHGMOD](#chgmod)  |[084FH](#084fh)    |VDPモードの変更
|0062H      |[CHGCLR](#chgclr)  |[07F7H](#07f7h)    |VDPカラーを変更する
|0065H      |......             |.....              |NOP
|0066H      |[NMI](#nmi)        |[1398H](#1398h)    |マスク不可能割り込みハンドラ
|0069H      |[CLRSPR](#clrspr)  |[06A8H](#06a8h)    |すべてのスプライトをクリア
|006CH      |[INITXT](#initxt)  |[050EH](#050eh)    |VDPを[40x24テキストモード](#40x24_text_mode)に初期化します
|006FH      |[INIT32](#init32)  |[0538H](#0538h)    |VDPを[32x24テキストモード](#32x24_text_mode)に初期化します
|0072H      |[INIGRP](#inigrp)  |[05D2H](#05d2h)    |VDPを[グラフィックモード](#graphics_mode)に初期化します
|0075H      |[INIMLT](#inimlt)  |[061FH](#061fh)    |VDPを[マルチカラーモード](#multicolor_mode)に初期化します
|0078H      |[SETTXT](#settxt)  |[0594H](#0594h)    |VDPを[40x24テキストモード](#40x24_text_mode)に設定
|007BH      |[SETT32](#sett32)  |[05B4H](#05b4h)    |VDPを[32x24テキストモード](#32x24_text_mode)に設定
|007EH      |[SETGRP](#setgrp)  |[0602H](#0602h)    |VDPを[グラフィックモード](#graphics_mode)に設定する
|0081H      |[SETMLT](#setmlt)  |[0659H](#0659h)    |VDPを[マルチカラーモード](#multicolour_mode)に設定します
|0084H      |[CALPAT](#calpat)  |[06E4H](#06e4h)    |スプライトパターンのアドレスを計算する
|0087H      |[CALATR](#calatr)  |[06F9H](#06f9h)    |スプライト属性のアドレスを計算する
|008AH      |[GSPSIZ](#gspsiz)  |[0704H](#0704h)    |スプライトのサイズを取得する
|008DH      |[GRPPRT](#grpprt)  |[1510H](#1510h)    |グラフィック画面に文字を印刷する
|0090H      |[GICINI](#gicini)  |[04BDH](#04bdh)    |PSG (GI チップ) の初期化
|0093H      |[WRTPSG](#wrtpsg)  |[1102H](#1102h)    |任意のPSGレジスタに書き込む
|0096H      |[RDPSG](#rdpsg)    |[110EH](#110eh)    |任意のPSGレジスタから読み取る
|0099H      |[STRTMS](#strtms)  |[11C4H](#11c4h)    |音楽のデキューを開始します
|009CH      |[CHSNS](#chsns)    |[0D6AH](#0d6ah)    |文字のキーボードバッファを感知
|009FH      |[CHGET](#chget)    |[10CBH](#10cbh)    |キーボードバッファから文字を取得する(待機)
|00A2H      |[CHPUT](#chput)    |[08BCH](#08bch)    |画面文字出力
|00A5H      |[LPTOUT](#lptout)  |[085DH](#085dh)    |ラインプリンタ文字出力
|00A8H      |[LPTSTT](#lptstt)  |[0884H](#0884h)    |ラインプリンタステータステスト
|00ABH      |[CNVCHR](#cnvchr)  |[089DH](#089dh)    |グラフィックヘッダー付きの文字を変換する
|00AEH      |[PINLIN](#pinlin)  |[23BFH](#23bfh)    |コンソール（エディター）から行を取得します
|00B1H      |[INLIN](#inlin)    |[23D5H](#23d5h)    |コンソール（エディター）から行を取得
|00B4H      |[QINLIN](#qinlin)  |[23CCH](#23cch)    |「`?`」を表示し、コンソール(エディター)から行を取得します。
|00B7H      |[BREAKX](#breakx)  |[046FH](#046fh)    |CTRL-STOPキーを直接チェック
|00BAH      |[ISCNTC](#iscntc)  |[03FBH](#03fbh)    |CRTL-STOPキーをチェック
|00BDH      |[CKCNTC](#ckcntc)  |[10F9H](#10f9h)    |CTRL-STOPキーをチェック
|00C0H      |[BEEP](#beep)      |[1113H](#1113h)    |ビープ音を鳴らす
|00C3H      |[CLS](#cls)        |[0848H](#0848h)    |画面をクリア
|00C6H      |[POSIT](#posit)    |[088EH](#088eh)    |カーソル位置を設定する
|00C9H      |[FNKSB](#fnksb)    |[0B26H](#0b26h)    |ファンクションキーの表示がオンになっているか確認
|00CCH      |[ERAFNK](#erafnk)  |[0B15H](#0b15h)    |ファンクションキーの表示を消去
|00CFH      |[DSPFNK](#dspfnk)  |[0B2BH](#0b2bh)    |ファンクションキーを表示する
|00D2H      |[TOTEXT](#totext)  |[083BH](#083bh)    |VDPをテキストモードに戻す
|00D5H      |[GTSTCK](#gtstck)  |[11EEH](#11eeh)    |ジョイスティックのステータスを取得する
|00D8H      |[GTTRIG](#gttrig)  |[1253H](#1253h)    |トリガーステータスを取得
|00DBH      |[GTPAD](#gtpad)    |[12ACH](#12ach)    |タッチパッドの状態を取得する
|00DEH      |[GTPDL](#gtpdl)    |[1273H](#1273h)    |パドルの状態を取得する
|00E1H      |[TAPION](#tapion)  |[1A63H](#1a63h)    |テープ入力オン
|00E4H      |[TAPIN](#tapin)    |[1ABCH](#1abch)    |テープ入力
|00E7H      |[TAPIOF](#tapiof)  |[19E9H](#19e9h)    |テープ入力オフ
|00EAH      |[TAPOON](#tapoon)  |[19F1H](#19f1h)    |テープ出力オン
|00EDH      |[TAPOUT](#tapout)  |[1A19H](#1a19h)    |テープ出力
|00F0H      |[TAPOOF](#tapoof)  |[19DDH](#19ddh)    |テープ出力オフ
|00F3H      |[STMOTR](#stmotr)  |[1384H](#1384h)    |モーターのオン/オフ
|00F6H      |[LFTQ](#lftq)      |[14EBH](#14ebh)    |音楽キューに残っているスペース
|00F9H      |[PUTQ](#putq)      |[1492H](#1492h)    |音楽キューにバイトを入れる
|00FCH      |[RIGHTC](#rightc)  |[16C5H](#16c5h)    |現在のピクセルの物理アドレスを右に移動する
|00FFH      |[LEFTC](#leftc)    |[16EEH](#16eeh)    |現在のピクセルの物理アドレスを左に移動する
|0102H      |[UPC](#upc)        |[175DH](#175dh)    |現在のピクセルの物理アドレスを上に移動
|0105H      |[TUPC](#tupc)      |[173CH](#173ch)    |[UPC](#upc)をテストして、合法かどうかを確認します
|0108H      |[DOWNC](#downc)    |[172AH](#172ah)    |現在のピクセルの物理アドレスを下に移動
|010BH      |[TDOWNC](#tdownc)  |[170AH](#170ah)    |合法であれば[DOWNC](#downc)をテストする
|010EH      |[SCALXY](#scalxy)  |[1599H](#1599h)    |グラフィック座標のスケール
|0111H      |[MAPXYC](#mapxyc)  |[15DFH](#15dfh)    |グラフィック座標を物理アドレスにマップする
|0114H      |[FETCHC](#fetchc)  |[1639H](#1639h)    |現在のピクセルの物理アドレスを取得する
|0117H      |[STOREC](#storec)  |[1640H](#1640h)    |現在のピクセルの物理アドレスを格納
|011AH      |[SETATR](#setatr)  |[1676H](#1676h)    |属性バイトの設定
|011DH      |[READC](#readc)    |[1647H](#1647h)    |現在のピクセルの属性を読み取る
|0120H      |[SETC](#setc)      |[167EH](#167eh)    |現在のピクセルの属性を設定する
|0123H      |[NSETCX](#nsetcx)  |[1809H](#1809h)    |ピクセル数の属性を設定する
|0126H      |[GTASPC](#gtaspc)  |[18C7H](#18c7h)    |アスペクト比を取得
|0129H      |[PNTINI](#pntini)  |[18CFH](#18cfh)    |ペイントの初期化
|012CH      |[SCANR](#scanr)    |[18E4H](#18e4h)    |右にピクセルをスキャン
|012FH      |[SCANL](#scanl)    |[197AH](#197ah)    |左にピクセルをスキャン
|0132H      |[CHGCAP](#chgcap)  |[0F3DH](#0f3dh)    |Caps Lock LED の変更
|0135H      |[CHGSND](#chgsnd)  |[0F7AH](#0f7ah)    |キークリック音の出力を変更する
|0138H      |[RSLREG](#rslreg)  |[144CH](#144ch)    |プライマリスロットレジスタの読み取り
|013BH      |[WSLREG](#wslreg)  |[144FH](#144fh)    |プライマリスロットレジスタへの書き込み
|013EH      |[RDVDP](#rdvdp)    |[1449H](#1449h)    |VDPステータスレジスタの読み取り
|0141H      |[SNSMAT](#snsmat)  |[1452H](#1452h)    |キーボードマトリックスの行を読み取る
|0144H      |[PHYDIO](#phydio)  |[148AH](#148ah)    |ディスク、アクションなし
|0147H      |[FORMAT](#format)  |[148EH](#148eh)    |ディスク、アクションなし
|014AH      |[ISFLIO](#isflio)  |[145FH](#145fh)    |ファイルI/Oのチェック
|014DH      |[OUTDLP](#outdlp)  |[1B63H](#1b63h)    |ラインプリンタへのフォーマットされた出力
|0150H      |[GETVCP](#getvcp)  |[1470H](#1470h)    |音楽ボイスポインターを取得
|0153H      |[GETVC2](#getvc2)  |[1474H](#1474h)    |音楽ボイスポインターを取得
|0156H      |[KILBUF](#kilbuf)  |[0468H](#0468h)    |キーボードバッファをクリア
|0159H      |[CALBAS](#calbas)  |[01FFH](#01ffh)    |任意のスロットからBASICを呼び出す
|015CH      |......             |.....              |拡張のために01B5HにNOP

<a name="01b6h"></a><a name="rdslt"></a>

```
Address... 01B6H
Name...... RDSLT
Entry..... A=Slot ID, HL=Address
Exit...... A=Byte read
Modifies.. AF, BC, DE, DI
```

任意のスロットのメモリから1バイトを読み取る標準ルーチン。スロット識別子は、プライマリスロット番号、セカンダリスロット番号、およびフラグで構成されます。

<a name="figure34"></a>![][CH04F34]

**図34:** スロットID

このフラグは通常 0 ですが、スロット ID にセカンダリ スロット番号が含まれている場合は 1 にする必要があります。最初にメモリ アドレスとスロット ID が処理され ([027EH](#027eh))、関連するスロット レジスタに適用するビット マスクのセットが生成されます。セカンダリ スロット番号が指定されている場合は、最初にセカンダリ スロット レジスタが変更され、そのセカンダリ スロットから関連するページが選択されます ([02A3H](#02a3h))。次に、プライマリ スロットが Z80 アドレス空間に切り替えられ、バイトが読み取られ、ワークスペース領域の [RDPRIM](#rdprim) ルーチンによってプライマリ スロットが元の設定に復元されます。最後に、スロット ID にセカンダリ スロット番号が含まれている場合は、元のセカンダリ スロット レジスタの設定が復元されます (01ECH)。

ワークスペース領域を含むスロットでない限り、ページ3（C000H～FFFFH）へのアクセスを試みると、[RDPRIM](#rdprim)が自動的に切り替わるため、システムがクラッシュすることに注意してください。また、すべてのメモリ切り替えルーチンによって割り込みが無効になっていることにも注意してください。

<a name="01d1h"></a><a name="wrslt"></a>

```
Address... 01D1H
Name...... WRSLT
Entry..... A=Slot ID, HL=Address, E=Byte to write
Exit...... なし
Modifies.. AF, BC, D, DI
```

任意のスロットのメモリに1バイトを書き込む標準ルーチン。動作は基本的に[RDSLT](#rdslt)標準ルーチンと同じですが、[RDPRIM](#rdprim)ではなくワークスペースエリアルーチン[WRPRIM](#wrprim)が使用される点が異なります。

<a name="01ffh"></a><a name="calbas"></a>

```
Address... 01FFH
Name...... CALBAS
Entry..... IX=Address
Exit...... なし
Modifies.. AF', BC', DE', HL', IY, DI
```

BASICインタープリタの任意のスロットからアドレスを呼び出す標準ルーチンです。通常、これは拡張ROMのページ1（4000H～7FFFH）で実行されているマシンコードプログラムから呼び出されます。レジスタペアIYの上位バイトにMSX ROMスロットID（00H）がロードされ、制御は[CALSLT](#calslt)標準ルーチンに移ります。

<a name="0205h"></a><a name="callf"></a>

```
Address... 0205H
Name...... CALLF
Entry..... なし
Exit...... なし
Modifies.. AF', BC', DE', HL', IX, IY, DI
```

任意のスロットのアドレスを呼び出す標準ルーチン。スロットIDとアドレスは、フック([第6章](chapter_6))内に収まるように、レジスタではなくインラインパラメータとして渡されます。例:

```
RST 30H
DEFB Slot ID
DEFW Address
RET
```

まずスロットIDが収集され、レジスタペアIYの上位バイトに格納されます。次にアドレスがレジスタペアIXに格納され、制御は[CALSLT](#calslt)標準ルーチンに移ります。

<a name="0217h"></a><a name="calslt"></a>

```
Address... 0217H
Name...... CALSLT
Entry..... IY(High byte)=Slot ID, IX=Address
Exit...... なし
Modifies.. AF', BC', DE', HL', DI
```

任意のスロットのアドレスを呼び出す標準ルーチンです。動作は基本的に[RDSLT](#rdslt)標準ルーチンと同じですが、[RDPRIM](#rdprim)ではなくワークスペースエリアルーチン[CLPRIM](#clprim)が使用される点が異なります。[CALBAS](#calbas)と[CALLF](#callf)は、この標準ルーチンへの特殊なエントリポイントであり、コード量を削減するために使用されます。

<a name="025eh"></a><a name="enaslt"></a>

```
Address... 025EH
Name...... ENASLT
Entry..... A=Slot ID, HL=Address
Exit...... なし
Modifies.. AF, BC, DE, DI
```

任意のスロットからページを永続的に切り替えるための標準ルーチンです。[RDSLT](#rdslt)、[WRSLT](#wrslt)、[CALSLT](#calslt) 標準ルーチンとは異なり、プライマリスロットの切り替えはワークスペース領域ルーチンではなく直接実行されます。そのため、ページ0のアドレス（0000H～3FFFH）は即座にシステムクラッシュを引き起こします。

<a name="027eh"></a>

    Address... 027EH

このルーチンは、メモリスイッチング標準ルーチンによって使用され、レジスタペアHLのアドレスとレジスタAのスロットIDをビットマスクのセットに変換します。例えば、スロットIDがFxxxSSPPでページ1のアドレス（4000H～7FFFH）の場合、以下の結果が返されます。

```
Register B=00 00 PP 00 (OR mask)
Register C=11 11 00 11 (AND mask)
Register D=PP PP PP PP (Replicated)
Register E=00 00 11 00 (Page mask)
```

レジスタBとCは、プライマリスロット番号とページマスクから生成されます。これらは、新しいプライマリスロット番号をプライマリスロットレジスタの既存の内容に合成するために使用されます。レジスタDには、4倍に複製されたプライマリスロット番号が含まれ、レジスタEにはページマスクが含まれます。これは、アドレスの上位2ビットを調べてページ番号を決定し、その後、マスクを適切な位置までシフトすることで生成されます。これらのレジスタは、後にセカンダリスロットの切り替え時に使用されます。

ルーチンが終了すると、スロット ID のビット 7 がテストされ、セカンダリ スロットが指定されているかどうかが判断され、指定されている場合はフラグ M が返されます。

<a name="02a3h"></a>

    Address... 02A3H

このルーチンは、メモリスイッチング標準ルーチンによってセカンダリスロットレジスタを変更するために使用されます。スロットIDはレジスタAに提供され、レジスタDとEには前のルーチンで示したビットマスクが格納されます。

まず、レジスタDのビット6と7がプライマリスロットレジスタにコピーされます。これにより、スロットIDで指定されたプライマリスロットからページ3が切り替わり、必要なセカンダリスロットレジスタが使用可能になります。次に、メモリ位置FFFFHからページマスクが読み出され、反転されたページマスクを使用して必要な2ビットがクリアされます。セカンダリスロット番号は適切な位置にシフトされ、ミックスインされます。最後に、新しい設定がセカンダリスロットレジスタに格納され、プライマリスロットレジスタは元の設定に戻ります。

<a name="02d7h"></a><a name="chkram"></a>

```
Address... 02D7H
Name...... CHKRAM
Entry..... なし
Exit...... なし
Modifies.. AF, BC, DE, HL, SP
```

電源投入時にメモリ初期化を実行する標準ルーチンです。16個のスロットすべてにおいて、ページ2とページ3のRAMを非破壊的にテストし、見つかった最大の領域でプライマリスロットレジスタとセカンダリスロットレジスタを切り替え設定します。ワークスペース領域（F380H～FFC9H）全体がゼロにクリアされ、[EXPTBL](#exptbl)と[SLTTBL](#slttbl)が埋められ、存在する拡張インターフェースがマッピングされます。割り込みモード1が設定され、制御は電源投入初期化ルーチンの残りの部分（[7C76H](#7c76h)）に移ります。

<a name="03fbh"></a><a name="iscntc"></a>

```
Address... 03FBH
Name...... ISCNTC
Entry..... なし
Exit...... なし
Modifies.. AF, EI
```

Ctrl-StopキーまたはStopキーが押されたかどうかを確認する標準ルーチンです。BASICインタープリタは、各ステートメントの末尾でこのルーチンを使用してプログラムの終了を確認します。まず[BASROM](#basrom)に0以外の値が含まれているかどうかを調べ、含まれている場合はルーチンを直ちに終了します。これは、ユーザーがBASICプログラムを含む拡張ROMに侵入するのを防ぐためです。

次に[INTFLG](#intflg)をチェックし、割り込みハンドラがそこにCTRL-STOPまたはSTOPキーコード（03Hまたは04H）を配置したかどうかを判定します。STOPが検出された場合、カーソルがオンになり（[09DAH](#09dah)）、いずれかのキーコードが再び表示されるまで[INTFLG](#intflg)がチェックされます。その後、カーソルがオフになり（[0A27H](#0a27h)）、キーがSTOPであればルーチンは終了します。

CTRL-STOPが検出された場合、まず[KILBUF](#kilbuf)標準ルーチンによってキーボードバッファがクリアされ、[TRPTBL](#trptbl)で「`ON STOP GOSUB`」ステートメントがアクティブかどうかがチェックされます。アクティブであれば、[TRPTBL](#trptbl)の関連エントリが更新され([0EF1H](#0ef1h))、イベントはインタープリタ実行ループによって処理されるため、ルーチンは終了します。そうでない場合は、拡張ROMがルーチンを使用している場合、[ENASLT](#enaslt)標準ルーチンを使用してMSX ROMからページ1に切り替え、制御は「`STOP`」ステートメントハンドラ(63E6H)に移ります。

<a name="0468h"></a><a name="kilbuf"></a>

```
Address... 0468H
Name...... KILBUF
Entry..... なし
Exit...... なし
Modifies.. HL
```

40文字の先行入力キーボードバッファ[KEYBUF](#keybuf)をクリアする標準ルーチンです。このバッファには2つのポインタがあります。[PUTPNT](#putpnt)は割り込みハンドラが文字を配置するポインタ、[GETPNT](#getpnt)はアプリケーションプログラムが文字を取得するポインタです。バッファ内の文字数はこの2つのポインタの差で示されるため、[KEYBUF](#keybuf)は単に両方のポインタを等しくするだけで空になります。

<a name="046fh"></a><a name="breakx"></a>

```
Address... 046FH
Name...... BREAKX
Entry..... なし
Exit...... Flag C if CTRL-STOP key pressed
Modifies.. AF
```

キーボードの6行目と7行目を直接テストし、CtrlキーとStopキーが両方押されているかどうかを判定する標準ルーチンです。両方のキーが押されている場合、[KEYBUF](#keybuf) がクリアされ、[OLDKEY](#oldkey) の7行目が変更され、割り込みハンドラがこれらのキーも取得しないようにします。このルーチンは、カセット入出力時など割り込みが無効になっている場合でも動作し、インタープリタに遷移しないため、[ISCNTC](#iscntc) よりもアプリケーションプログラムでの使用に適している場合が多いです。

<a name="049dh"></a><a name="initio"></a>

```
Address... 049DH
Name...... INITIO
Entry..... なし
Exit...... なし
Modifies.. AF, E, EI
```

PSGとセントロニクスステータスポートを初期化する標準ルーチンです。まず[PSGレジスタ7](#register_7)を80Hに設定し、PSGポートBを出力、PSGポートAを入力に設定します。次に[PSGレジスタ15](#register_15)をCFHに設定し、ジョイスティックコネクタ制御ハードウェアを初期化します。次に[PSGレジスタ14](#register_14)を読み取り、キーボードモードビットを[KANAMD](#kanamd)に設定します。これはUKマシンには関係ありません。

最後に、セントロニクスステータスポート（I/Oポート90H）にFFHの値が出力され、[STROBE](#strobe)信号がハイになります。その後、制御は[GICINI](#gicini)標準ルーチンに移行し、初期化を完了します。

<a name="04bdh"></a><a name="gicini"></a>

```
Address... 04BDH
Name...... GICINI
Entry..... なし
Exit...... なし
Modifies.. EI
```

"`PLAY`" ステートメントに関連付けられた PSG およびワークスペース領域変数を初期化する標準ルーチンです。まず、[QUETAB](#quetab)、[VCBA](#vcba)、[VCBB](#vcbb)、[VCBC](#vcbc) が第 6 章で示した値で初期化されます。次に、PSG レジスタ [8](#register_8)、[9](#register_9)、[10](#register_10) が振幅ゼロに設定され、[PSG レジスタ 7](#register_7) が B8H に設定されます。これにより、各チャンネルのトーンジェネレータが有効になり、ノイズジェネレータが無効になります。

<a name="0508h"></a>

    Address... 0508H

この 6 バイトのテーブルには、[GICINI](#gicini) 標準ルーチンによって [VCBA](#vcba)、[VCBB](#vcbb)、[VCBC](#vcbc) に最初に配置された "`PLAY`" ステートメント パラメータが含まれています: オクターブ = 4、長さ = 4、テンポ = 120、ボリューム = 88H、エンベロープ = 00FFH。

<a name="050eh"></a><a name="initxt"></a>

```
Address... 050EH
Name...... INITXT
Entry..... なし
Exit...... なし
Modifies.. AF, BC, DE, HL, EI
```

VDPを[40x24テキストモード](#40x24_text_mode)に初期化する標準ルーチンです。[DISSCR](#disscr)標準ルーチンによって画面が一時的に無効になり、[SCRMOD](#scrmod)と[OLDSCR](#oldscr)が00Hに設定されます。[CHPUT](#chput)標準ルーチンに必要なパラメータは、[LINL40](#linl40)を[LINLEN](#linlen)に、[TXTNAM](#txtnam)を[NAMBAS](#nambas)に、[TXTCGP](#txtcgp)を[CGPBAS](#cgpbas)にコピーすることで設定されます。その後、[CHGCLR](#chgclr)標準ルーチンによってVDPの色が設定され、画面がクリアされます(077EH)。現在の文字セットがVRAMの文字パターンテーブル([071EH](#071eh))にコピーされます。最後に、[SETTXT](#settxt) 標準ルーチンを介して VDP モードとベース アドレスが設定され、画面が有効になります。

<a name="0538h"></a><a name="init32"></a>

```
Address... 0538H
Name...... INIT32
Entry..... なし
Exit...... なし
Modifies.. AF, BC, DE, HL, EI
```

VDPを[32x24テキストモード](#32x24_text_mode)に初期化する標準ルーチンです。[DISSCR](#disscr)標準ルーチンによって画面が一時的に無効になり、[SCRMOD](#scrmod)と[OLDSCR](#oldscr)が01Hに設定されます。[CHPUT](#chput)標準ルーチンに必要なパラメータは、[LINL32](#linl32)を[LINLEN](#linlen)に、[T32NAM](#t32nam)を[NAMBAS](#nambas)に、[T32CGP](#t32cgp)を[CGPBAS](#cgpbas)に、[T32PAT](#t32pat)を[PATBAS](#patbas)に、[T32ATR](#t32atr)を[ATRBAS](#atrbas)にコピーすることで設定されます。次に、[CHGCLR](#chgclr) 標準ルーチンを介してVDPカラーが設定され、画面がクリアされます(077EH)。現在の文字セットがVRAMの文字パターンテーブル([071EH](#071eh))にコピーされ、すべてのスプライトがクリアされます(06BBH)。最後に、[SETT32](#sett32) 標準ルーチンを介してVDPモードとベースア​​ドレスが設定され、画面が有効化されます。

<a name="0570h"></a><a name="enascr"></a>

```
Address... 0570H
Name...... ENASCR
Entry..... なし
Exit...... なし
Modifies.. AF, BC, EI
```

画面を有効にするための標準ルーチン。VDP [モードレジスタ1](#mode_register_1) のビット6を設定するだけです。

<a name="0577h"></a><a name="disscr"></a>

```
Address... 0577H
Name...... DISSCR
Entry..... なし
Exit...... なし
Modifies.. AF, BC, EI
```

画面を無効にする標準ルーチン。VDP [モードレジスタ1](#mode_register_1)のビット6をリセットするだけです。

<a name="057fh"></a><a name="wrtvdp"></a>

```
Address... 057FH
Name...... WRTVDP
Entry..... B=Data byte, C=VDP Mode Register number
Exit...... なし
Modifies.. AF, B, EI
```

任意のVDP [モードレジスタ](#vdp_mode_registers)にデータバイトを書き込む標準ルーチンです。まずレジスタ選択バイトがVDP [コマンドポート](#commandpport)に書き込まれ、続いてデータバイトが書き込まれます。その後、ワークスペースエリア内の対応するレジスタイメージ[RG0SAV](#rg0sav)～[RG7SAV](#rg7sav)にコピーされます。

<a name="0594h"></a><a name="settxt"></a>

```
Address... 0594H
Name...... SETTXT
Entry..... なし
Exit...... なし
Modifies.. AF, BC, DE, HL, EI
```

VDPを部分的に[40x24テキストモード](#40x24_text_mode)に設定する標準ルーチンです。まず、VDPモードレジスタ[0](#mode_register_0)と[1](#mode_register_1)のモードビットM1、M2、M3を設定します。次に、[TXTNAM](#txtnam)で始まる5つのVRAMテーブルベースアドレスが、ワークスペース領域からVDPモードレジスタ[2](#mode_register_2)、[3](#mode_register_3)、[4](#mode_register_4)、[5](#mode_register_5)、[6](#mode_register_6)([0677H](#0677h))にコピーされます。

<a name="05b4h"></a><a name="sett32"></a>

```
Address... 05B4H
Name...... SETT32
Entry..... なし
Exit...... なし
Modifies.. AF, BC, DE, HL, EI
```

VDPを部分的に[32x24テキストモード](#32x24_text_mode)に設定する標準ルーチンです。まず、VDPモードレジスタ[0](#mode_register_0)と[1](#mode_register_1)のモードビットM1、M2、M3を設定します。次に、[T32NAM](#t32nam)で始まる5つのVRAMテーブルベースアドレスが、ワークスペース領域からVDPモードレジスタ[2](#mode_register_2)、[3](#mode_register_3)、[4](#mode_register_4)、[5](#mode_register_5)、[6](#mode_register_6)([0677H](#0677h))にコピーされます。

<a name="05d2h"></a><a name="inigrp"></a>

```
Address... 05D2H
Name...... INIGRP
Entry..... なし
Exit...... なし
Modifies.. AF, BC, DE, HL, EI
```

VDPを[グラフィックモード](#graphics_mode)に初期化する標準ルーチンです。[DISSCR](#disscr)標準ルーチンによって画面が一時的に無効になり、[SCRMOD](#scrmod)が02Hに設定されます。[GRPPRT](#grpprt)標準ルーチンに必要なパラメータは、[GRPPAT](#grppat)を[PATBAS](#patbas)に、[GRPATR](#grpatr)を[ATRBAS](#atrbas)にコピーすることで設定されます。その後、文字コードドライバパターンがVDPネームテーブルにコピーされ、画面がクリア(07A1H)され、すべてのスプライトがクリア(06BBH)されます。最後に、[SETGRP](#setgrp)標準ルーチンによってVDPモードとベースア​​ドレスが設定され、画面が有効になります。

<a name="0602h"></a><a name="setgrp"></a>

```
Address... 0602H
Name...... SETGRP
Entry..... なし
Exit...... なし
Modifies.. AF, BC, DE, HL, EI
```

VDPを部分的に[グラフィックスモード](#graphics_mode)に設定する標準ルーチンです。まず、VDPモードレジスタ[0](#mode_register_0)と[1](#mode_register_1)のモードビットM1、M2、M3を設定します。次に、[GRPNAM](#grpnam)で始まる5つのVRAMテーブルベースアドレスが、ワークスペース領域からVDPモードレジスタ[2](#mode_register_2)、[3](#mode_register_3)、[4](#mode_register_4)、[5](#mode_register_5)、[6](#mode_register_6)([0677H](#0677h))にコピーされます。

<a name="061fh"></a><a name="inimlt"></a>

```
Address... 061FH
Name...... INIMLT
Entry..... なし
Exit...... なし
Modifies.. AF, BC, DE, HL, EI
```

VDPを[マルチカラーモード](#multicolour_mode)に初期化する標準ルーチンです。[DISSCR](#disscr)標準ルーチンによって画面が一時的に無効になり、[SCRMOD](#scrmod)が03Hに設定されます。[GRPPRT](#grpprt)標準ルーチンに必要なパラメータは、[MLTPAT](#mltpat)を[PATBAS](#patbas)に、[MLTATR](#mltatr)を[ATRBAS](#atrbas)にコピーすることで設定されます。その後、文字コードドライバパターンがVDPネームテーブルにコピーされ、画面がクリア(07B9H)され、すべてのスプライトがクリア(06BBH)されます。最後に、[SETMLT](#setmlt)標準ルーチンによってVDPモードとベースア​​ドレスが設定され、画面が有効になります。

<a name="0659h"></a><a name="setmlt"></a>

```
Address... 0659H
Name...... SETMLT
Entry..... なし
Exit...... なし
Modifies.. AF, BC, DE, HL, EI
```

VDPを部分的に[マルチカラーモード](#multicolour_mode)に設定する標準ルーチンです。まず、VDPモードレジスタ[0](#mode_register_0)と[1](#mode_register_1)のモードビットM1、M2、M3を設定します。次に、[MLTNAM](#mltnam)で始まる5つのVRAMテーブルベースアドレスが、ワークスペース領域からVDPモードレジスタ[2](#mode_register_2)、[3](#mode_register_3)、[4](#mode_register_4)、[5](#mode_register_5)、[6](#mode_register_6)にコピーされます。

<a name="0677h"></a>

    Address... 0677H

このルーチンは、[SETTXT](#settxt)、[SETT32](#sett32)、[SETGRP](#setgrp)、[SETMLT](#setmlt)標準ルーチンによって使用され、ワー​​クスペース領域から5つのテーブルベースアドレスのブロックをVDPモードレジスタ[2](#mode_register_2)、[3](#mode_register_3)、[4](#mode_register_4)、[5](#mode_register_5)、[6](#mode_register_6)にコピーします。エントリ時にレジスタペアHLは関連するアドレスグループを指します。各ベースアドレスは収集され、必要な桁数だけシフトされた後、[WRTVDP](#wrtvdp)標準ルーチンを介して関連するモードレジスタに書き込まれます。

<a name="06a8h"></a><a name="clrspr"></a>

```
Address... 06A8H
Name...... CLRSPR
Entry..... なし
Exit...... なし
Modifies.. AF, BC, DE, HL, EI
```

すべてのスプライトをクリアする標準ルーチン。まず、[FILVRM](#filvrm)標準ルーチンによって、2KBのスプライトパターンテーブル全体がゼロで埋められます。次に、32個のスプライト属性ブロックそれぞれの垂直座標を-47 (D1H)に設定し、スプライトを画面の上端に配置します。水平座標は変更されません。

スプライト属性テーブル内のパターン番号は、8x8スプライトの場合は0、1、2、3、4、…31、16x16スプライトの場合は0、4、8、12、16、…124の連続番号で初期化されます。生成される連続番号は、VDP [モードレジスタ1](#mode_register_1)のサイズビットによって決定されます。最後に、各スプライト属性ブロックのカラーバイトに[FORCLR](#forclr)に格納されているカラーコードが設定されます。初期値は白です。

VDP [モードレジスタ1](#mode_register_1) のサイズビットとマグニチュードビットは、このルーチンの影響を受けないことに注意してください。また、[INIT32](#init32)、[INIGRP](#inigrp)、[INIMLT](#inimlt) 標準ルーチンは、このルーチンをエントリポイント06BBHで使用し、スプライトパターンテーブルには影響を与えないことにも注意してください。

<a name="06e4h"></a><a name="calpat"></a>

```
Address... 06E4H
Name...... CALPAT
Entry..... A=Sprite pattern number
Exit...... HL=Sprite pattern address
Modifies.. AF, DE, HL
```

スプライトパターンのアドレスを計算する標準ルーチンです。パターン番号はまず8倍され、16x16スプライトが選択されている場合はさらに4倍されます。そして、この値を[PATBAS](#patbas)から取得したスプライトパターンテーブルのベースアドレスに加算することで、最終的なアドレスが生成されます。

この番号体系は、16x16スプライトが選択されている場合、VDPではなくBASICインタープリタのパターン番号の使用法と一致しています。例えば、インタープリタは2番目のパターン番号を1と呼んでいますが、実際にはVDPのパターン番号は4です。この使用法は、16x16スプライトが選択されている場合、このルーチンが許容する最大パターン番号が63であることを意味します。この制限は実際にはチェックされないため、大きなパターン番号は3FFFHを超えるアドレスを生成します。このようなアドレスを他のVDPルーチンに渡すと、0を超えてラップアラウンドし、VRAM内の文字パターンテーブルが破損します。

<a name="06f9h"></a><a name="calatr"></a>

```
Address... 06F9H
Name...... CALATR
Entry..... A=Sprite number
Exit...... HL=Sprite attribute address
Modifies.. AF, DE, HL
```

スプライト属性ブロックのアドレスを計算する標準ルーチンです。スプライト番号（0から31まで）を4倍し、[ATRBAS](#atrbas)から取得したスプライト属性テーブルのベースアドレスに加算します。

<a name="0704h"></a><a name="gspsiz"></a>

```
Address... 0704H
Name...... GSPSIZ
Entry..... なし
Exit...... A=Bytes in sprite pattern (8 or 32)
Modifies.. AF
```

スプライトパターンテーブル内の各スプライトパターンが占有するバイト数を返す標準ルーチン。結果は、VDP [モードレジスタ1](#mode_register_1)のサイズビットを調べるだけで得られます。

<a name="070fh"></a><a name="ldirmv"></a>

```
Address... 070FH
Name...... LDIRMV
Entry..... BC=Length, DE=RAM address, HL=VRAM address
Exit...... なし
Modifies.. AF, BC, DE, EI
```

VDP VRAMからメインメモリにブロックをコピーする標準ルーチンです。VRAMの開始アドレスは[SETRD](#setrd)標準ルーチンによって設定され、その後、VDP [データポート](#data_port)から連続したバイトが読み取られ、メインメモリに配置されます。

<a name="071eh"></a>

    Address... 071EH

このルーチンは、2KBの文字セットをVDP文字パターンテーブルにコピーするために使用されます。VRAM上の文字パターンテーブルのベースアドレスは[CGPBAS](#cgpbas)から取得されます。文字セットの開始アドレスは[CGPNT](#cgpnt)から取得されます。文字データの読み取りには[RDSLT](#rdslt)標準ルーチンが使用されるため、拡張ROMに配置される場合があります。

電源投入時に、[CGPNT](#cgpnt) はROMアドレス0004Hに格納されているアドレス [1BBFH](#1bbfh) で初期化されます。[CGPNT](#cgpnt) は簡単に変更でき、興味深い結果を得ることができます。`POKE &HF920,&HC7:SCREEN 0` は非常に分かりにくい例です。

<a name="0744h"></a><a name="ldirvm"></a>

```
Address... 0744H
Name...... LDIRVM
Entry..... BC=Length, DE=VRAM address, HL=RAM address
Exit...... なし
Modifies.. AF, BC, DE, HL, EI
```

メインメモリからVRAMへブロックをコピーする標準ルーチンです。VRAMの開始アドレスは[SETWRT](#setwrt)標準ルーチンによって設定され、その後、メインメモリから連続したバイトが取得され、VDP [データポート](#data_port)に書き込まれます。

<a name="0777h"></a>

    Address... 0777H

このルーチンは、どのVDPモードでも画面をクリアします。[40x24テキストモード](#40x24_text_mode)および[32x24テキストモード](#32x24_text_mode)では、まずベースアドレスが[NAMBAS](#nambas)から取得される名前テーブルにASCIIスペースが埋め込まれます。次に、カーソルをホームポジション([0A7FH](#0a7fh))に設定し、行末テーブル[LINTTB](#linttb)を再初期化します。最後に、ファンクションキーの表示が有効になっている場合は、[FNKSB](#fnksb)標準ルーチンによって復元されます。

[グラフィックスモード](#graphics_mode)では、まずVDP [モードレジスタ7](#mode_register_7) (0832H) を介して境界色が設定されます。次に、カラーテーブルに[BAKCLR](#bakclr)から取得した背景色コードが、0ピクセルと1ピクセルの両方について入力されます。最後に、文字パターンテーブルに0が設定されます。

[マルチカラーモード](#multicolour_mode)では、まずVDP [モードレジスタ7](#mode_register_7) (0832H) を介して境界色が設定されます。次に、文字パターンテーブルは[BAKCLR](#bakclr) から取得した背景色で塗りつぶされます。

<a name="07cdh"></a><a name="wrtvrm"></a>

```
Address... 07CDH
Name...... WRTVRM
Entry..... A=Data byte, HL=VRAM address
Exit...... なし
Modifies.. EI
```

VDP VRAMに1バイトを書き込む標準ルーチンです。まず[SETWRT](#setwrt)標準ルーチンでVRAMアドレスを設定し、次にデータバイトをVDP [データポート](#data_port)に書き込みます。このルーチンに含まれる一見不要な2つの`EX(SP),HL`命令、および他のいくつかの命令は、VDPのタイミング制約を満たすために必要です。

<a name="07d7h"></a><a name="rdvrm"></a>

```
Address... 07D7H
Name...... RDVRM
Entry..... HL=VRAM address
Exit...... A=Byte read
Modifies.. AF, EI
```

VDP VRAMから1バイトを読み取る標準ルーチンです。まず[SETRD](#setrd)標準ルーチンによってVRAMアドレスが設定され、次にVDP [データポート](#data_port)からバイトが読み取られます。

<a name="07dfh"></a><a name="setwrt"></a>

```
Address... 07DFH
Name...... SETWRT
Entry..... HL=VRAM address
Exit...... なし
Modifies.. AF, EI
```

[データポート](#data_port) を介してVRAMへの後続の書き込みを行うためのVDPを設定するための標準ルーチンです。レジスタペアHLに含まれるアドレスは、[図7](#figure7) に示すように、LSBを先頭にMSBを2番目にVDP [コマンドポート](#command_port) に書き込まれます。3FFFHを超えるアドレスは、アドレスの最上位2ビットが無視されるため、0を超えてラップアラウンドします。

<a name="07ech"></a><a name="setrd"></a>

```
Address... 07ECH
Name...... SETRD
Entry..... HL=VRAM address
Exit...... なし
Modifies.. AF, EI
```

[データポート](#data_port)を介してVRAMから後続の読み取りを実行するためのVDPを設定するための標準ルーチンです。レジスタペアHLに含まれるアドレスは、[図7](#figure7)に示すように、LSBを先頭にMSBを2番目にVDP [コマンドポート](#command_port)に書き込まれます。3FFFHを超えるアドレスは、アドレスの最上位2ビットが無視されるため、0を超えてラップアラウンドします。

<a name="07f7h"></a><a name="chgclr"></a>

```
Address... 07F7H
Name...... CHGCLR
Entry..... なし
Exit...... なし
Modifies.. AF, BC, HL, EI
```

VDPの色を設定するための標準ルーチンです。まず[SCRMOD](#scrmod)を調べて適切な処理を決定します。[40x24テキストモード](#40x24_text_mode)では、[BAKCLR](#bakclr)と[FORCLR](#forclr)の内容をVDPの[モードレジスタ7](#mode_register_7)に書き込み、0と1のピクセルの色を設定します。これらのピクセルの初期色は青と白です。このモードでは境界色を指定できないことに注意してください。境界色は0のピクセルの色と同じになります。 [32x24 テキストモード](#32x24_text_mode)、[グラフィックスモード](#graphics_mode)、[マルチカラーモード](#multicolour_mode)では、[BDRCLR](#bdrclr) の内容がVDP [モードレジスタ 7](#mode_register_7) に書き込まれ、境界の色（初期値は青）が設定されます。また、[32x24 テキストモード](#32x24_text_mode)では、[BAKCLR](#bakclr) と [FORCLR](#forclr) の内容がカラーテーブル全体にコピーされ、0 ピクセルと 1 ピクセルの色が決まります。

<a name="0815h"></a><a name="filvrm"></a>

```
Address... 0815H
Name...... FILVRM
Entry..... A=Data byte, BC=Length, HL=VRAM address
Exit...... なし
Modifies.. AF, BC, EI
```

VDP VRAMのブロックを1バイトのデータで埋める標準ルーチンです。レジスタペアHLに含まれるVRAMの開始アドレスは、まず[SETWRT](#setwrt)標準ルーチンによって設定されます。その後、データバイトはVDP [データポート](#data_port)に繰り返し書き込まれ、VRAMの連続する位置を埋めていきます。

<a name="083bh"></a><a name="totext"></a>

```
Address... 083BH
Name...... TOTEXT
Entry..... なし
Exit...... なし
Modifies.. AF, BC, DE, HL, EI
```

VDPが現在[グラフィックスモード](#graphics_mode)または[マルチカラーモード](#multicolour_mode)の場合、VDPを[40x24テキストモード](#40x24_text_mode)または[32x24テキストモード](#32x24_text_mode)に戻す標準ルーチンです。このルーチンは、BASICインタープリタのメインループと"[INPUT](#input)"ステートメントハンドラによって使用されます。[INITXT](#initxt)または[INIT32](#init32)標準ルーチンが使用されるたびに、モードバイト（00Hまたは01H）が[OLDSCR](#oldscr)にコピーされます。その後、モードが[グラフィックスモード](#graphics_mode)または[マルチカラーモード](#multicolour_mode)に変更され、その後キーボード入力のために2つのテキストモードのいずれかに戻らなければならない場合、このルーチンによって同じモードに戻ることが保証されます。

まず[SCRMOD](#scrmod)が調べられ、画面が既にいずれかのテキストモードになっている場合は、ルーチンは何もせずに終了します。そうでない場合は、[OLDSCR](#oldscr)から以前のテキストモードが取得され、[CHGMOD](#chgmod)標準ルーチンに渡されます。

<a name="0848h"></a><a name="cls"></a>

```
Address... 0848H
Name...... CLS
Entry..... Flag Z
Exit...... なし
Modifies.. AF, BC, DE, EI
```

どのモードでも画面をクリアする標準ルーチンです。0777Hのルーチンを呼び出す以外は何もしません。これは実際には「`CLS`」ステートメントハンドラであり、この文の後に不正なテキストがあることを示すため、フラグNZが設定されている場合には単に戻ります。

<a name="084fh"></a><a name="chgmod"></a>

```
Address... 084FH
Name...... CHGMOD
Entry..... A=Screen mode required (0, 1, 2, 3)
Exit...... なし
Modifies.. AF, BC, DE, HL, EI
```

新しい画面モードを設定するための標準ルーチンです。必要な画面モードが格納されているレジスタAがテストされ、制御は[INITXT](#initxt)、[INIT32](#init32)、[INIGRP](#inigrp)、または[INIMLT](#inimlt)に渡されます。

<a name="085dh"></a><a name="lptout"></a>

```
Address... 085DH
Name...... LPTOUT
Entry..... A=Character to print
Exit...... Flag C if CTRL-STOP termination
Modifies.. AF
```

セントロニクスポートを介してラインプリンタに文字を出力する標準ルーチンです。プリンタの状態は、[LPTSTT](#lptstt) 標準ルーチンによって継続的にテストされ、プリンタがフリーになるまで続きます。その後、文字はセントロニクスデータポート (I/O ポート 91H) に書き込まれ、セントロニクスステータスポート (I/O ポート 90H) の [STROBE](#strobe) 信号が短時間ローレベルになります。プリンタがビジー状態の場合、[BREAKX](#breakx) 標準ルーチンは CTRL-STOP キーの検出に使用されます。CTRL-STOP キーが検出されると、CR コードがセントロニクスデータポートに書き込まれ、プリ​​ンタのラインバッファがフラッシュされます。ルーチンはフラグ C で終了します。

<a name="0884h"></a><a name="lptstt"></a>

```
Address... 0884H
Name...... LPTSTT
Entry..... なし
Exit...... A=0 and Flag Z if printer busy
Modifies.. AF
```

CentronicsステータスポートのBUSY信号をテストするための標準ルーチン。I/Oポート90Hを読み取り、ビット1の状態（0=Ready、1=Busy）を調べるだけです。

<a name="088eh"></a><a name="posit"></a>

```
Address... 088EH
Name...... POSIT
Entry..... H=Column, L=Row
Exit...... なし
Modifies.. AF, EI
```

カーソル座標を設定する標準ルーチンです。行と列の座標は、ESC,"Y",Row+1FH, Column+1FH シーケンスのパラメータとして [OUTDO](#outdo) 標準ルーチンに渡されます。BIOSのホームポジションは、BASICインタープリタで使用される 0,0 ではなく、1,1 であることに注意してください。

<a name="089dh"></a><a name="cnvchr"></a>

```
Address... 089DH
Name...... CNVCHR
Entry..... A=Character
Exit...... Flag Z,NC=Header; Flag NZ,C=Graphic; Flag Z,C=Normal
Modifies.. AF
```

グラフィックヘッダーを持つ文字を検査し、必要に応じて変換する標準ルーチンです。20H未満の文字は通常、出力デバイスドライバによって制御文字として解釈されます。この範囲の文字コードは、先頭にグラフィックヘッダー制御コード（01H）を付加し、その値に40Hを加算することで、表示可能な文字として扱うことができます。例えば、文字コード0DHをキャリッジリターンとして解釈させるのではなく、直接表示するには、01Hと4DHの2バイトを出力する必要があります。このルーチンは、[CHPUT](#chput)標準ルーチンなどの出力デバイスドライバによって、このようなシーケンスの有無を確認するために使用されます。

文字がグラフィックヘッダーの場合、[GRPHED](#grphed) は01Hに設定され、ルーチンは終了します。それ以外の場合は、[GRPHED](#grphed) は0になります。文字が40Hから5FHの範囲外にある場合は、変更されません。文字がこの範囲内にあり、[GRPHED](#grphed) に前のグラフィックヘッダーを示す01Hが含まれている場合は、40Hを減算して変換されます。

<a name="08bch"></a><a name="chput"></a>

```
Address... 08BCH
Name...... CHPUT
Entry..... A=Character
Exit...... なし
Modifies.. EI
```

[40x24 テキストモード](#40x24_text_mode) または [32x24 テキストモード](#32x24_text_mode) で画面に文字を出力する標準ルーチンです。まず [SCRMOD](#scrmod) をチェックし、VDP が [グラフィックモード](#graphics_mode) または [マルチカラーモード](#multicolour_mode) のいずれかである場合、ルーチンは何もせずに終了します。それ以外の場合、カーソルが削除され ([0A2EH](#0a2eh))、文字がデコードされ ([08DFH](#08dfh))、カーソルが置き換えられます ([09E1H](#09e1h))。最後に、カーソルの列位置が [TTYPOS](#ttypos) に格納され、"`PRINT`" 文で使用されます。そしてルーチンは終了します。

<a name="08dfh"></a>

    Address... 08DFH

このルーチンは、[CHPUT](#chput) 標準ルーチンによって使用され、文字をデコードして適切なアクションを実行します。[CNVCHR](#cnvchr) 標準ルーチンは最初にグラフィック文字をチェックするために使用されます。文字がヘッダー コード (01H) の場合、ルーチンはアクションを実行せずに終了します。文字が変換されたグラフィック文字の場合、制御コードのデコード セクションはスキップされます。それ以外の場合は、[ESCCNT](#esccnt) で以前の ESC 文字 (1BH) を受信したかどうかがチェックされ、受信されている場合は ESC シーケンス プロセッサ ([098FH](#098fh)) に制御が移ります。そうでない場合は、文字が 20H より小さいかどうかがチェックされ、20H より小さい場合は制御コード プロセッサ ([0914H](#0914h)) に制御が移ります。次に、文字が DEL (7FH) かどうかがチェックされ、DEL の場合は削除ルーチン (0AE3H) に制御が移ります。

文字が表示可能であると仮定すると、カーソル座標は[CSRY](#csry)と[CSRX](#csrx)から取得され、レジスタペアHL（H=列、L=行）に格納されます。次に、これらの座標はVDPネームテーブルの物理アドレスに変換され、文字がそこに格納されます（[0BE6H](#0be6h)）。次に、カーソルの列位置がインクリメントされ（[0A44H](#0a44h)）、右端の列を超えていないと仮定してルーチンは終了します。右端の列を超えている場合は、行終端テーブル[LINTTB](#linttb)の行エントリが拡張論理行を示すためにゼロに設定され、列番号が01Hに設定され、LFが実行されます。

<a name="0908h"></a>

    Address... 0908H

このルーチンは、[CHPUT](#chput)標準ルーチン制御コードプロセッサのLF操作を実行します。カーソル行がインクリメントされ([0A61H](#0a61h))、最下行を超えていないと仮定すると、ルーチンは終了します。最下行を超えている場合は、画面を上方向にスクロールし、最下行を消去します(0A88H)。

<a name="0914h"></a>

    Address... 0914H

これは[CHPUT](#chput)標準ルーチンの制御コードプロセッサです。[092FH](#092fh)のテーブルで一致するコードが検索され、対応するアドレスに制御が渡されます。

<a name="092fh"></a>

    Address... 092FH

この表には、[CHPUT](#chput) 標準ルーチンによって認識される、それぞれに関連付けられたアドレスを持つ制御コードが含まれています。

|CODE |TO     |FUNCTION
|:---:|:-----:|--------------------------------
|07H  |1113H  |BELL, go beep
|08H  |0A4CH  |BS, cursor left
|09H  |0A71H  |TAB, cursor to next tab position
|0AH  |0908H  |LF, cursor down a row
|0BH  |0A7FH  |HOME, cursor to home
|0CH  |077EH  |FORMFEED, clear screen and home
|0DH  |0A81H  |CR, cursor to leftmost column
|1BH  |0989H  |ESC, enter escape sequence
|1CH  |0A5BH  |RIGHT, cursor right
|1DH  |0A4CH  |LEFT, cursor left
|1EH  |0A57H  |UP, cursor up
|1FH  |0A61H  |DOWN, cursor down.

</a>

<a name="0953h"></a>

    Address... 0953H

この表には、[CHPUT](#chput) 標準ルーチンによって認識される、それぞれに関連付けられたアドレスを持つ ESC 制御コードが含まれています。

|CODE |TO     |FUNCTION
|:---:|:-----:|-------------------------------
|6AH  |077EH  |ESC,"j", clear screen and home
|45H  |077EH  |ESC,"E", clear screen and home
|4BH  |0AEEH  |ESC,"K", clear to end of line
|4AH  |0B05H  |ESC,"J", clear to end of screen
|6CH  |0AECH  |ESC,"l", clear line
|4CH  |0AB4H  |ESC,"L", insert line
|4DH  |0A85H  |ESC,"M", delete line
|59H  |0986H  |ESC,"Y", set cursor coordinates
|41H  |0A57H  |ESC,"A", cursor up
|42H  |0A61H  |ESC,"B", cursor down
|43H  |0A44H  |ESC,"C", cursor right
|44H  |0A55H  |ESC,"D", cursor left
|48H  |0A7FH  |ESC,"H", cursor home
|78H  |0980H  |ESC,"x", change cursor
|79H  |0983H  |ESC,"y", change cursor

</a>

<a name="0980h"></a>

    Address... 0980H

このルーチンは、[CHPUT](#chput)標準ルーチン制御コードプロセッサに対してESC,"x"操作を実行します。[ESCCNT](#esccnt)は、次に受信した文字がパラメータであることを示すために01Hに設定されます。

<a name="0983h"></a>

    Address... 0983H

このルーチンは、[CHPUT](#chput)標準ルーチン制御コードデコーダーのESC,"y"操作を実行します。[ESCCNT](#esccnt)は、次に受信した文字がパラメーターであることを示すために02Hに設定されます。

<a name="0986h"></a>

    Address... 0986H

このルーチンは、[CHPUT](#chput)標準ルーチン制御コードプロセッサに対してESC",Y"操作を実行します。[ESCCNT](#esccnt)は、次に受信した文字がパラメータであることを示すために04Hに設定されます。

<a name="0989h"></a>

    Address... 0989H

このルーチンは、[CHPUT](#chput)標準ルーチン制御コードプロセッサのESC操作を実行します。[ESCCNT](#esccnt)は、次に受信した文字が2番目の制御文字であることを示すためにFFHに設定されます。

<a name="098fh"></a>

    Address... 098FH

これは[CHPUT](#chput)標準ルーチンESCシーケンスプロセッサです。[ESCCNT](#esccnt)にFFHが含まれている場合、その文字は2番目の制御文字であり、制御は制御コードプロセッサ(0919H)に移り、[0953H](#0953h)のESCコードテーブルを検索します。

[ESCCNT](#esccnt) に 01H が含まれている場合、その文字は ESC,"x" シーケンスの唯一のパラメータです。パラメータが "4" (34H) の場合、[CSTYLE](#cstyle) に 00H が設定され、ブロックカーソルになります。パラメータが "5" (35H) の場合、[CSRSW](#csrsw) に 00H が設定され、カーソルは通常無効になります。

[ESCCNT](#esccnt) に 02H が含まれている場合、その文字は ESC,"y" シーケンスの唯一のパラメータです。パラメータが "4" (34H) の場合、[CSTYLE](#cstyle) に 01H が設定され、下線付きカーソルが表示されます。パラメータが "5" (35H) の場合、[CSRSW](#csrsw) に 01H が設定され、カーソルが通常通り有効になります。

[ESCCNT](#esccnt) に 04H が含まれている場合、その文字は ESC,"Y" シーケンスの最初のパラメータであり、行座標を表します。このパラメータから 1FH が減算され、[CSRY](#csry) に格納されます。その後、[ESCCNT](#esccnt) は 03H に減算されます。

[ESCCNT](#esccnt) に 03H が含まれている場合、その文字は ESC,"Y" シーケンスの 2 番目のパラメータであり、列座標を表します。このパラメータから 1FH が減算され、[CSRX](#csrx) に格納されます。

<a name="09dah"></a>

    Address... 09DAH

このルーチンは、例えば[CHGET](#chget)標準ルーチンによって、通常は無効になっているカーソル文字を表示するために使用されます。[CSRSW](#csrsw)が0以外の場合、ルーチンは何もせずに終了します。0の場合、カーソルが表示されます(09E6H)。

<a name="09e1h"></a>

    Address... 09E1H

このルーチンは、例えば[CHPUT](#chput)標準ルーチンによって、カーソル文字が通常有効な場合にその文字を表示するために使用されます。[CSRSW](#csrsw)が0の場合、ルーチンは何もせずに終了します。[SCRMOD](#scrmod)がチェックされ、画面が[グラフィックスモード](#graphics_mode)または[マルチカラーモード](#multicolour_mode)の場合、ルーチンは何もせずに終了します。それ以外の場合、カーソル座標はVDPネームテーブルの物理アドレスに変換され、その位置([0BD8H](#0bd8h))から文字が読み取られ、[CURSAV](#cursav)に保存されます。

文字の8バイトのピクセルパターンがVDP文字パターンテーブルから[LINWRK](#linwrk)バッファ([0BA5H](#0ba5h))に読み込まれます。その後、ピクセルパターンは反転されます。[CSTYLE](#cstyle)がブロックカーソルを示している場合は8バイトすべてが反転され、[CSTYLE](#cstyle)が下線カーソルを示している場合は下位3バイトのみが反転されます。ピクセルパターンは、VDP文字パターンテーブル([0BBEH](#0bbeh))の文字コード255の位置にコピーされます。その後、文字コード255がVDP名前テーブル([0BE6H](#0be6h))の現在のカーソル位置に配置され、ルーチンが終了します。

文字コード255を使用してカーソル文字を生成するこの方法は、特定の条件下では奇妙な結果をもたらすことがあります。これは、BASIC文「FOR N=1 TO 100: PRINT CHR$(255);:NEXT」を実行し、その後カーソルアップキーを押すことで確認できます。

<a name="0a27h"></a>

    Address... 0A27H

このルーチンは、例えば[CHGET](#chget)標準ルーチンによって、通常は無効になっているカーソル文字を削除するために使用されます。[CSRSW](#csrsw)が0以外の場合、ルーチンは何もせずに終了します。0の場合、カーソルは削除されます(0A33H)。

<a name="0a2eh"></a>

    Address... 0A2EH

このルーチンは、例えば[CHPUT](#chput)標準ルーチンによって、カーソル文字が通常有効になっている場合にそれを削除するために使用されます。[CSRSW](#csrsw)が0の場合、ルーチンは何もせずに終了します。[SCRMOD](#scrmod)がチェックされ、画面が[グラフィックスモード](#graphics_mode)または[マルチカラーモード](#multicolour_mode)の場合、ルーチンは何もせずに終了します。それ以外の場合、カーソル座標はVDPネームテーブルの物理アドレスに変換され、[CURSAV](#cursav)に保持されている文字がその位置([0BE6H](#0be6h))に書き込まれます。

<a name="0a44h"></a>

    Address... 0A44H

このルーチンは、[CHPUT](#chput)標準ルーチン制御コードプロセッサのESC,"C"操作を実行します。カーソルの列座標が既に[LINLEN](#linlen)で決定される右端の列にある場合、ルーチンは何もせずに終了します。そうでない場合は、列座標がインクリメントされ、[CSRX](#csrx)が更新されます。

<a name="0a4ch"></a>

    Address... 0A4CH

このルーチンは、[CHPUT](#chput)標準ルーチン制御コードプロセッサのBS/LEFT演算を実行します。カーソルの列座標が減算され、[CSRX](#csrx)が更新されます。列座標が左端の位置を超えて移動した場合は、[LINLEN](#linlen)から右端の位置に設定され、UP演算が実行されます。

<a name="0a55h"></a>

    Address... 0A55H

このルーチンは、[CHPUT](#chput)標準ルーチン制御コードプロセッサのESC,"D"操作を実行します。カーソルの列座標が既に左端にある場合、ルーチンは何もせずに終了します。そうでない場合は、列座標がデクリメントされ、[CSRX](#csrx)が更新されます。

<a name="0a57h"></a>

    Address... 0A57H

このルーチンは、[CHPUT](#chput)標準ルーチン制御コードプロセッサのESC,"A" (UP)操作を実行します。カーソル行座標が既に最上位にある場合、ルーチンは何もせずに終了します。そうでない場合は、行座標がデクリメントされ、[CSRY](#csry)が更新されます。

<a name="0a5bh"></a>

    Address... 0A5BH

このルーチンは、[CHPUT](#chput)標準ルーチン制御コードプロセッサのRIGHT演算を実行します。カーソルの列座標がインクリメントされ、[CSRX](#csrx)が更新されます。列座標が[LINLEN](#linlen)で決定される右端の位置を超えて移動した場合、左端の位置（01H）に設定され、DOWN演算が実行されます。

<a name="0a61h"></a>

    Address... 0A61H

このルーチンは、[CHPUT](#chput)標準ルーチン制御コードプロセッサのESC,"B" (DOWN)操作を実行します。カーソル行座標が既に[CRTCNT](#crtcnt)と[CNSDFG](#cnsdfg) ([0C32H](#0c32h))によって決定される最低位置にある場合、ルーチンは何もせずに終了します。そうでない場合は、行座標がインクリメントされ、[CSRY](#csry)が更新されます。

<a name="0a71h"></a>

    Address... 0A71H

このルーチンは、[CHPUT](#chput)標準ルーチン制御コードプロセッサのTAB操作を実行します。[CSRX](#csrx)が8の倍数+1（BIOS列1、9、17、25、33）になるまで、ASCIIスペースが出力されます（[08DFH](#08dfh)）。

<a name="0a7fh"></a>

    Address... 0A7FH

このルーチンは、[CHPUT](#chput) 標準ルーチン制御コードプロセッサの ESC,"H" (HOME) 操作を実行し、[CSRX](#csrx) と [CSRY](#csry) は単に 1,1 に設定されます。ROM BIOS カーソル座標系は、BASIC インタープリタで使用されるものと機能的に同一ですが、画面の行を 1 から 24、列を 1 から 32/40 に番号付けします。

<a name="0a81h"></a>

    Address... 0A81H

このルーチンは、[CHPUT](#chput)標準ルーチン制御コードプロセッサのCR操作を実行し、[CSRX](#csrx)は単に01Hに設定されます。

<a name="0a85h"></a>

    Address... 0A85H

このルーチンは、[CHPUT](#chput)標準ルーチン制御コードプロセッサのESC,"M"機能を実行します。まず、カーソルの列座標を最左端に設定するためにCR操作を実行します。次に、現在行から画面最下部までの行数を求めます。この値が0の場合、現在行は単に消去されます([0AECH](#0aech))。この行数は、まず行終端テーブル[LINTTB](#linttb)の該当セクションを1バイトずつ上にスクロールするために使用されます。次に、この行数を使用して、画面の該当セクションを1行ずつ上にスクロールします。現在行の下の行から開始し、各行はVDPネームテーブルから[LINWRK](#linwrk)バッファ([0BAAH](#0baah))にコピーされ、さらに1行上のネームテーブル([0BC3H](#0bc3h))にコピーされます。最後に、画面最下部の行が消去されます([0AECH](#0aech))。

<a name="0ab4h"></a>

    Address... 0AB4H

このルーチンは、[CHPUT](#chput)標準ルーチン制御コードプロセッサのESC,"L"操作を実行します。まず、カーソルの列座標を最左端に設定するためにCR操作を実行します。次に、現在行から画面最下部までの行数を求めます。この値が0の場合、現在行は単に消去されます([0AECH](#0aech))。この行数は、まず行終端テーブル[LINTTB](#linttb)の該当セクションを1バイトずつスクロールダウンするために使用されます。次に、この行数を使用して、画面の該当セクションを1行ずつスクロールダウンします。画面の最後から2番目の行から開始し、各行がVDPネームテーブルから[LINWRK](#linwrk)バッファ([0BAAH](#0baah))にコピーされ、さらに1行下のネームテーブル([0BC3H](#0bc3h))にコピーされます。最後に、現在行が消去されます([0AECH](#0aech))。

    Address... 0AE3H

このルーチンは、[CHPUT](#chput)標準ルーチン制御コードプロセッサのDEL操作を実行するために使用されます。最初にLEFT操作が実行されます。カーソルが既にホームポジションにあるためこの操作を完了できない場合、ルーチンは何もせずに終了します。それ以外の場合は、VDPネームテーブル内のカーソルの物理位置([0BE6H](#0be6h))にスペースが書き込まれます。

<a name="0aech"></a>

    Address... 0AECH

このルーチンは、[CHPUT](#chput)標準ルーチン制御コードプロセッサのESC,"l"操作を実行します。カーソルの列座標は01Hに設定され、制御はESC,"K"ルーチンに移ります。

<a name="0aeeh"></a>

    Address... 0AEEH

このルーチンは、[CHPUT](#chput)標準ルーチン制御コードプロセッサのESC,"K"操作を実行します。行終端テーブル[LINTTB](#linttb)の行エントリは、論理行が拡張されていないことを示すために、まず非ゼロ値([0C29H](#0c29h))になります。カーソル座標はVDPネームテーブルの物理アドレス(0BF2H)に変換され、[SETWRT](#setwrt)標準ルーチンを介してVDPが書き込み用に設定されます。その後、[LINLEN](#linlen)で決定される右端の列に達するまで、スペースがVDP [データポート](#data_port)に直接書き込まれます。

    Address... 0B05H

このルーチンは、[CHPUT](#chput)標準ルーチン制御コードプロセッサのESC,"J"操作を実行します。ESC,"K"操作は、現在の行から開始し、画面下部に達するまで連続して実行されます。

<a name="0b15h"></a><a name="erafnk"></a>

```
Address... 0B15H
Name...... ERAFNK
Entry..... なし
Exit...... なし
Modifies.. AF, DE, EI
```

ファンクションキーの表示をオフにする標準ルーチンです。まず[CNSDFG](#cnsdfg)がゼロにリセットされ、VDPが[グラフィックモード](#graphics_mode)または[マルチカラーモード](#multicolour_mode)の場合、ルーチンはそれ以上の処理を行わずに終了します。VDPが[40x24テキストモード](#40x24_text_mode)または[32x24テキストモード](#32x24_text_mode)の場合、画面の最終行が消去されます([0AECH](#0aech))。

<a name="0b26h"></a><a name="fnksb"></a>

```
Address... 0B2BH
Name...... DSPFNK
Entry..... なし
Exit...... なし
Modifies.. AF, BC, DE, EI
```

ファンクションキーが有効になっている場合、ファンクションキー表示を行う標準ルーチンです。[CNSDFG](#cnsdfg) がゼロの場合、ルーチンは何もせずに終了します。それ以外の場合、制御は [DSPFNK](#dspfnk) 標準ルーチンに渡されます。

<a name="0b2bh"></a><a name="dspfnk"></a>

```
Address... 0B2BH
Name...... DSPFNK
Entry..... なし
Exit...... なし
Modifies.. AF、BC、DE、EI
```

ファンクションキーの表示をオンにする標準ルーチンです。[CNSDFG](#cnsdfg) は FFH に設定され、VDP が [グラフィックスモード](#graphics_mode) または [マルチカラーモード](#multicolour_mode) の場合、ルーチンはそれ以上の処理を行わずに終了します。それ以外の場合は、カーソルの行座標をチェックし、カーソルが画面の最終行にある場合は、画面を上にスクロールするための LF コード (0AH) を [OUTDO](#outdo) 標準ルーチンに発行します。

レジスタペアHLは、SHIFTキーが押されているかどうかに応じて、ワークスペース領域内のシフトされていない機能文字列またはシフトされた機能文字列のいずれかを指すように設定されます。[LINLEN](#linlen)は、フィールド間に最低1つのスペースを確保するために4を減算し、5で割ることで各文字列のフィールドサイズを決定します。次に、各機能文字列から連続する文字が取得され、[CNVCHR](#cnvchr)標準ルーチンによってグラフィックヘッダーがチェックされ、文字列がなくなるか領域が一杯になるまで[LINWRK](#linwrk)バッファに格納されます。5つの文字列がすべて完了すると、[LINWRK](#linwrk)バッファはVDP名前テーブル([0BC3H](#0bc3h))の最終行に書き込まれます。

<a name="0b9ch"></a>

    Address... 0B9CH

このルーチンは、ファンクションキー表示関連の標準ルーチンによって使用されます。レジスタAの内容は[CNSDFG](#cnsdfg)に格納され、[SCRMOD](#scrmod)がテストされ、画面が[グラフィックスモード](#graphics_mode)または[マルチカラーモード](#multicolour_mode)の場合、フラグNCが返されます。

<a name="0ba5h"></a>

    Address... 0BA5H

このルーチンは、VDP VRAM から 8 バイトを [LINWRK](#linwrk) バッファにコピーします。VRAM の物理アドレスはレジスタ ペア HL に提供されます。

<a name="0baah"></a>

    Address... 0BAAH

このルーチンは、[LINLEN](#linlen)で指定された長さの文字行全体をVDP VRAMから[LINWRK](#linwrk)バッファにコピーします。カーソル行の座標はレジスタLに与えられます。

<a name="0bbeh"></a>

    Address... 0BBEH

このルーチンは、[LINWRK](#linwrk) バッファから 8 バイトを VDP VRAM にコピーします。VRAM の物理アドレスはレジスタ ペア HL に提供されます。

<a name="0bc3h"></a>

    Address... 0BC3H

このルーチンは、[LINLEN](#linlen) で指定された長さの文字行全体を、[LINWRK](#linwrk) バッファから VDP VRAM にコピーします。カーソル行の座標はレジスタ L に渡されます。

<a name="0bd8h"></a>

    Address... 0BD8H

このルーチンは、VDP VRAM から 1 バイトをレジスタ C に読み取ります。列座標はレジスタ H に提供され、行座標はレジスタ L に提供されます。

<a name="0be6h"></a>

    Address... 0BE6H

このルーチンは、画面座標のペア（レジスタHの列とレジスタLの行）をVDPネームテーブル内の物理アドレスに変換します。このアドレスはレジスタペアHLに返されます。

行座標は、画面モードに応じてまず32倍または40倍され、列座標に加算されます。次に、この値が[NAMBAS](#nambas)から取得される名前テーブルベースアドレスに加算され、初期アドレスが生成されます。

[LINLEN](#linlen) で示される画面幅は可変であるため、アクティブ領域を画面のほぼ中央に配置するには、初期アドレスにオフセットを追加する必要があります。行あたりの「実際の」文字数（32文字または40文字）と現在の幅の差を半分にし、切り上げて左側のオフセットを生成します。[40x24 テキストモード](#40x24_text_mode) で37文字幅の英国製マシンの場合、この結果、左側に2文字、右側に1文字の未使用文字が発生します。`PRINT (41-WID)\2` という文（`WID` は任意の画面幅）は、[40x24 テキストモード](#40x24_text_mode) で左側の列オフセットを表示します。

このルーチンをエミュレートする完全な BASIC プログラムを以下に示します。

```
10 CPR=40:NAM=BASE(0):WID=PEEK(&HF3AE)
20 SCRMD=PEEK(&HFCAF):IF SCRMD=0 THEN 40
30 CPR=32:NAM=BASE(5):WID=PEEK(&HF3AF)
40 LH=(CPR+1-WID)\2
50 ADDR=NAM+(ROW-1)*CPR+(COL-1)+LH
```

このプログラムは、ROM BIOSで使用される「ROW」および「COL」座標系（ホーム座標は1,1）用に設計されています。BASICインタープリタの座標系を使用する場合は、50行目の「-1」係数を削除することで簡略化できます。

<a name="0c1dh"></a>

    Address... 0C1DH

このルーチンは、行終端テーブル[LINTTB](#linttb)内の行エントリのアドレスを計算します。行座標はレジスタLに与えられ、アドレスはレジスタペアDEに返されます。

<a name="0c29h"></a>

    Address... 0C29H

このルーチンは、[LINTTB](#linttb) の行エントリを、[0C29H](#0c29h) に入った場合は非ゼロに、0C2AH に入った場合はゼロにします。行座標はレジスタ L に与えられます。

<a name="0c32h"></a>

    Address... 0C32H

このルーチンは、画面上の行数をレジスタAに返します。ファンクションキーの表示が無効の場合は通常24、有効の場合は23を返します。画面サイズは[CRTCNT](#crtcnt)によって決定され、BASIC文（例えば`POKE &HF3B1H,14:SCREEN 0`）で変更できることに注意してください。

<a name="0c3ch"></a><a name="keyint"></a>

```
Address... 0C3CH
Name...... KEYINT
Entry..... なし
Exit...... なし
Modifies.. いいえ
```

Z80割り込みを処理するための標準ルーチンです。UKマシンでは、VDPによって20msごとに割り込みが生成されます。まず[VDPステータスレジスタ](#vdp_status_register)が読み込まれ、ビット7がフレームレート割り込みであるかどうかがチェックされます。そうでない場合、ルーチンは何もせずに終了します。[ステータスレジスタ](#vdp_status_register)の内容は[STATFL](#statfl)に保存され、ビット5がスプライトの一致かどうかがチェックされます。一致フラグがアクティブの場合、[TRPTBL](#trptbl)の関連エントリが更新されます([0EF1H](#0ef1h))。

次に、「`INTERVAL`」カウンタ[INTCNT](#intcnt)が減算されます。このカウンタがゼロに達した場合、[TRPTBL](#trptbl)の対応するエントリが更新され([0EF1H](#0ef1h))、カウンタは[INTVAL](#intval)の内容でリセットされます。

次に、[JIFFY](#jiffy) と呼ばれる「`TIME`」カウンタがインクリメントされます。このカウンタはオーバーフローするとゼロに戻ります。

[MUSICF](#musicf) は、"`PLAY`" 文によって生成された3つの音楽キューのいずれかがアクティブかどうかを判定するために検査されます。アクティブなキューごとに、デキュールーチン ([113BH](#113bh)) が呼び出され、次の音楽パケットが取得されてPSGに書き込まれます。

次に、[SCNCNT](#scncnt) をデクリメントして、ジョイスティックとキーボードのスキャンが必要かどうかを判断します。必要でない場合、割り込みハンドラはそれ以上の処理を行わずに終了します。このカウンタは、スキャンが3回の割り込みごとに実行されるようにすることで、スループットを向上させ、キーバウンスの問題を最小限に抑えるために使用されます。スキャンが必要な場合、ジョイスティックコネクタ1が選択され、2つのトリガービット([120CH](#120ch))が読み込まれます。続いて、ジョイスティックコネクタ2の2つのトリガービット([120CH](#120ch))と、キーボードの8列目のスペースキー([1226H](#1226h))が読み込まれます。これら5つの入力はすべて「`STRIG`」ステートメントに関連し、0=押下、1=押下されていないことを示す1バイトにまとめられます。

<a name="figure35"></a>![][CH04F35]

**図35:** 「`STRIG`」入力

この読み取り値は、[TRGFLG](#trgflg) に保持されている前回の読み取り値と比較され、アクティブ遷移バイトが生成されます。[TRGFLG](#trgflg) は新しい読み取り値で更新されます。アクティブ遷移バイトは通常はゼロですが、押されていない状態から押された状態への遷移が発生した各位置には1が格納されます。このアクティブ遷移バイトはビットごとにシフトアウトされ、アクティブなデバイスごとに [TRPTBL](#trptbl) の対応するエントリ ([0EF1H](#0ef1h)) が更新されます。

次に、キーボード マトリックスを完全にスキャンして新しいキーの押下を識別し、見つかったキーはキー コードに変換されて [KEYBUF](#keybuf) ([0D12H](#0d12h)) に格納されます。このプロセスの最後に [KEYBUF](#keybuf) が空であることが判明した場合、[REPCNT](#repcnt) がデクリメントされて、自動繰り返し遅延が経過したかどうかが確認され、経過していない場合はルーチンが終了します。遅延期間が経過した場合、[REPCNT](#repcnt) は高速繰り返し値 (60 ms) でリセットされ、[OLDKEY](#oldkey) キーボード マップが再初期化され、キーボードが再度スキャンされます (0D4EH)。このスキャン中に連続して押されたキーは、新しい遷移として表示されます。キーが自動繰り返しされるのは、アプリケーション プログラムが文字を読み取って [KEYBUF](#keybuf) を空にしている間だけであることに注意してください。その後、割り込み ハンドラーが終了します。

<a name="0d12h"></a>

    Address... 0D12H

このルーチンは、割り込みハンドラのためにキーボードマトリックスの 11 行すべてを完全にスキャンします。11 行はそれぞれ PPI を介して読み込まれ、[NEWKEY](#newkey) に昇順に配置されます。次に [ENSTOP](#enstop) をチェックして、ウォームスタートが有効かどうかを確認します。その内容がゼロでなく、CODE、GRAPH、CTRL、および SHIFT キーが押されている場合、制御は [CALBAS](#calbas) 標準ルーチンを介して BASIC インタープリタ (409BH) に渡されます。この機能は、割り込みハンドラが実行中である限り、マシンコードプログラムであっても終了できるため便利です。[NEWKEY](#newkey) の内容は [OLDKEY](#oldkey) に含まれる前回のスキャンと比較されます。何らかの変更があった場合は、[REPCNT](#repcnt) に初期の自動繰り返し遅延 (780 ms) がロードされます。次に、[NEWKEY](#newkey) から読み取った各行 1 を、[OLDKEY](#oldkey) に保持されている前の行と比較し、アクティブ遷移バイトを生成します。その後、[OLDKEY](#oldkey) が新しい読み取り値で更新されます。アクティブ遷移バイトは通常はゼロですが、押されていない状態から押された状態への遷移が発生した各位置には 1 が格納されます。行に何らかの遷移が含まれている場合、それらはデコードされ、[KEYBUF](#keybuf) にキーコード ([0D89H](#0d89h)) として格納されます。11 行すべてが完了すると、ルーチンは [PUTPNT](#putpnt) から [GETPNT](#getpnt) を減算することで [KEYBUF](#keybuf) に文字があるかどうかを確認し、終了します。

<a name="0d6ah"></a><a name="chsns"></a>

```
Address... 0D6AH
Name...... CHSNS
Entry..... なし
Exit...... KEYBUFに文字がある場合はNZフラグを立てる
Modifies.. AF、EI
```

キーボード入力可能な文字があるかどうかを確認する標準ルーチンです。画面が[グラフィックモード](#graphincsmode)または[マルチカラーモード](#multicolour_mode)の場合、[GETPNT](#getpnt)を[PUTPNT](#putpnt) (0D62H)から減算し、ルーチンを終了します。画面が[40x24テキストモード](#40x24_text_mode)または[32x24テキストモード](#32x24_text_mode)の場合、SHIFTキーの状態も確認し、ファンクションキーの表示が変化している場合は[DSPFNK](#dspfnk)標準ルーチンを介して更新します。

<a name="0d89h"></a>

    Address... 0D89H

このルーチンは、キーボード行遷移バイト内の各アクティブビットをキーコードに変換します。各ビットはまず、キーボードマトリックス内の位置に基づいてキー番号に変換されます。

<a name="figure36"></a>![][CH04F36]

**図36:** 主要な数字

キー番号はキーコードに変換され、[KEYBUF](#keybuf) ([1021H](#1021h))に格納されます。8ビットすべての処理が完了すると、ルーチンは終了します。

<a name="0da5h"></a>

    Address... 0DA5H

この表には、キー番号00Hから2FHまでのキーコードが、様々なコントロールキーの組み合わせごとに記載されています。表に0と入力されている場合、そのキーが押されてもキーコードは生成されません。

```
       37H  36H  35H  34H  33H  32H  31H  30H   Row  0
       3BH  5DH  5BH  5CH  3DH  2DH  39H  38H   Row  1
NORMAL 62H  61H  9CH  2FH  2EH  2CH  60H  27H   Row  2
       6AH  69H  68H  67H  66H  65H  64H  63H   Row  3
       72H  71H  70H  6FH  6EH  6DH  6CH  6BH   Row  4
       7AH  79H  78H  77H  76H  75H  74H  73H   Row  5

       26H  5EH  25H  24H  23H  40H  21H  29H   Row  0
       3AH  7DH  7BH  7CH  2BH  5FH  28H  2AH   Row  1
SHIFT  42H  41H  9CH  3FH  3EH  3CH  7EH  22H   Row  2
       4AH  49H  48H  47H  46H  45H  44H  43H   Row  3
       52H  51H  50H  4FH  4EH  4DH  4CH  4BH   Row  4
       5AH  59H  58H  57H  56H  55H  54H  53H   Row  5

       FBH  F4H  BDH  EFH  BAH  ABH  ACH  09H   Row  0
       06H  0DH  01H  1EH  F1H  17H  07H  ECH   Row  1
GRAPH  11H  C4H  9CH  1DH  F2H  F3H  BBH  05H   Row  2
       C6H  DCH  13H  15H  14H  CDH  C7H  BCH   Row  3
       18H  CCH  DBH  C2H  1BH  0BH  C8H  DDH   Row  4
       0FH  19H  1CH  CFH  1AH  C0H  12H  D2H   Row  5

       00H  F5H  00H  00H  FCH  FDH  00H  0AH   Row  0
       04H  0EH  02H  16H  F0H  1FH  08H  00H   Row  1
SHIFT  00H  FEH  9CH  F6H  AFH  AEH  F7H  03H   Row  2
GRAPH  CAH  DFH  D6H  10H  D4H  CEH  C1H  FAH   Row  3
       A9H  CBH  D7H  C3H  D3H  0CH  C9H  DEH   Row  4
       F8H  AAH  F9H  D0H  D5H  C5H  00H  D1H   Row  5

       E1H  E0H  98H  9BH  BFH  D9H  9FH  EBH   Row  0
       B7H  DAH  EDH  9CH  E9H  EEH  87H  E7H   Row  1
CODE   97H  84H  9CH  A7H  A6H  86H  E5H  B9H   Row  2
       91H  A1H  B1H  81H  94H  8CH  8BH  8DH   Row  3
       93H  83H  A3H  A2H  A4H  E6H  B5H  B3H   Row  4
       85H  A0H  8AH  88H  95H  82H  96H  89H   Row  5

       00H  00H  9DH  9CH  BEH  9EH  ADH  D8H   Row  0
       B6H  EAH  E8H  00H  00H  00H  80H  E2H   Row  1
SHIFT  00H  8EH  9CH  A8H  00H  8FH  E4H  B8H   Row  2
CODE   92H  00H  B0H  9AH  99H  00H  00H  00H   Row  3
       00H  00H  E3H  00H  A5H  00H  B4H  B2H   Row  4
       00H  00H  00H  00H  00H  90H  00H  00H   Row  5

        7    6    5    4    3    2    1    0    Column
```

</a>

<a name="0ec5h"></a>

    Address... 0EC5H

制御は [0FC3H](#0fc3h) からこのルーチンに移り、5つのファンクションキーのデコードを完了します。まず、[FNKFLG](#fnkflg) の該当エントリがチェックされ、キーが「`ON KEY GOSUB`」文に関連付けられているかどうかが判断されます。関連付けられている場合、かつ [CURLIN](#curlin) によって BASIC インタープリタがプログラムモードであることが示されていれば、[TRPTBL](#trptbl) の該当エントリが更新され ([0EF1H](#0ef1h))、ルーチンは終了します。キーが「`ON KEY GOSUB`」文に関連付けられていない場合、またはインタープリタがダイレクトモードの場合は、代わりにファンクションキーに関連付けられた文字列が返されます。各文字列は16文字なので、キー番号は16倍され、ワー​​クスペース領域にあるファンクションキー文字列の開始アドレスに加算されます。次に、ゼロバイト終端に達するまで、文字列から連続した文字が取得され、[KEYBUF](#keybuf) ([0F55H](#0f55h)) に配置されます。

<a name="0ef1h"></a>

    Address... 0EF1H

このルーチンは、BASICプログラム割り込みが発生した際に、[TRPTBL](#trptbl)内のデバイスのエントリを更新するために使用されます。エントリ時に、レジスタペアHLはテーブル内のデバイスのステータスバイトを指します。ステータスバイトのビット0が最初にチェックされ、デバイスが「`ON`」でない場合、ルーチンは何もせずに終了します。次に、イベントフラグであるビット2がチェックされます。これが既に設定されている場合はルーチンが終了し、そうでない場合はイベントが発生したことを示すためにビット2が設定されます。次に、イベントフラグであるビット1がチェックされます。デバイスが停止している場合は、ルーチンはそれ以上何もせずに終了します。それ以外の場合は、[ONGSBF](#ongsbf)がインクリメントされ、インタープリタ実行ループにイベントを処理する必要があることを通知します。

<a name="0f06h"></a>

    Address... 0F06H

キーデコーダのこのセクションは、HOMEキーのみを処理します。SHIFTキーの状態は、[NEWKEY](#newkey)の6行目と、[KEYBUF](#keybuf)に格納されているHOMEキーコード(0BH)またはCLSキーコード(0CH)に基づいて決定されます([0F55H](#0f55h))。

<a name="0f10h"></a>

    アドレス...0F10H

キーボードデコーダのこのセクションは、CAP、F1～F5、STOP、HOMEキーを除くキー番号30H～57Hを処理します。キー番号は、[1033H](#1033h)のテーブルでキーコードを検索するために使用され、そのキーコードは[KEYBUF](#keybuf) ([0F55H](#0f55h))に格納されます。

<a name="0f1fh"></a>

    Address... 0F1FH

キーボードデコーダのこのセクションは、ヨーロッパのMSXマシンにあるDEADキーを処理します。英国仕様のマシンでは、2行5列目のキーは常に、表の0DA5Hに示されているポンドキーコード（9CH）を生成します。ヨーロッパ仕様のマシンでは、この表の同じ位置にキーコードFFHが存在します。このキーコードは、次に押されたキーが母音の場合、アクセント付きグラフィック文字を生成するように変更する必要があることを示すフラグとしてのみ機能します。

SHIFT キーと CODE キーの状態は、[NEWKEY](#newkey) の 6 行目と、[KANAST](#kanast) に配置された次のいずれかによって決定されます: 01H=DEAD、02H=DEAD+SHIFT、03H=DEAD+CODE、04H=DEAD+SHIFT+CODE。

<a name="0f36h"></a>

    アドレス...0F36H

キーボードデコーダのこのセクションはCAPキーを処理します。[CAPST](#capst)の現在の状態が反転され、制御は[CHGCAP](#chgcap)標準ルーチンに移ります。

<a name="0f3dh"></a><a name="chgcap"></a>

```
Address... 0F3DH
Name...... CHGCAP
Entry..... A=オン/オフスイッチ
Exit...... なし
変更.. AF
```

Caps Lock LEDのオン/オフをレジスタAの内容（00H=オン、NZ=オフ）に応じて切り替える標準ルーチンです。LEDのオン/オフはPPIモードポートのビットセット/リセット機能を使用して変更されます。[CAPST](#capst)は変更されないため、このルーチンはキーボードで入力される文字には影響しません。

<a name="0f46h"></a>

    Address... 0F46H

キーボードデコーダのこのセクションは、STOPキーを処理します。CTRLキーの状態は[NEWKEY](#newkey)の6行目によって決定され、STOPキーコード（04H）またはCTRL/STOPキーコード（03H）が適宜生成されます。CTRL/STOPコードが生成された場合は、[INTFLG](#intflg)にコピーされ、[ISCNTC](#iscntc)標準ルーチンで使用されてから、[KEYBUF](#keybuf)（[0F55H](#0f55h)）に配置されます。STOPコードが生成された場合は、これも[INTFLG](#intflg)にコピーされますが、[KEYBUF](#keybuf)には配置されず、代わりにクリック音（0F64H）が生成されます。つまり、アプリケーションプログラムはROM BIOS標準ルーチンを介してSTOPキーコードを読み取ることができません。

<a name="0f55h"></a>

    アドレス...0F55H

キーボードデコーダのこのセクションは、キーコードを[KEYBUF](#keybuf)に格納し、クリック音を生成します。まず[PUTPNT](#putpnt)からキーボードバッファ内の正しいアドレスを取得し、そこにコードを格納します。その後、アドレスはインクリメントされます([105BH](#105bh))。[GETPNT](#getpnt)に追いついた場合は、キーボードバッファが一杯であるため、ルーチンはそれ以上の処理を行わずに終了します。そうでない場合は、[PUTPNT](#putpnt)が新しいアドレスで更新されます。

次に、[CLIKSW](#cliksw) と [CLIKFL](#clikfl) の両方をチェックし、クリックが必要かどうかを判断します。[CLIKSW](#cliksw) は一般的な有効/無効スイッチであり、[CLIKFL](#clikfl) はファンクションキーが押された際に複数のクリックを防止するために使用されます。クリックが必要と判断された場合、キークリック出力は [PPI モードポート](#ppi_mode_port) を介して設定され、50 µs の遅延後に制御は [CHGSND](#chgsnd) 標準ルーチンに移行します。

<a name="0f7ah"></a><a name="chgsnd"></a>

```
Address... 0F7AH
Name...... CHGSND
Entry..... A=オン/オフスイッチ
Exit...... なし
変更.. AF
```

[PPIモードポート](#ppi_mode_port)を介してキークリック出力を設定またはリセットするための標準ルーチン：00H=リセット、NZ=セット。このオーディオ出力はAC結合されているため、絶対的な極性をあまり気にする必要はありません。

<a name="0f83h"></a>

    Address... 0F83H

キーボードデコーダのこのセクションは、キー番号00Hから2FHを処理します。SHIFT、GRAPH、CODEキーの状態は[NEWKEY](#newkey)の6行目から決定され、キー番号と組み合わせて[0DA5H](#0da5h)のテーブルへの参照アドレスを形成します。その後、テーブルからキーコードが取得されます。キーコードが0の場合、ルーチンはそれ以上何もせずに終了し、FFHの場合、制御はDEADキープロセッサ([0F1FH](#0f1fh))に移ります。コードが40Hから5FHまたは60Hから7FHの範囲内にあり、CTRLキーが押された場合、対応する制御コードが[KEYBUF](#keybuf)([0F55H](#0f55h))に格納されます。コードが 01H から 1FH の範囲にある場合、最初にグラフィック ヘッダー コード (01H) が [KEYBUF](#keybuf) ([0F55H](#0f55h)) に配置され、その後に 40H が追加されたコードが続きます。コードが 61H から 7BH の範囲にあり、[CAPST](#capst) が Caps Lock がオンであることを示す場合、20H を減算して大文字に変換されます。[KANAST](#kanast) にゼロが含まれていると仮定すると (英国のマシンでは常にそうなります)、キー コードは [KEYBUF](#keybuf) ([0F55H](#0f55h)) に配置され、ルーチンは終了します。ヨーロッパの MSX マシンでは、ポンド キーの代わりに DEAD キーがあり、母音 a、e、i、o、u に対応するキー コードがグラフィック コードにさらに変更される場合があります。

<a name="0fc3h"></a>

    Address... 0FC3H

キーボードデコーダのこのセクションは、5つのファンクションキーを処理します。SHIFTキーの状態は[NEWKEY](#newkey)の6行目によって確認され、押されている場合はキー番号に5が加算されます。その後、制御は[0EC5H](#0ec5h)に移り、処理を完了します。

<a name="1021h"></a>

    Address... 1021H

このルーチンは、[1B97H](#1b97h)のテーブルを検索し、レジスタCに与えられたキー番号がどのキーグループに属するかを判断します。次に、対応するアドレスをテーブルから取得し、キーボードデコーダの該当セクションに制御を移します。なお、このテーブル自体は、日本語版ROMに加えられた変更の結果、標準ルーチン[OUTDO](#outdo)の途中にパッチされていることに注意してください。

<a name="1033h"></a>

    Address... 1033H

この表には、CAP、F1～F5、STOP、HOMEキーを除く、キー番号30H～57Hのキーコードが記載されています。表に0と記載されている場合は、そのキーを押してもキーコードが生成されません。

```
00H 00H 00H 00H 00H 00H 00H 00H 6行目
0DH 18H 08H 00H 09H 1BH 00H 00H 7行目
1CH 1FH 1EH 1DH 7FH 12H 0CH 20H 8行目
34H 33H 32H 31H 30H 00H 00H 00H 9行目
2EH 2CH 2DH 39H 38H 37H 36H 35H 10行目

 7   6   5   4   3   2   1   0  列
```

</a>

<a name="105bh"></a>

    Address... 105BH

このルーチンは単に [KANAST](#kanast) をゼロにして、制御を [10C2H](#10c2h) に渡します。

<a name="1061h"></a>

    Address... 1061H

この表には、ヨーロッパのマシンで母音 a、e、i、o、u を置き換えるグラフィックス文字が含まれています。

<a name="10c2h"></a>

    Address... 10C2H

このルーチンは、レジスタペアHLに指定されたキーボードバッファポインタ（[PUTPNT](#putpnt)または[GETPNT](#getpnt)）をインクリメントします。ポインタがキーボードバッファの終端を超えた場合は、先頭に戻ります。

<a name="10cbh"></a><a name="chget"></a>

```
Address... 10CBH
Name...... CHGET
Entry..... なし
Exit...... A=キーボードからの文字
Modifies.. AF、EI
```

キーボードバッファから文字を取得する標準ルーチンです。まず、バッファに既に文字が含まれているかどうかを確認します([0D6AH](#0d6ah))。含まれていない場合はカーソルをオンにし([09DAH](#09dah))、文字が表示されるまでバッファを繰り返しチェックし([0D6AH](#0d6ah))、文字が現れたらカーソルをオフにします([0A27H](#0a27h))。[GETPNT](#getpnt)を使用してバッファから文字を取得し、インクリメントします([10C2H](#10c2h))。

<a name="10f9h"></a><a name="ckcntc"></a>

```
Address... 10F9H
Name...... CKCNTC
Entry..... なし
Exit...... なし
Modifies.. AF、EI
```

CTRL-STOPキーまたはSTOPキーが押されたかどうかを確認する標準ルーチンです。BASICインタープリタは、このルーチンを「`WAIT`」や「`CIRCLE`」といったプロセッサ負荷の高いステートメント内で使用し、プログラムの終了を確認します。レジスタペアHLはまずゼロに設定され、その後制御が[ISCNTC](#iscntc)標準ルーチンに移されます。インタープリタの実行中、レジスタペアHLには通常、BASICプログラムテキスト内の現在の文字のアドレスが格納されています。[ISCNTC](#iscntc)がCTRL-STOPで終了した場合、このアドレスは「`STOP`」ステートメントハンドラ(63E6H)によって[OLDTXT](#oldtxt)に格納され、後続の「`CONT`」ステートメントで使用されます。レジスタペアHLを事前にゼロに設定しておくことで、「`CONT`」ハンドラはステートメント内で終了が発生したことを通知され、継続処理が試行された場合に「`Can't CONTINUE`」エラーを発行します。

<a name="1102h"></a><a name="wrtpsg"></a>

```
Address... 1102H
Name...... WRTPSG
Entry..... A=Register number, E=Data byte
Exit...... なし
Modifies.. EI
```

16個の[PSGレジスタ](#registers_0_and_1)のいずれかにデータバイトを書き込む標準ルーチンです。レジスタ選択番号はPSGの[アドレスポート](#address_port)に書き込まれ、データバイトはPSGの[データ書き込みポート](#data_write_port)に書き込まれます。

<a name="110eh"></a><a name="rdpsg"></a>

```
Address... 110EH
Name...... RDPSG
Entry..... A=Register number
Exit...... A=Data byte read from PSG
Modifies.. A
```

16個の[PSGレジスタ](#registers_0_and_1)のいずれかからデータバイトを読み取る標準ルーチンです。レジスタ選択番号はPSGの[アドレスポート](#address_port)に書き込まれ、データバイトはPSGの[データ読み取りポート](#data_read_port)から読み取られます。

<a name="1113h"></a><a name="beep"></a>

```
Address... 1113H
Name...... BEEP
Entry..... なし
Exit...... なし
Modifies.. AF, BC, E, EI
```

PSGを介してビープ音を生成する標準ルーチン。チャンネルAは1316Hzの音を生成するように設定され、その後振幅7で有効になります。40ミリ秒の遅延の後、制御は[GICINI](#gicini)標準ルーチンに移行し、PSGを再初期化します。

<a name="113bh"></a>

    Address... 113BH

このルーチンは、割り込みハンドラによって音楽キューを処理するために使用されます。このルーチンは3つあり、それぞれがPSGチャネルにデータを送信するため、処理するキューはレジスタAにキュー番号を指定することで指定します。0=[VOICAQ](#voicaq)、1=[VOICBQ](#voicbq)、2=[VOICCQ](#voiccq)です。

"`PLAY`" 文の各文字列は、BASICインタープリタによって一連のデータパケットに変換されます。これらのパケットは適切なキューに配置され、最後にデータ終了バイト（FFH）が付加されます。パケットのキューからの取り出し、デコード、およびPSGの設定は、割り込みハンドラによって実行されます。これにより、インタープリタは音符の再生が終了するのを待つことなく、直ちに次の文に進むことができます。

パケットの最初の2バイトは、バイト数と持続時間を指定します。最初のバイトの上位3ビットは、パケット内のヘッダーに続くバイト数を指定します。ヘッダーの残りの部分は、イベントの持続時間を20ミリ秒単位で指定します。この持続時間は、次のパケットがキューから読み出されるまでの時間を決定します。

<a name="figure37"></a>![][CH04F37]

**図37:** パケットヘッダー

パケット ヘッダーの後に、周波数または振幅情報を含む 0 個以上のブロックが任意の順序で続く場合があります。

<a name="figure38"></a>![][CH04F38]

**図38:** パケットブロックの種類

このルーチンはまず、[GETVCP](#getvcp) 標準ルーチンを介して、対応する音声バッファ（[VCBA](#vcba)、[VCBB](#vcbb)、または[VCBC](#vcbc)）内の現在の継続時間カウンタを見つけ、それを減算します。カウンタがゼロに達した場合は、キューから次のパケットを読み出す必要があります。ゼロでない場合は、ルーチンは終了します。

キュー番号が [QUEUEN](#queuen) に格納され、キューから 1 バイトが読み取られます ([11E2H](#11e2h))。次に、これがデータ終了マーク (FFH) かどうかがチェックされ、そうであればキューが終了します ([11B0H](#11b0h))。そうでない場合は、バイト数がレジスタ C に格納され、期間の MSB が関連する音声バッファに格納されます。2 番目のバイトが読み取られ ([11E2H](#11e2h))、期間の LSB が関連する音声バッファに格納されます。次にバイト数が調べられ、パケット ヘッダーに続くバイトがない場合、ルーチンは終了します。そうでない場合は、バイト数がなくなるまで、キューから連続するバイトが読み取られ、適切なアクションが実行されます。

周波数ブロックが見つかった場合は、2 番目のバイトが読み取られ、キュー番号に応じて両方のバイトが PSG レジスタ [0](#registers_0_and_1) と [1](#registers_0_and_1)、[2](#registers_2_and_3) と [3](#registers_2_and_3)、または [4](#registers_4_and_5) と [5](#registers_4_and_5) に書き込まれます。

振幅ブロックが見つかった場合、振幅ビットとモードビットがキュー番号に応じてPSGレジスタ[8](#register_8)、[9](#register_9)、または[10](#register_10)に書き込まれます。モードビットが1の場合、つまり固定振幅ではなく変調振幅が選択されている場合、エンベロープ形状を設定するために、そのバイトがPSGレジスタ[13](#register_13)にも書き込まれます。

エンベロープブロックが見つかった場合、または振幅ブロックのビット6が設定されている場合は、さらに2バイトがキューから読み取られ、PSGレジスタ[11](#registers_11_and_12)と[12](#registers_11_and_12)に書き込まれます。

<a name="11b0h"></a>

    Address... 11B0H

このルーチンは、3つのミュージックキューのいずれかでデータ終了マーク（FFH）が見つかった場合に使用されます。キュー番号に応じて、PSGレジスタ[8](#register_8)、[9](#register_9)、または[10](#register_10)に振幅値0が書き込まれ、チャネルがシャットダウンされます。その後、[MUSICF](#musicf)内の該当チャネルのビットがリセットされ、制御は[STRTMS](#strtms)標準ルーチンに移行します。

<a name="11c4h"></a><a name="strtms"></a>

```
Address... 11C4H
Name...... STRTMS
Entry..... なし
Exit...... なし
Modifies.. AF, HL
```

"`PLAY`" ステートメントハンドラが割り込みハンドラによる音楽のデキューを開始するために使用する標準ルーチンです。まず [MUSICF](#musicf) が調べられ、いずれかのチャンネルが既に実行中の場合、ルーチンは何もせずに終了します。次に [PLYCNT](#plycnt) がデクリメントされ、キューに "`PLAY`" 文字列が残っていない場合、ルーチンは終了します。それ以外の場合、[VCBA](#vcba)、[VCBB](#vcbb)、[VCBC](#vcbc) の3つの継続時間カウンタが0001Hに設定され、新しいグループの最初のパケットが次の割り込み時にデキューされます。[MUSICF](#musicf) が07Hに設定され、3つのチャンネルすべてが有効になります。

<a name="11e2h"></a>

    Address... 11E2H

このルーチンは、[QUEUEN](#queuen) から現在のキュー番号をレジスタ A にロードし、そのキューから 1 バイトを読み取ります ([14ADH](#14adh))。

<a name="11eeh"></a><a name="gtstck"></a>

```
Address... 11EEH
Name...... GTSTCK
Entry..... A=Joystick ID (0, 1 or 2)
Exit...... A=Joystick position code (0～8)
Modifies.. AF, B, DE, HL, EI
```

ジョイスティックまたは4つのカーソルキーの位置を読み取る標準ルーチンです。指定されたIDが0の場合、カーソルキーの状態は[PPIポートB](ppi_port_b) ([1226H](#1226h)) を介して読み取られ、1243Hのルックアップテーブルを使用して位置コードに変換されます。それ以外の場合は、ジョイスティックコネクタ1または2 ([120CH](#120ch)) が読み取られ、1233Hのルックアップテーブルを使用して4つの方向ビットが位置コードに変換されます。返される位置コードは以下のとおりです。

<a name="figure39a"></a>![][CH04F39a]

<a name="120ch"></a>

    Address... 120CH

このルーチンは、レジスタAの内容で指定されたジョイスティックコネクタを読み取ります：0=コネクタ1、1=コネクタ2。PSG [レジスタ15](#register_15)の現在の内容を読み取り、ジョイスティック選択ビットを適切に設定して書き戻します。その後、PSG [レジスタ14](#register_14)がレジスタA (110CH)に読み込まれ、ルーチンは終了します。

<a name="1226h"></a>

    Address... 1226H

このルーチンはキーボードマトリックスの8行目を読み取ります。[PPIポートC](ppi_port_c)の現在の内容が読み込まれ、8行目のキーボード行選択ビット4つがセットされた状態で書き戻されます。その後、列入力が[PPIポートB](ppi_port_b)からレジスタAに読み込まれます。

<a name="1253h"></a><a name="gttrig"></a>

```
Address... 1253H
Name...... GTTRIG
Entry..... A=Trigger ID (0, 1, 2, 3 or 4)
Exit...... A=Status code
Modifies.. AF, BC, EI
```

ジョイスティックのトリガーまたはスペースキーの状態を確認する標準ルーチンです。指定されたIDが0の場合、キーボードマトリックスの8行目([1226H](#1226h))が読み込まれ、ステータスコードに変換されます。それ以外の場合、ジョイスティックコネクタ1または2([120CH](#120ch))が読み込まれ、ステータスコードに変換されます。選択IDは以下のとおりです。

```
0=スペースキー
1=JOY 1、トリガーA
2=JOY 2、トリガーA
3=JOY 1、トリガーB
4=JOY 2、トリガーB
```

関連するトリガーが押された場合は返される値は FFH になり、それ以外の場合はゼロになります。

<a name="1273h"></a><a name="gtpdl"></a>

```
Address... 1273H
Name...... GTPDL
Entry..... A=Paddle ID (1 to 12)
Exit...... A=Paddle value (0 to 255)
Modifies.. AF, BC, DE, EI
```

ジョイスティック コネクタに接続されたパドルの値を読み取る標準ルーチンです。コネクタごとに 6 つの入力ライン (4 つの方向と 2 つのトリガー) のそれぞれがパドルをサポートできるため、合計で 12 個のパドルが可能です。ジョイスティック コネクタ 1 に接続されたパドルのエントリ ID は 1、3、5、7、9、11 です。ジョイスティック コネクタ 2 に接続されたパドルのエントリ ID は 2、4、6、8、10、12 です。各パドルは基本的にワンショット パルス ジェネレーターで、パルスの長さは可変抵抗器によって制御されます。開始パルスは、PSG [レジスタ 15](#register_15) を介して指定されたジョイスティック コネクタに発行されます。次に、関連する入力がタイムアウトするまでに PSG [レジスタ 14](#register_14) を何回読み取る必要があるかをカウントします。各単位の増分は、1 つの待機状態がある MSX マシン上でおよそ 12 µs の期間を表します。

<a name="12ach"></a><a name="gtpad"></a>

```
Address... 12ACH
Name...... GTPAD
Entry..... A=Function code (0 to 7)
Exit...... A=Status or value
Modifies.. AF, BC, DE, HL, EI
```

ジョイスティックコネクタのいずれかに接続されたタッチパッドにアクセスするための標準ルーチン。ジョイスティックコネクタ1で使用可能な機能コードは次のとおりです。

```
0=アクティビティステータスを返す
1=X座標を返す
2=Y座標を返す
3=スイッチステータスを返す
```

機能コード4～7は、ジョイスティックコネクタ2に対して同じ効果を持ちます。アクティビティステータス関数は、タッチパッドがタッチされている場合はFFHを、それ以外の場合はゼロを返します。スイッチステータス関数は、スイッチが押されている場合はFFHを、それ以外の場合はゼロを返します。2つの座標要求関数は、最後にタッチされた位置の座標を返します。これらの座標は、機能コード0または4の呼び出しでアクティビティが検出されると、ワークスペース領域変数[PADX](#padx)と[PADY](#pady)に格納されます。これらの変数は両方のジョイスティックコネクタで共有されることに注意してください。

<a name="1384h"></a><a name="stmotr"></a>

```
Address... 1384H
Name...... STMOTR
Entry..... A=Motor ON/OFF code
Exit...... なし
Modifies.. AF
```

[PPI ポート C](ppi_port_c) を介してカセット モーター リレーをオンまたはオフにする標準ルーチン: 00H=オフ、01H=オン、FFH=逆電流状態。

<a name="1398h"></a><a name="nmi"></a>

```
Address... 1398H
Name...... NMI
Entry..... なし
Exit...... なし
Modifies.. なし
```

Z80 マスク不可能割り込みを処理するための標準ルーチン。標準の MSX マシンに戻るだけです。

<a name="139dh"></a><a name="inifnk"></a>

```
Address... 139DH
Name...... INIFNK
Entry..... なし
Exit...... なし
Modifies.. BC, DE, HL
```

10個のファンクションキー文字列を電源投入時の値に初期化する標準ルーチンです。[13A9H](#13a9h)から始まる160バイトのデータが、ワークスペース領域の[FNKSTR](#fnkstr)バッファにコピーされます。

<a name="13a9h"></a>

    Address... 13A9H

この領域には、10個のファンクションキーの電源投入時の文字列が格納されます。各文字列は16文字で、未使用の位置に0が入ります。

```
F1 to F5  F6 to F10
color     color 15,4,4 CR
auto      cload"
goto      cont CR
list      list. CR UP UP
run CR    run CLS CR
```

<a name="1449h"></a><a name="rdvdp"></a>

```
Address... 1449H
Name...... RDVDP
Entry..... なし
Exit...... A=VDP Status Register contents
Modifies.. A
```

[コマンドポート](#command_port)を読み取って[VDPステータスレジスタ](#vdp_status_register)の内容を入力する標準ルーチンです。[VDPステータスレジスタ](#vdp_status_register)を読み出すと、関連するフラグがクリアされ、割り込みハンドラに影響を与える可能性があることに注意してください。

<a name="144ch"></a><a name="rslreg"></a>

```
Address... 144CH
Name...... RSLREG
Entry..... なし
Exit...... A=Primary Slot Register contents
Modifies.. A
```

[PPI ポート A](ppi_port_a) を読み取ってプライマリ スロット レジスタの内容を入力する標準ルーチン。

<a name="144fh"></a><a name="wslreg"></a>

```
Address... 144FH
Name...... WSLREG
Entry..... A=Value to write
Exit...... なし
Modifies.. なし
```

[PPI ポート A](ppi_port_a) に書き込むことでプライマリ スロット レジスタを設定する標準ルーチン。

<a name="1452h"></a><a name="snsmat"></a>

```
Address... 1452H
Name...... SNSMAT
Entry..... A=Keyboard row number
Exit...... A=Column data of keyboard row
Modifies.. AF, C, EI
```

キーボードマトリックスの1行全体を読み取る標準ルーチンです。[PPIポートC](ppi_port_c) を読み込んだ後、4つのキーボード行選択ビットに行番号を書き込みます。次に、[PPIポートB](ppi_port_b) をレジスタAに読み込み、8つの列入力を返します。[PPIポートC](ppi_port_c) の4つのその他の制御出力は、このルーチンの影響を受けません。

<a name="145fh"></a><a name="isflio"></a>

```
Address... 145FH
Name...... ISFLIO
Entry..... なし
Exit...... Flag NZ if file I/O active
Modifies.. AF
```

BASICインタープリタが現在、入出力バッファを介して入力または出力を行っているかどうかを確認する標準ルーチンです。これは[PTRFIL](#ptrfil)を調べることで判定されます。通常は0ですが、インタープリタが「`PRINT#1`」、「`INPUT#1`」などのステートメントを実行している間は、バッファのFCB（ファイル制御ブロック）アドレスが格納されます。

<a name="146ah"></a><a name="dcompr"></a>

```
Address... 146AH
Name...... DCOMPR
Entry..... HL, DE
Exit...... Flag NC if HL>DE, Flag Z if HL=DE, Flag C if HL<DE
Modifies.. AF
```

BASIC インタープリタがレジスタ ペア HL と DE の相対値をチェックするために使用する標準ルーチン。

<a name="1470h"></a><a name="getvcp"></a>

```
Address... 1470H
Name...... GETVCP
Entry..... A=Voice number (0, 1, 2)
Exit...... HL=Address in voice buffer
Modifies.. AF, HL
```

指定された音声バッファ([VCBA](#vcba)、[VCBB](#vcbb)、または[VCBC](#vcbc))のバイト2のアドレスを返す標準ルーチン。

<a name="1474h"></a><a name="getvc2"></a>

```
Address... 1474H
Name...... GETVC2
Entry..... L=Byte number (0 to 36)
Exit...... HL=Address in voice buffer
Modifies.. AF, HL
```

[VOICEN](#voicen) のボイス番号で指定されたボイスバッファ ([VCBA](#vcba)、[VCBB](#vcbb)、または [VCBC](#vcbc)) 内の任意のバイトのアドレスを返す標準ルーチン。

<a name="148ah"></a><a name="phydio"></a>

```
Address... 148AH
Name...... PHYDIO
Entry..... なし
Exit...... なし
Modifies.. なし
```

Disk BASIC で使用するための標準ルーチン。標準の MSX マシンでは単に返されます。

<a name="148eh"></a><a name="format"></a>

```
Address... 148EH
Name...... FORMAT
Entry..... なし
Exit...... なし
Modifies.. なし
```

Disk BASIC で使用するための標準ルーチン。標準の MSX マシンでは単に返されます。

<a name="1492h"></a><a name="putq"></a>

```
Address... 1492H
Name...... PUTQ
Entry..... A=Queue number, E=Data byte
Exit...... Flag Z if queue full
Modifies.. AF, BC, HL
```

3つの音楽キューの1つにデータバイトを配置する標準ルーチンです。キューの取得位置と配置位置は、まず[QUETAB](#quetab) ([14FAH](#14fah)) から取得されます。配置位置は一時的にインクリメントされ、取得位置と比較されます。両者が等しい場合は、キューが一杯であるためルーチンは終了します。そうでない場合は、キューのアドレスが[QUETAB](#quetab) から取得され、配置位置がそれに加算されます。データバイトはキューのこの位置に配置され、配置位置がインクリメントされてルーチンは終了します。音楽キューは循環型であることに注意してください。取得または配置ポインタがキューの最後の位置に達すると、キューの先頭に戻ります。

<a name="14adh"></a>

    Address... 14ADH

このルーチンは、割り込みハンドラによって使用され、3 つの音楽キューの 1 つから 1 バイトを読み取ります。キュー番号はレジスタ A に提供され、データ バイトはレジスタ A に返されます。キューが空の場合、ルーチンはフラグ Z を返します。キューの取得位置と配置位置は、最初に [QUETAB](#quetab) ([14FAH](#14fah)) から取得されます。プットバック フラグがアクティブの場合、データ バイトは [QUEBAK](#quebak) から取得され、ルーチンは終了します (14D1H)。この機能は、MSX ROM の現在のバージョンでは使用されていません。次に、配置位置が取得位置と比較され、それらが等しい場合は、キューが空であるためルーチンは終了します。それ以外の場合は、キューのアドレスが [QUETAB](#quetab) から取得され、それに取得位置が加算されます。データ バイトはキューのこの位置から読み取られ、取得位置が増分されてルーチンは終了します。

    Address... 14DAH

このルーチンは、[GICINI](#gicini) 標準ルーチンによって使用され、[QUETAB](#quetab) 内のキューの制御ブロックを初期化します。制御ブロックはまず [QUETAB](#quetab) ([1504H](#1504h)) に配置され、put、get、および putback の各バイトがゼロに設定されます。サイズバイトはレジスタ B から、キューアドレスはレジスタペア DE から設定されます。

<a name="14ebh"></a><a name="lftq"></a>

```
Address... 14EBH
Name...... LFTQ
Entry..... A=Queue number
Exit...... HL=Free space left in queue
Modifies.. AF, BC, HL
```

音楽キューに残っている空きバイト数を返す標準ルーチンです。キューのget位置とput位置は[QU​​ETAB](#quetab) ([14FAH](#14fah))から取得され、空き容量はgetからputを引いて算出されます。

<a name="14fah"></a>

    Address... 14FAH

このルーチンは [QUETAB](#quetab) からキューの制御パラメータを返します。キュー番号はレジスタ A に提供されます。制御ブロックは最初に [QUETAB](#quetab) ([1504H](#1504h)) に配置され、次にプット位置がレジスタ B に、取得位置がレジスタ C に、プットバック フラグがレジスタ A に配置されます。

<a name="1504h"></a>

    Address... 1504H

このルーチンは、[QUETAB](#quetab) 内のキューの制御ブロックを検索します。キュー番号はレジスタAに渡され、制御ブロックのアドレスはレジスタペアHLに返されます。キュー番号はブロックあたり6バイトなので、単純に6倍され、[QUEUES](#queues) に格納されている [QUETAB](#quetab) のアドレスに加算されます。

<a name="1510h"></a><a name="grpprt"></a>

```
Address... 1510H
Name...... GRPPRT
Entry..... A=Character
Exit...... なし
Modifies.. EI
```

[グラフィック モード](#graphics_mode) または [マルチカラー モード](#multicolour_mode) のいずれかで画面上に文字を表示するための標準ルーチンです。機能的には [CHPUT](#chput) 標準ルーチンと同等です。

[CNVCHR](#cnvchr) 標準ルーチンは、まずグラフィック文字の有無をチェックするために使用されます。文字がヘッダーコード (01H) の場合、ルーチンは何もせずに終了します。文字が変換されたグラフィックコードの場合、制御コードのデコードセクションはスキップされます。それ以外の場合は、文字が制御コードかどうかがチェックされます。CRコード (0DH) ([157EH](#157eh)) のみが認識され、20H未満の他の文字はすべて無視されます。

文字が表示可能であると仮定すると、その8バイトのピクセルパターンがROM文字セットから[PATWRK](#patwrk)バッファ(0752H)にコピーされ、[FORCLR](#forclr)が[ATRBYT](#atrbyt)にコピーされて色設定されます。次に、現在のグラフィックス座標が[GRPACX](#grpacx)と[GRPACY](#grpacy)から取得され、[SCALXY](#scalxy)と[MAPXYC](#mapxyc)標準ルーチンを介して現在のピクセル物理アドレスを設定するために使用されます。

[PATWRK](#patwrk) 内の8バイトパターンは、1バイトずつ処理されます。各バイトの開始時に、[FETCHC](#fetchc) 標準ルーチンによって現在のピクセル物理アドレスが取得され、保存されます。その後、8ビットが順に検査されます。ビットが1の場合、対応するピクセルは[SETC](#setc) 標準ルーチンによって設定され、0の場合は何も行われません。各ビットの後、現在のピクセル物理アドレスは右に移動します([16ACH](#16ach))。バイトが終了するか、画面の右端に達すると、最初の現在のピクセル物理アドレスが復元され、[TDOWNC](#tdownc) 標準ルーチンによって1つ下に移動します。

パターンが完成するか、画面の下部に到達すると、[GRPACX](#grpacx) が更新されます。[グラフィックモード](#graphics_mode) では値が8増加し、[マルチカラーモード](#multicolour_mode) では値が32増加します。[GRPACX](#grpacx) が画面の右端である255を超えると、CR演算が実行されます([157EH](#157eh))。

<a name="157eh"></a>

    Address... 157EH

このルーチンは、[GRPPRT](#grpprt) 標準ルーチンの CR 操作を実行します。このコードは CR と LF を組み合わせたものとして機能します。[GRPACX](#grpacx) はゼロに設定され、画面モードに応じて 8 または 32 が [GRPACY](#grpacy) に加算されます。[GRPACY](#grpacy) が画面下端の 191 を超える場合は、ゼロに設定されます。

[GRPACX](#grpacx) と [GRPACY](#grpacy) は、利用可能な制御機能の数が限られていることを補うために、アプリケーション プログラムによって直接操作される場合があります。

<a name="1599h"></a><a name="scalxy"></a>

```
Address... 1599H
Name...... SCALXY
Entry..... BC=X coordinate, DE=Y coordinate
Exit...... Flag NC if clipped
Modifies.. AF
```

必要に応じてグラフィック座標のペアをクリップする標準ルーチンです。BASICインタープリタは、実際の画面サイズをはるかに超える-32768～+32767の範囲の座標を生成できます。このルーチンは、物理的に実現可能な範囲内に収まるように、超過した座標値を修正します。X座標が255より大きい場合は255に設定され、Y座標が191より大きい場合は191に設定されます。いずれかの座標が負の値（7FFFHより大きい値）の場合は0に設定されます。最後に、画面が[マルチカラーモード](#multicolour_mode)の場合、[MAPXYC](#mapxyc)標準ルーチンの要件に従って、両方の座標が4で割られます。

    Address... 15D9H

このルーチンは現在の画面モードを確認するために使用され、画面が [グラフィックス モード](#graphics_mode) の場合、フラグ Z を返します。

<a name="15dfh"></a><a name="mapxyc"></a>

```
Address... 15DFH
Name...... MAPXYC
Entry..... BC=X coordinate, DE=Y coordinate
Exit...... なし
Modifies.. AF, D, HL
```

グラフィックス座標ペアを現在のピクセル物理アドレスに変換する標準ルーチンです。ピクセルを含むバイトの文字パターンテーブルにおける位置は[CLOC](#cloc)に格納されます。そのバイト内のピクセルを識別するビットマスクは[CMASK](#cmask)に格納されます。[グラフィックスモード](#graphics_mode)と[マルチカラーモード](#multicolour_mode)では変換方法が若干異なりますが、BASICで同等のプログラムは以下のとおりです。

```
Graphics Mode

10 INPUT"X,Y Coordinates";X,Y
20 A=(Y\8)*256+(Y AND 7)+(X AND &HF8)
30 PRINT"ADDR=";HEX$(Base(12)+A);"H ";
40 RESTORE 100
50 FOR N=0 TO (X AND 7):READ M$: NEXT N
60 PRINT"MASK=";M$
70 GOTO 10
100 DATA 10000000
110 DATA 01000000
120 DATA 00100000
130 DATA 00010000
140 DATA 00001000
150 DATA 00000100
160 DATA 00000010
170 DATA 00000001
```

</a>

```
Multicolour Mode

10 INPUT"X,Y Coordinates";X,Y
20 X=X\4:Y-Y\4
30 A=(Y\8)*256+(Y AND 7)+(X*4 AND &HF8)
40 PRINT"ADDR=";HEX$(BASE(17)+A);"H ";
50 IF X MOD 2=0 THEN MS="11110000" ELSE MS="00001111"
60 PRINT"MASK=";M$
70 GOTO 10
```

両プログラムとも、入力可能な範囲はX=0～255、Y=0～191です。[グラフィックスモード](#graphics_mode)プログラムのデータステートメントは、MSX ROMの160BHから始まる8バイトのマスクテーブルに対応しています。[マルチカラーモード](#multicolour_mode)プログラムの20行目は、実際には[SCALXY](#scalxy)標準ルーチンの4で割る処理に対応しています。これは、両プログラムの座標系を統一するために含まれています。

<a name="1639h"></a><a name="fetchc"></a>

```
Address... 1639H
Name...... FETCHC
Entry..... なし
Exit...... A=CMASK, HL=CLOC
Modifies.. A, HL
```

現在のピクセル物理アドレスを返す標準ルーチン。レジスタ ペア HL は [CLOC](#cloc) からロードされ、レジスタ A は [CMASK](#cmask) からロードされます。

<a name="1640h"></a><a name="storec"></a>

```
Address... 1640H
Name...... STOREC
Entry..... A=CMASK, HL=CLOC
Exit...... なし
Modifies.. なし
```

現在のピクセルの物理アドレスを設定するための標準ルーチン。レジスタ ペア HL は [CLOC](#cloc) にコピーされ、レジスタ A は [CMASK](#cmask) にコピーされます。

<a name="1647h"></a><a name="readc"></a>

```
Address... 1647H
Name...... READC
Entry..... なし
Exit...... A=Colour code of current pixel
Modifies.. AF, EI
```

現在のピクセルの色を返す標準ルーチンです。まず[FETCHC](#fetchc)標準ルーチンによってVRAMの物理アドレスが取得されます。画面が[グラフィックモード](#graphics_mode)の場合、[CLOC](#cloc)で指定されたバイトが[RDVRM](#rdvrm)標準ルーチンによって文字パターンテーブルから読み取られます。次に[CMASK](#cmask)によって必要なビットが分離され、カラーテーブル内の対応するエントリの上位4ビットまたは下位4ビットが選択されます。

画面が[マルチカラーモード](#multicolour_mode)の場合、[CLOC](#cloc)で指定されたバイトは、[RDVRM](#rdvrm)標準ルーチンを介して文字パターンテーブルから読み取られます。その後、[CMASK](#cmask)を使用して、このバイトの上位4ビットまたは下位4ビットを選択します。どちらの場合も、返される値は0から15までの通常のVDPカラーコードになります。

<a name="1676h"></a><a name="setatr"></a>

```
Address... 1676H
Name...... SETATR
Entry..... A=Colour code
Exit...... Flag C if illegal code
Modifies.. Flags
```

[SETC](#setc) および [NSETCX](#nsetcx) 標準ルーチンで使用されるグラフィックインクの色を設定する標準ルーチンです。0から15までの色コードは、[ATRBYT](#atrbyt) に格納されます。

<a name="167eh"></a><a name="setc"></a>

```
Address... 167EH
Name...... SETC
Entry..... なし
Exit...... なし
Modifies.. AF, EI
```

現在のピクセルを任意の色に設定する標準ルーチン。カラーコードは[ATRBYT](#atrbyt)から取得されます。ピクセルのVRAM物理アドレスは、まず[FETCHC](#fetchc)標準ルーチンによって取得されます。[グラフィックスモード](#graphics_mode)では、文字パターンテーブルとカラーテーブルの両方が変更されます([186CH](#186ch))。

[マルチカラーモード](#multicolour_mode)では、[CLOC](#cloc)で指定されたバイトが[RDVRM](#rdvrm)標準ルーチンによって文字パターンテーブルから読み取られます。その後、[ATRBYT](#atrbyt)の内容が[CMASK](#cmask)によって決定された上位または下位4ビットに格納され、そのバイトが[WRTVRM](#wrtvrm)標準ルーチンによって書き戻されます。

<a name="16ach"></a>

    Address... 16ACH

このルーチンは、現在のピクセルの物理アドレスを1つ右に移動します。画面の右端を超えた場合は、フラグCが返され、物理アドレスは変更されません。[グラフィックスモード](#graphics_mode)では、[CMASK](#cmask)がまず1ビット右にシフトされ、ピクセルがまだバイト内に収まっている場合はルーチンが終了します。[CLOC](#cloc)が右端の文字セル(LSB=F8H～FFH)にある場合は、ルーチンはフラグC(175AH)で終了します。それ以外の場合は、[CMASK](#cmask)が左端のピクセルである80Hに設定され、[CLOC](#cloc)に0008Hが加算されます。

[マルチカラーモード](#multicolour_mode)では、制御は別のルーチン([1779H](#1779h))に移ります。

<a name="16c5h"></a><a name="rightc"></a>

```
Address... 16C5H
Name...... RIGHTC
Entry..... なし
Exit...... なし
Modifies.. AF
```

現在のピクセルの物理アドレスを1つ右に移動する標準ルーチンです。[グラフィックモード](#graphics_mode)では、[CMASK](#cmask)がまず1ビット右にシフトされます。ピクセルがまだバイト内に収まっている場合はルーチンは終了します。そうでない場合は、[CMASK](#cmask)が左端のピクセルである80Hに設定され、[CLOC](#cloc)に0008Hが加算されます。画面の右端を超えると、誤ったアドレスが生成されることに注意が必要です。

[マルチカラーモード](#multicolour_mode)では、制御は別のルーチン([178BH](#178bh))に移行します。

<a name="16d8h"></a>

    Address... 16D8H

このルーチンは、現在のピクセルの物理アドレスを1つ左に移動します。画面の左端を超えた場合はフラグCが返され、物理アドレスは変更されません。[グラフィックスモード](#graphics_mode)では、[CMASK](#cmask)がまず1ビット左にシフトされ、ピクセルがまだバイト内に収まっている場合はルーチンが終了します。[CLOC](#cloc)が左端の文字セル(LSB=00H～07H)にある場合は、ルーチンはフラグC(175AH)で終了します。それ以外の場合は、[CMASK](#cmask)は右端のピクセルである01Hに設定され、[CLOC](#cloc)から0008Hを減算した値になります。

[マルチカラーモード](#multicolour_mode)では、制御は別のルーチン([179CH](#179ch))に転送されます。

<a name="16eeh"></a><a name="leftc"></a>

```
Address... 16EEH
Name...... LEFTC
Entry..... なし
Exit...... なし
Modifies.. AF
```

現在のピクセルの物理アドレスを1つ左に移動する標準ルーチンです。[グラフィックモード](#graphics_mode)では、まず[CMASK](#cmask)を1ビット左にシフトします。ピクセルがまだバイト内に収まっている場合はルーチンを終了します。それ以外の場合は、[CMASK](#cmask)を左端のピクセルである01Hに設定し、[CLOC](#cloc)から0008Hを減算します。画面の左端を超えると、誤ったアドレスが生成されることに注意します。

[マルチカラーモード](#multicolour_mode)では、制御は別のルーチン([17ACH](#17ach))に移行します。

<a name="170ah"></a><a name="tdownc"></a>

```
Address... 170AH
Name...... TDOWNC
Entry..... なし
Exit...... Flag C if off screen
Modifies.. AF
```

現在のピクセルの物理アドレスを1つ下に移動させる標準ルーチンです。画面の下端を超えた場合、フラグCが返され、物理アドレスは変更されません。[グラフィックモード](#graphics_mode)では、まず[CLOC](#cloc)がインクリメントされ、8バイト境界内に収まっている場合はルーチンが終了します。[CLOC](#cloc)が最下行([CLOC](#cloc)>=1700H)にある場合、ルーチンはフラグC (1759H)で終了します。それ以外の場合は、[CLOC](#cloc)に00F8Hが加算されます。

[マルチカラーモード](#multicolour_mode)では、制御は別のルーチン([17C6H](#17c6h))に転送されます。

<a name="172ah"></a><a name="downc"></a>

```
Address... 172AH
Name...... DOWNC
Entry..... なし
Exit...... なし
Modifies.. AF
```

現在のピクセルの物理アドレスを1つ下に移動させる標準ルーチンです。[グラフィックモード](#graphics_mode)では、まず[CLOC](#cloc)がインクリメントされ、8バイト境界内に収まっている場合はルーチンが終了します。そうでない場合は、[CLOC](#cloc)に00F8Hが加算されます。画面の下端を超えると、誤ったアドレスが生成されることに注意が必要です。

[マルチカラーモード](#multicolour_mode)では、制御は別のルーチン([17DCH](#17dch))に転送されます。

<a name="173ch"></a><a name="tupc"></a>

```
Address... 173CH
Name...... TUPC
Entry..... なし
Exit...... Flag C if off screen
Modifies.. AF
```

現在のピクセルの物理アドレスを1つ上に移動する標準ルーチンです。画面の上端を超えた場合、フラグCが返され、物理アドレスは変更されません。[グラフィックスモード](#graphics_mode)では、まず[CLOC](#cloc)が減算され、8バイト境界内に収まっている場合はルーチンが終了します。[CLOC](#cloc)が最上位の文字列([CLOC](#cloc)<0100H)にある場合、ルーチンはフラグCで終了します。それ以外の場合は、[CLOC](#cloc)から00F8Hが減算されます。

[マルチカラーモード](#multicolour_mode)では、制御は別のルーチン([17E3H](#17e3h))に転送されます。

<a name="175dh"></a><a name="upc"></a>

```
Address... 175DH
Name...... UPC
Entry..... なし
Exit...... なし
Modifies.. AF
```

現在のピクセルの物理アドレスを1つ上に移動する標準ルーチンです。[グラフィックモード](#graphics_mode)では、まず[CLOC](#cloc)を減算し、8バイト境界内に収まっている場合はルーチンを終了します。そうでない場合は、[CLOC](#cloc)から00F8Hを減算します。画面の上端を超えると、誤ったアドレスが生成されることに注意が必要です。

[マルチカラーモード](#multicolour_mode)では、制御は別のルーチン([17F8H](#17f8h))に転送されます。

<a name="1779h"></a>

    Address... 1779H

これは[16ACH](#16ach)のルーチンの[マルチカラーモード](#multicolour_mode)版です。[CMASK](#cmask)が4ビット右にシフトされ、セル境界を越える場合はF0Hとなる点を除けば、[グラフィックモード](#graphics_mode)版と同じです。

<a name="178bh"></a>

    Address... 178BH

これは[RIGHTC](#rightc)標準ルーチンの[マルチカラーモード](#multicolour_mode)版です。[CMASK](#cmask)が4ビット右にシフトされ、セル境界を越える場合はF0Hとなる点を除けば、[グラフィックモード](#graphics_mode)版と同じです。

<a name="179ch"></a>

    Address... 179CH

これは、[16D8H](#16d8h) のルーチンの [マルチカラーモード](#multicolour_mode) バージョンです。[CMASK](#cmask) が4ビット左にシフトされ、セル境界を越える場合は0FH になる点を除けば、[グラフィックモード](#graphics_mode) バージョンと同じです。

<a name="17ach"></a>

    Address... 17ACH

これは[LEFTC](#leftc)標準ルーチンの[マルチカラーモード](#multicolour_mode)版です。[CMASK](#cmask)が4ビット左にシフトされ、セル境界を越える場合は0FHになる点を除けば、[グラフィックモード](#graphics_mode)版と同じです。

<a name="17c6h"></a>

    Address... 17C6H

これは[TDOWNC](#tdownc)標準ルーチンの[マルチカラーモード](#multicolour_mode)版です。[グラフィックモード](#graphics_mode)版と基本的に同じですが、下限アドレスが1700Hではなく0500Hになっています。このルーチンにはバグがあり、文字パターンテーブルのベースアドレス[MLTCGP](#mltcgp)が通常の0から変更されると、予期しない動作が発生します。アドレス17CEHに`EX DE,HL`命令を挿入する必要があります。

文字パターンテーブルのベースが増加すると、ルーチンは画面の下部に到達したと認識しますが、実際には画面の下部に到達していません。このルーチンは「`PAINT`」文で使用されているため、以下の例でこのエラーが確認できます。

```
10 BASE(17)=&H1000
20 SCREEN 3
30 PSET(200,0)
40 DRAW"D180L100U180R100"
50 PAINT(150,90)
60 GOTO 60
```

</a>

<a name="17dch"></a>

    Address... 17DCH

これは、[DOWNC](#downc) 標準ルーチンの [マルチカラー モード](#multicolour_mode) バージョンであり、[グラフィック モード](#graphics_mode) バージョンと同一です。

<a name="17e3h"></a>

    Address... 17E3H

これは[TUPC](#tupc)標準ルーチンの[マルチカラーモード](#multicolour_mode)版です。[グラフィックモード](#graphics_mode)版と全く同じですが、上記のようなバグがあり、今回はアドレス17EBHに`EX DE,HL`命令が存在するはずです。

文字パターンテーブルのベースアドレスを増やすと、ルーチンは実際には画面の上端を超えているにもかかわらず、テーブル内であると認識してしまいます。これは、前のプログラムの40行目の「`R100`」の部分を削除することで確認できます。

<a name="17f8h"></a>

    Address... 17F8H

これは [UPC](#upc) 標準ルーチンの [マルチカラー モード](#multicolour_mode) バージョンであり、[グラフィック モード](#graphics_mode) バージョンと同一です。

<a name="1809h"></a><a name="nsetcx"></a>

```
Address... 1809H
Name...... NSETCX
Entry..... HL=Pixel fill count
Exit...... なし
Modifies.. AF, BC, DE, HL, EI
```

現在のピクセル物理アドレスから水平右方向の複数のピクセルの色を設定する標準ルーチンです。この機能は[SETC](#setc)および[RIGHTC](#rightc)標準ルーチンでも再現できますが、動作速度が大幅に低下します。画面の右端が渡されると異常な動作が発生するため、指定するピクセル数は画面の右端が渡らないように選択してください。このルーチンでは現在のピクセル物理アドレスは変更されません。

[グラフィックモード](#graphics_mode)では、まず[CMASK](#cmask)を調べ、現在の文字セル内の右側のピクセル数を決定します。塗りつぶし数が十分に大きいと仮定すると、これらのピクセル数は([186CH](#186ch))に設定されます。残りの塗りつぶし数を8で割ることで、文字セル全体の数を決定します。文字パターンテーブルの連続するバイトはゼロに設定され、カラーテーブルの対応するバイトが[ATRBYT](#atrbyt)から設定され、これらのセル全体が塗りつぶされます。残りの塗りつぶし数は、185DHにある7バイトのテーブルを使用してビットマスクに変換され、これらのピクセルが([186CH](#186ch))に設定されます。

[マルチカラーモード](#multicolour_mode)では、制御は別のルーチン([18BBH](#18bbh))に移行します。

<a name="186ch"></a>

    Address... 186CH

このルーチンは、[グラフィックモード](#graphicsmod)において、セル内の最大8ピクセルを指定された色に設定します。[ATRBYT](#atrbyt)には色コードが含まれ、レジスタペアHLには文字パターンテーブル内の対応するバイトのアドレスが、レジスタAにはビットマスク（例えば11100000）が含まれます。ここで、1は設定するビットを示します。

[ATRBYT](#atrbyt) が対応するカラーテーブルバイトの既存の 1 ピクセルの色と一致する場合、文字パターンテーブルバイトの各指定ビットは 1 に設定されます。[ATRBYT](#atrbyt) が対応するカラーテーブルバイトの既存の 0 ピクセルの色と一致する場合、文字パターンテーブルバイトの各指定ビットは 0 に設定されます。

[ATRBYT](#atrbyt) がカラーテーブルバイト内の既存の色のいずれにも一致しない場合、通常は文字パターンテーブルバイト内の指定された各ビットが1に設定され、カラーテーブルバイト内の1ピクセルの色が変更されます。ただし、文字パターンテーブルバイト内のすべてのビットが1に設定される場合、指定された各ビットが0に設定され、カラーテーブルバイト内の0ピクセルの色が変更されます。

<a name="18bbh"></a>

    Address... 18BBH

これは[NSETCX](#nsetcx)標準ルーチンの[マルチカラーモード](#multicolour_mode)版です。[SETC](#setc)と[RIGHTC](#rightc)標準ルーチンは、塗りつぶしカウントがなくなるまで呼び出されます。[マルチカラーモード](#multicolour_mode)では、画面解像度が低いため必要な処理回数が少なくなり、処理速度はそれほど重要ではありません。

<a name="18c7h"></a><a name="gtaspc"></a>

```
Address... 18C7H
Name...... GTASPC
Entry..... なし
Exit...... DE=ASPCT1, HL=ASPCT2
Modifies.. DE, HL
```

「`CIRCLE`」ステートメントのデフォルトのアスペクト比を返す標準ルーチン。

<a name="18cfh"></a><a name="pntini"></a>

```
Address... 18CFH
Name...... PNTINI
Entry..... A=Boundary colour (0 to 15)
Exit...... Flag C if illegal colour
Modifies.. AF
```

"`PAINT`" ステートメントの境界色を設定する標準ルーチンです。[マルチカラーモード](#multicolour_mode) では、指定されたカラーコードが [BDRATR](#bdratr) に格納されます。[グラフィックモード](#graphics_mode) では、ペイント色と境界色を別々に設定できないため、[BDRATR](#bdratr) は [ATRBYT](#atrbyt) からコピーされます。

<a name="18e4h"></a><a name="scanr"></a>

```
Address... 18E4H
Name...... SCANR
Entry..... B=Fill switch, DE=Skip count
Exit...... DE=Skip remainder, HL=Pixel count
Modifies.. AF, BC, DE, HL, EI
```

"`PAINT`" 文ハンドラが使用する標準ルーチン。現在のピクセル物理アドレスから右方向に、[BDRATR](#bdratr) に等しいカラーコードが見つかるか、画面の端に達するまで検索します。終了位置は現在のピクセル物理アドレスとなり、開始位置は [CSAVEA](#csavea) と [CSAVEM](#csavem) に返されます。走査領域のサイズはレジスタペア HL と [FILNAM](#filnam)+1 に返されます。走査領域は通常は塗りつぶされますが、[グラフィックスモード](#graphics_mode) の場合のみ、レジスタ B のエントリパラメータに 0 を設定することで、塗りつぶしを抑止できます。レジスタペア DE のスキップカウントは、最初の開始位置から無視できる必要な色のピクセルの最大数を決定します。この機能は、"`PAINT`" 文ハンドラが、上方向への移動を妨げる水平境界内のギャップを検索するために使用します。

<a name="197ah"></a><a name="scanl"></a>

```
Address... 197AH
Name...... SCANL
Entry..... なし
Exit...... HL=Pixel count
Modifies.. AF, BC, DE, HL, EI
```

現在のピクセル物理アドレスから左方向に、[BDRATR](#bdratr) に等しいカラーコードが見つかるまで、または画面の端に達するまで検索する標準ルーチンです。終了位置が現在のピクセル物理アドレスとなり、検索した領域のサイズがレジスタペアHLに返されます。検索した領域は常に塗りつぶされます。

<a name="19c7h"></a>

    Address... 19C7H

このルーチンは、[SCANL](#scanl) および [SCANR](#scanr) 標準ルーチンによって使用され、現在のピクセルの色を [BDRATR](#bdratr) の境界色と比較します。

<a name="19ddh"></a><a name="tapoof"></a>

```
Address... 19DDH
Name...... TAPOOF
Entry..... なし
Exit...... なし
Modifies.. EI
```

カセットへのデータ書き込み完了後にカセットモーターを停止する標準ルーチンです。1つの待機状態を持つMSXマシンでは、550ミリ秒の遅延の後、制御は[TAPIOF](#tapiof)標準ルーチンに移行します。

<a name="19e9h"></a><a name="tapiof"></a>

```
Address... 19E9H
Name...... TAPIOF
Entry..... なし
Exit...... なし
Modifies.. EI
```

カセットからデータを読み取った後、カセットモーターを停止する標準ルーチンです。モーターリレーは[PPIモードポート](#ppi_mode_port)を介して開きます。タイミング上の理由から、カセットデータ転送中は割り込みを無効にしておく必要がありますが、このルーチンの終了時には割り込みが有効になります。

<a name="19f1h"></a><a name="tapoon"></a>

```
Address... 19F1H
Name...... TAPOON
Entry..... A=Header length switch
Exit...... Flag C if CTRL-STOP termination
Modifies.. AF, BC, HL, DI
```

カセットモーターを起動し、テープが所定の速度に達するまで550ミリ秒待機した後、カセットにヘッダーを書き込む標準的なルーチンです。ヘッダーとは、各データブロックの先頭に書き込まれるHIサイクルのバーストであり、これによりデータを読み戻す際にボーレートを判定できます。

ヘッダーの長さはレジスタAの内容によって決まります。00H = ショートヘッダー、NZ = ロングヘッダー。BASICカセットのステートメント「`SAVE`」、「`CSAVE`」、「`BSAVE`」はすべて、ファイルの先頭、識別ブロックの前にロングヘッダーを生成し、その後、データブロック間にショートヘッダーを使用します。ヘッダーのサイクル数は、現在のボーレートによって変更され、一定の長さを維持します。

```
1200 ボー SHORT ... 3840 Cycles ... 1.5 Seconds
1200 ボー LONG ... 15360 Cycles ... 6.1 Seconds
2400 ボー SHORT ... 7936 Cycles ... 1.6 Seconds
2400 ボー LONG ... 31744 Cycles ... 6.3 Seconds
```

モーターがオンになり、遅延時間が経過すると、[HEADER](#header)の内容が256倍され、レジスタAが0でない場合はさらに4倍されてサイクルカウントが生成されます。その後、HIサイクル([1A4DH](#1a4dh))が生成され、カウントがなくなると制御は[BREAKX](#breakx)標準ルーチンに移ります。Ctrl-Stopキーは終了時にのみ確認されるため、このルーチンの途中でブレークアウトすることはできません。

<a name="1a19h"></a><a name="tapout"></a>

```
Address... 1A19H
Name...... TAPOUT
Entry..... A=Data byte
Exit...... Flag C if CTRL-STOP termination
Modifies.. AF, B, HL
```

カセットに1バイトのデータを書き込む標準ルーチン。MSX ROMは、カセットに情報を格納するためにソフトウェア駆動のFSK（周波数偏移変調）方式を採用しています。1200ボーレートでは、これはBBCがBASICODEプログラムの配布に使用したカンザスシティ規格と同一です。

1200ボーでは、各0ビットは1200HzのLOサイクル1つとして、各1ビットは2400HzのHIサイクル2つとして書き込まれます。0ビットと1ビットの持続時間は同じなので、データレートは一定です。2400ボーレートを選択した場合、2つの周波数は2400Hzと4800Hzに変わりますが、その他のフォーマットは変更されません。

1バイトのデータは、0のスタートビット（[1A50H](#1a50h)）、最下位ビットを先頭とする8つのデータビット、そして1のストップビット2つ（[1A40H](#1a40h)）で書き込まれます。1200ボーレートの場合、1バイトの公称持続時間は11 x 833 µs = 9.2 msです。ストップビットの書き込み後、制御は[BREAKX](#breakx)標準ルーチンに移行し、CTRL-STOPキーをチェックします。バイト43Hがカセットに書き込まれる様子を以下に示します。

<a name="figure39b"></a>![][CH04F39b]

**図39:** カセットデータバイト

データを書き込む際は、バイト間の間隔を長くしすぎないことが重要です。間隔が長すぎるとエラー率が上昇します。例えば、バイト間の間隔が80マイクロ秒の場合、読み取りエラー率は約12%になります。バイト間にかなりの処理が必要な場合は、バッファリングを使用してデータをヘッダー付きブロックにまとめる必要があります。BASICの「`SAVE`」形式はこのタイプです。

<a name="1a39h"></a>

    Address... 1A39H

このルーチンは、約816µsの長さを持つ単一のLOサイクルをカセットに書き込みます。サイクルの各半分の長さは[LOW](#low)から取得され、制御は汎用サイクルジェネレータ([1A50H](#1a50h))に移ります。

<a name="1a40h"></a>

    Address... 1A40H

このルーチンは、カセットに2つのHIサイクルを書き込みます。最初のサイクル（[1A4DH](#1a4dh)）が生成され、その後17µsの遅延が続き、2番目のサイクル（[1A4DH](#1a4dh)）が生成されます。

<a name="1a4dh"></a>

    Address... 1A4DH

このルーチンは、約396マイクロ秒の長さを持つ単一のHIサイクルをカセットに書き込みます。サイクルの各半分の長さは[HIGH](#high)から取得され、制御は汎用サイクルジェネレータに渡されます。

<a name="1a50h"></a>

    Address... 1A50H

このルーチンは、カセットに1サイクルを書き込みます。サイクルの前半の長さはレジスタLに、後半の長さはレジスタHに与えられます。最初の長さはカウントダウンされ、[PPIモードポート](#ppi_mode_port)を介してCas Outビットがセットされます。2番目の長さはカウントダウンされ、Cas Outビットがリセットされます。

すべてのMSXマシンにおいて、Z80は3.579545MHz（280ns）のクロック周波数で動作し、M1サイクル中に1つのウェイトステートを持ちます。このルーチンは16Tステートごとにカウントするため、長さカウントの単位増加は4.47µsの周期を表します。また、長さカウントに関わらず、このルーチンには20.7µsの固定オーバーヘッドが伴います。

<a name="1a63h"></a><a name="タピオン"></a>

```
Address... 1A63H
Name...... TAPION
Entry..... なし
Exit...... Flag C if CTRL-STOP termination
Modifies.. AF, BC, DE, HL, DI
```

カセットモーターを起動し、ヘッダーが見つかるまでカセットを読み取り、ボーレートを決定する標準ルーチンです。カセットから連続するサイクルを読み取り、各サイクルの長さを測定します([1B34H](#1b34h))。長さの変動が35µs未満のサイクルが1,111個見つかった場合、ヘッダーが見つかったことになります。

次の256サイクルが読み出され（[1B34H](#1b34h)）、平均化されてカセットのHIサイクル長が算出されます。この数値は1.5倍され、[LOWLIM](#lowlim)に格納されます。これは、0スタートビットの最小許容長を定義します。HIサイクル長は[WINWID](#winwid)に格納され、LOサイクルとHIサイクルを区別するために使用されます。

<a name="1abch"></a><a name="tapin"></a>

```
Address... 1ABCH
Name...... TAPIN
Entry..... なし
Exit...... A=Byte read, Flag C if CTRL-STOP or I/O error
Modifies.. AF, BC, DE, L
```

カセットから1バイトのデータを読み取る標準ルーチンです。まず、スタートビットが見つかるまでカセットを連続的に読み取ります。これは、負の遷移を見つけ、それに続くサイクル長([1B1FH](#1b1fh))を測定し、これが[LOWLIM](#lowlim)より大きいかどうかを比較することで行われます。

8つのデータビットそれぞれは、一定時間内の遷移回数をカウントすることで読み取られます([1B03H](#1b03h))。0または1回の遷移が見つかった場合は0ビット、2または3回の遷移が見つかった場合は1ビットとなります。4回以上の遷移が見つかった場合は、何らかのハードウェアエラーとみなされるため、ルーチンはフラグCで終了します。各ビットの値が確定した後、同期を維持するためにさらに1つまたは2つの遷移が読み取られます(1B23H)。遷移回数が奇数の場合はさらに1つ、偶数の場合はさらに2つが読み取られます。

<a name="1b03h"></a>

    Address... 1B03H

このルーチンは、[TAPIN](#tapin)標準ルーチンによって使用され、一定時間内のカセットの遷移回数をカウントします。ウィンドウの持続時間は[WINWID](#winwid)に格納されており、以下に示すように、HIサイクルの長さの約1.5倍です。

<a name="figure40"></a>![][CH04F40]

**図40:** カセットウィンドウ

Cas入力ビットはPSG [レジスタ14](#register_14) を介して継続的にサンプリングされ、レジスタEに保持されている前回の読み取り値と比較されます。状態の変化が検出されるたびに、レジスタCがインクリメントされます。サンプリングレートは17.3µsごとに1回なので、[TAPION](#tapion)標準ルーチンによって11.45µsのカウントレートで決定された[WINWID](#winwid)の値は、実質的に1.5倍になります。

<a name="1b1fh"></a>

    Address... 1B1FH

このルーチンは、次のカセット入力遷移までの時間を測定します。カセット入力ビットは、レジスタEに設定された状態から変化するまで、PSG [レジスタ14](#register_14) を介して継続的にサンプリングされます。その後、状態フラグが反転され、持続時間カウントがレジスタCに返されます。1単位のインクリメントは11.45µsの周期を表します。

<a name="1b34h"></a>

    Address... 1B34H

このルーチンは、カセットの立ち下がりから立ち下がりまでのサイクル全体の長さを測定します。カセット入力ビットは、PSG [レジスタ14](#register_14) を介して、ゼロになるまでサンプリングされます。レジスタEの遷移フラグはゼロに設定され、立ち上がりまでの時間が測定されます(1B23H)。次に、立ち下がりまでの時間が測定され(1B25H)、その合計値がレジスタCに返されます。

<a name="1b45h"></a><a name="outdo"></a>

```
Address... 1B45H
Name...... OUTDO
Entry..... A=Character to output
Exit...... なし
Modifies.. EI
```

BASICインタープリタが現在のデバイスに文字を出力するために使用する標準ルーチンです。[ISFLIO](#isflio)標準ルーチンは、まず出力が現在I/Oバッファに向けられているかどうかをチェックするために使用されます。そうである場合は、[CALBAS](#calbas)標準ルーチンを介してシーケンシャル出力ドライバ([6C48H](#6c48h))に制御が移ります。[PRTFLG](#prtflg)がゼロの場合、制御は[CHPUT](#chput)標準ルーチンに移り、文字が画面に出力されます。プリンタがアクティブであると仮定すると、[RAWPRT](#rawprt)がチェックされます。これがゼロでない場合、文字はプリンタ([1BABH](#1babh))に直接渡され、そうでない場合は[OUTDLP](#outdlp)標準ルーチンに制御が移ります。

<a name="1b63h"></a><a name="outdlp"></a>

```
Address... 1B63H
Name...... OUTDLP
Entry..... A=Character to output
Exit...... なし
Modifies.. EI
```

プリンタに文字を出力する標準ルーチンです。文字がTABコード（09H）の場合、[OUTDLP](#outdlp)標準ルーチンにスペースが発行され、[LPTPOS](#lptpos)が8の倍数（0、8、16など）になるまで処理が続けられます。文字がCRコード（0DH）の場合、[LPTPOS](#lptpos)はゼロに設定されます。その他の制御コードの場合は[LPTPOS](#lptpos)は影響を受けませんが、表示可能な文字の場合は[LPTPOS](#lptpos)がインクリメントされます。

[NTMSXP](#ntmsxp) がゼロの場合、つまりMSX専用プリンタが接続されている場合は、文字は直接プリンタに渡されます ([1BABH](#1babh))。通常のプリンタが接続されている場合は、[CNVCHR](#cnvchr) 標準ルーチンを使用してグラフィック文字の有無を確認します。文字がヘッダーコード (01H) の場合、ルーチンは何もせずに終了します。変換されたグラフィック文字の場合は、スペースに置き換えられ、それ以外の文字はプリンタに渡されます (1BACH)。

<a name="1b97h"></a>

    Address... 1B97H

この 20 バイトのテーブルは、キーボード デコーダーによって、指定されたキー番号の正しいルーチンを見つけるために使用されます。

|KEY NUMBER  |TO     |FUNCTION
|------------|:-----:|------------------
|00H to 2FH  |0F83H  |Rows 0 to 5
|30H to 32H  |0F10H  |SHIFT, CTRL, GRAPH
|33H         |0F36H  |CAP
|34H         |0F10H  |CODE
|35H to 39H  |0FC3H  |F1 to F5
|3AH to 3BH  |0F10H  |ESC, TAB
|3CH         |0F46H  |STOP
|3DH to 40H  |0F10H  |BS, CR, SEL, SPACE
|41H         |0F06H  |HOME
|42H to 57H  |0F10H  |INS, DEL, CURSOR

</a>

<a name="1babh"></a>

    Address... 1BABH

このルーチンは、[OUTDLP](#outdlp)標準ルーチンによってプリンタに文字を渡すために使用されます。この文字は[LPTOUT](#lptout)標準ルーチンを介して送信され、フラグCが返された場合は、[CALBAS](#calbas)標準ルーチンを介して「`デバイスI/Oエラー`」ジェネレータ([73B2H](#73b2h))に制御が移ります。

<a name="1bbfh"></a>

    Address... 1BBFH

続く2KBには、電源投入時の文字セットが含まれます。最初の8バイトには文字コード00Hのパターンが、次の8バイトには文字コード01Hのパターンが含まれ、以下同様に文字コードFFHまで続きます。

<a name="23bfh"></a><a name="pinlin"></a>

```
Address... 23BFH
Name...... PINLIN
Entry..... なし
Exit...... HL=Start of text, Flag C if CTRL-STOP termination
Modifies.. AF, BC, DE, HL, EI
```

BASICインタープリタのメインループがコンソールから論理行のテキストを収集するために使用する標準ルーチンです。前の行が切り取られた位置（23E0H）の直後で、制御は[INLIN](#inlin)標準ルーチンに移ります。

<a name="23cch"></a><a name="qinlin"></a>

```
Address... 23CCH
Name...... QINLIN
Entry..... なし
Exit...... HL=Start of text, Flag C if CTRL-STOP termination
Modifies.. AF, BC, DE, HL, EI
```

"`INPUT`" ステートメントハンドラがコンソールから論理テキスト行を収集するために使用する標準ルーチンです。文字列 "`? `" は [OUTDO](#outdo) 標準ルーチンによって表示され、制御は [INLIN](#inlin) 標準ルーチンに渡されます。

<a name="23d5h"></a><a name="inlin"></a>

```
Address... 23D5H
Name...... INLIN
Entry..... なし
Exit...... HL=Start of text, Flag C if CTRL-STOP termination
Modifies.. AF, BC, DE, HL, EI
```

"`LINE INPUT`" ステートメントハンドラがコンソールから論理行テキストを収集するために使用する標準ルーチンです。キーボードから文字が読み取られ、CR キーまたは Ctrl-Stop キーが押されるまで読み取られます。その後、論理行は画面から文字ごとに読み取られ、ワークスペース領域のテキストバッファ [BUF](#buf) に格納されます。

現在の画面座標はまず[CSRX](#csrx)と[CSRY](#csry)から取得され、[FSTPOS](#fstpos)に格納されます。次に、現在の画面行のすぐ上の行のエントリを[LINTTB](#linttb)に非ゼロ([0C29H](#0c29h))に設定し、論理的に現在の行に拡張されないようにします。

[CHGET](#chget) 標準ルーチンで読み取られた各キーボード文字は、[2439H](#2439h) の編集キーテーブルと照合され(0919H)、その後、制御は編集ルーチンの1つ、または適切なデフォルトのキーハンドラ([23FFH](#23ffh))に移ります。このプロセスは、CTRL-STOPルーチンまたはCRルーチンによってフラグCが返されるまで継続されます。その後、レジスタペアHLが[BUF](#buf)の先頭を指すように設定され、ルーチンは終了します。CRまたは保護されたCTRL-STOP終了と通常のCTRL-STOP終了を区別するために、フラグNZが返されたときにキャリーフラグもクリアされることに注意してください。

<a name="23ffh"></a>

    Address... 23FFH

このルーチンは、[INLIN](#inlin)標準ルーチンの特殊編集キーを除くすべての文字を処理します。文字がTABコード(09H)の場合、[CSRX](#csrx)が8の倍数+1(1、9、17、25、33桁目)になるまで、スペース([23FFH](#23ffh))が発行されます。文字がグラフィックヘッダーコード(01H)の場合、そのまま[OUTDO](#outdo)標準ルーチンにエコーされます。20H未満のその他の制御コードは[OUTDO](#outdo)標準ルーチンにエコーされ、その後[INSFLG](#insflg)と[CSTYLE](#cstyle)が0に設定されます。表示可能な文字については、まず [INSFLG](#insflg) がチェックされ、該当する場合はスペースが挿入されて ([24F2H](#24f2h))、その後文字が [OUTDO](#outdo) 標準ルーチンにエコーされます。

<a name="2439h"></a>

    Address... 2439H

この表には、[INLIN](#inlin) 標準ルーチンによって認識される特殊編集キーと関連するアドレスが含まれています。

|CODE |TO    |FUNCTION
|:---:|:----:|----------------------------
|08H  |2561H |BS、バックスペース
|12H  |24E5H |INS、挿入モードの切り替え
|1BH  |23FEH |ESC、アクションなし
|02H  |260EH |CTRL-B、前の単語
|06H  |25F8H |CTRL-F、次の単語
|0EH  |25D7H |CTRL-N、論理行の終了
|05H  |25B9H |CTRL-E、行末までクリア
|03H  |24C5H |CTRL-STOP、終了
|0DH  |245AH |CR、終了
|15H  |25AEH |CTRL-U、クリアライン
|7FH  |2550H |DEL、文字を削除

</a>

<a name="245ah"></a>

    Address... 245AH

このルーチンは、[INLIN](#inlin) 標準ルーチンの CR 操作を実行します。論理行の開始座標が検索され ([266CH](#266ch))、カーソルが画面から削除されます ([0A2EH](#0a2eh))。次に、最大 254 文字が VDP VRAM ([0BD8H](#0bd8h)) から読み取られ、[BUF](#buf) に格納されます。ヌル コード (00H) はすべて無視され、20H 未満の文字はグラフィック ヘッダー コード (01H) と、その文字自体に 40H が加算された値に置き換えられます。各物理行の末尾に達すると、[LINTTB](#linttb) がチェックされ ([0C1DH](#0c1dh))、論理行が次の物理行にまたがっているかどうかが確認されます。その後、末尾のスペースが [BUF](#buf) から削除され、テキスト終了マーカーとしてゼロ バイトが追加されます。カーソルは画面に復元され ([09E1H](#09e1h))、その座標は[POSIT](#posit)標準ルーチンによって論理行の最後の物理行に設定されます。[OUTDO](#outdo)標準ルーチンにLFコードが発行され、[INSFLG](#insflg)がゼロにリセットされ、ルーチンはレジスタAとフラグNZ,CにCRコード(0DH)を出力して終了します。このCRコードは、[INLIN](#inlin)標準ルーチンのメインループによって終了直前に画面に出力されます。

<a name="24c5h"></a>

    Address... 24C5H

このルーチンは、[INLIN](#inlin)標準ルーチンのCTRL-STOP操作を実行します。論理行の最後の物理行は[LINTTB](#linttb) ([0C1DH](#0c1dh)) を調べることで見つけられ、[CSTYLE](#cstyle) はゼロにされ、[BUF](#buf) の先頭にゼロバイトが配置され、[GICINI](#gicini)標準ルーチンによってすべての音楽変数がクリアされます。次に、[TRPTBL](#trptbl) (0454H) を調べて「`ON STOP`」ステートメントがアクティブかどうかを確認します。アクティブであれば、カーソルがリセットされ (24AFH)、ルーチンはフラグNZ,Cで終了します。次に、[BASROM](#basrom) を調べて保護されたROMが実行中かどうかを確認します。アクティブであれば、カーソルがリセットされ (24AFH)、ルーチンはフラグNZ,Cで終了します。それ以外の場合、カーソルはリセットされ (24B2H)、ルーチンはフラグ Z、C で終了します。

<a name="24e5h"></a>

    Address... 24E5H

このルーチンは、[INLIN](#inlin)標準ルーチンのINS演算を実行します。[INSFLG](#insflg)の現在の状態を反転し、[CSTYLE](#cstyle)設定ルーチン(242CH)を介して制御を終了します。

<a name="24f2h"></a>

    Address... 24F2H

このルーチンは、[INLIN](#inlin) 標準ルーチンのデフォルトキーセクションにスペース文字を挿入します。カーソルは削除され ([0A2EH](#0a2eh))、現在のカーソル座標が [CSRX](#csrx) と [CSRY](#csry) から取得されます。この位置の文字は VDP VRAM ([0BD8H](#0bd8h)) から読み出され、スペース ([0BE6H](#0be6h)) に置き換えられます。その後、物理行の末尾に達するまで、後続の文字が1列ずつ右にコピーされます。

この時点で [LINTTB](#linttb) が検査され ([0C1DH](#0c1dh))、論理行が拡張されているかどうかが判断され、拡張されている場合、プロセスは次の物理行に進みます。拡張されていない場合は、最後の列位置から取得された文字が検査され、これがスペースである場合、ルーチンはカーソルを置き換えて終了します ([09E1H](#09e1h))。そうでない場合は、[LINTTB](#linttb) の物理行のエントリがゼロに設定され、拡張された論理行が示されます。次の物理行の番号が画面上の行数と比較されます ([0C32H](#0c32h))。次の行が最後の行である場合は画面が上にスクロールされ (0A88H)、そうでない場合は空白行が挿入され (0AB7H)、コピー プロセスが続行されます。

<a name="2550h"></a>

    Address... 2550H

このルーチンは、[INLIN](#inlin)標準ルーチンのDEL操作を実行します。現在のカーソル位置が右端の列にあり、論理行が拡張されていない場合は、VDP VRAM (2595H) にスペースを書き込む以外は何も行いません。それ以外の場合は、[OUTDO](#outdo)標準ルーチンにRIGHTコード(1CH)が発行され、制御はBSルーチンに移ります。

<a name="2561h"></a>

    Address... 2561H

このルーチンは、[INLIN](#inlin)標準ルーチンのBS操作を実行します。まずカーソルが削除され([0A2EH](#0a2eh))、カーソルの列座標が減算されます。ただし、カーソルが左端にあり、前の行が拡張されていない場合に限ります。次に、VDP VRAM([0BD8H](#0bd8h))から文字が読み出され、論理行の末尾に達するまで、1つ左に書き戻されます([0BE6H](#0be6h))。論理行の末尾に達した時点で、VDP VRAM([0BE6H](#0be6h))にスペースが書き込まれ、カーソル文字が復元されます([09E1H](#09e1h))。

<a name="25aeh"></a>

    Address... 25AEH

このルーチンは、[INLIN](#inlin)標準ルーチンのCTRL-U操作を実行します。カーソルは削除され([0A2EH](#0a2eh))、論理行の先頭([266CH](#266ch))が[CSRX](#csrx)と[CSRY](#csry)に格納されます。その後、論理行全体がクリアされます(25BEH)。

<a name="25b9h"></a>

    Address... 25B9H

このルーチンは、[INLIN](#inlin) 標準ルーチンの CTRL-E 操作を実行します。カーソルは削除され ([0A2EH](#0a2eh))、物理行の残りはクリアされます ([0AEEH](#0aeeh))。このプロセスは、[LINTBB](#lintbb) で論理行の末尾が見つかるまで ([0C1DH](#0c1dh))、次の物理行に対して繰り返されます。その後、カーソルは復元され ([09E1H](#09e1h))、[INSFLG](#insflg) がゼロに設定され、[CSTLYE](#cstlye) がブロックカーソルにリセットされます (242DH)。

<a name="25d7h"></a>

    Address... 25D7H

このルーチンは、[INLIN](#inlin)標準ルーチンのCTRL-N操作を実行します。カーソルは削除され([0A2EH](#0a2eh))、[LINTTB](#linttb)の検査によって論理行の最後の物理行が特定されます([0C1DH](#0c1dh))。この物理行の右端の列から、VDP VRAM([0BD8H](#0bd8h))から文字が読み取られ、スペース以外の文字が見つかるまで読み取られます。カーソル座標は、この位置の1列右に設定され([0A5BH](#0a5bh))、ルーチンはカーソルを復元して終了します(25CDH)。

<a name="25f8h"></a>

    Address... 25F8H

このルーチンは、[INLIN](#inlin) 標準ルーチンの CTRL-F 操作を実行します。カーソルは削除され ([0A2EH](#0a2eh))、英数字以外の文字が見つかるまで右に連続的に移動されます ([2624H](#2624h))。その後、カーソルは英数字が見つかるまで右に連続的に移動されます ([2624H](#2624h))。ルーチンはカーソルを復元して終了します (25CDH)。

<a name="260eh"></a>

    Address... 260EH

このルーチンは、[INLIN](#inlin) 標準ルーチンの CTRL-B 操作を実行します。カーソルは削除され ([0A2EH](#0a2eh))、英数字が見つかるまで左に連続移動します ([2634H](#2634h))。次に、カーソルは英数字以外の文字が見つかるまで左に連続移動し ([2634H](#2634h))、次に右に1つ移動します ([0A5BH](#0a5bh))。ルーチンはカーソルを復元して終了します (25CDH)。

<a name="2624h"></a>

    Address... 2624H

このルーチンはカーソルを 1 つ右に移動し ([0A5BH](#0a5bh))、レジスタ D に右端の列番号をロードし、レジスタ E に最下行番号をロードして、カーソル位置 (263DH) の英数字をテストします。

<a name="2634h"></a>

    Address... 2634H

このルーチンはカーソルを1つ左に移動し ([0A4CH](#0a4ch))、レジスタDに左端の列番号、レジスタEに最上行番号をロードします。現在のカーソル座標とこれらの値を比較し、カーソルがこの位置にある場合はフラグZを終了します。そうでない場合は、この位置の文字をVDP VRAM ([0BD8H](#0bd8h)) から読み取り、それが英数字かどうかを確認します。英数字の場合はフラグNZ,Cを終了し、そうでない場合はフラグNZ,NCを終了します。

英数字は「0」から「9」までの数字と「A」から「Z」および「a」から「z」までの文字です。また、86Hから9FHおよびA6HからFFHまでのグラフィック文字も含まれますが、これらは元々日本語の文字であり、UK ROMへの変換時に除外されるべきでした。

<a name="266ch"></a>

    Address... 266CH

このルーチンは論理行の開始位置を見つけ、その画面座標をレジスタ ペア HL に返します。現在の行より上の各物理行は [LINTTB](#linttb) テーブル ([0C1DH](#0c1dh)) によってチェックされ、拡張されていない行が見つかるまで検索されます。画面上でこの行のすぐ下の行が論理行の開始位置となり、その行番号がレジスタ L に格納されます。次に、この行番号が [FSTPOS](#fstpos) と比較されます。[FSTPOS](#fstpos) には [INLIN](#inlin) 標準ルーチンが最初に実行されたときの行番号が格納されており、カーソルがまだ同じ行にあるかどうかが確認されます。同じ行にある場合、レジスタ H の列座標が [FSTPOS](#fstpos) からの初期位置に設定されます。それ以外の場合、レジスタ H は行全体を返すために左端の位置に設定されます。

<a name="2680h"></a>
<a name="2683h"></a>
<a name="2686h"></a>
<a name="2689h"></a>

```
アドレス...2680H、電源投入初期化ルーチン (7C76H) へのJP。
アドレス...2683H、SYNCHR標準ルーチン(558CH)へのJP。
アドレス...2686H、CHRGTR標準ルーチン(4666H)へのJP。
アドレス...2689H、GETYPR標準ルーチン(5597H)へのJP。
```

<br><br><br>

<a name="chapter_5"></a>

# 5. ROM BASICインタープリター

Microsoft BASICは長年にわたり進化を続け、現在では業界標準となっています。元々は8080マイクロプロセッサ用に開発され、MSX版でさえ8080アセンブリ言語形式で提供されています。この継続的な開発プロセスにより、Z80固有の命令は、より現代的なプログラムに期待されるものよりも少なくなっています。また、多くの変更が加えられた結果、プログラムはやや複雑になっています。インタプリタの構造上、アプリケーションプログラムがその多くの機能を利用することは困難です。しかし、ほとんどのプログラムはある程度インタプリタと連携する必要があるため、本章ではその動作について詳しく説明します。

インタプリタには4つの重要な領域があり、その中でも最も馴染み深いのはメインループ([4134H](#4134h))です。メインループは、コンソールから番号付きのテキスト行を収集し、直接命令文を受信するまでメモリのプログラムテキスト領域に順番に配置します。

実行ループ ([4601H](#4601h)) はプログラムの実行を担います。各プログラム行の最初のトークンを調べ、適切なルーチンを呼び出して残りの文を処理します。この処理は、プログラムテキストがなくなるまで続けられ、その後制御はメインループに戻ります。

ステートメント内の数値または文字列オペランドの分析は、Expression Evaluator ([4C64H](#4c64h)) によって実行されます。各式は複数の要素で構成され、要素はFactor Evaluator ([4DC7H](#4dc7h)) によって分析され、要素は二項演算子で連結されます。Microsoft BASIC では、行番号など、式の一部として使用できないオペランドの種類が複数あるため、「評価済み」という用語は、式の一部として使用できるオペランドを指す場合にのみ使用されます。それ以外の場合は、「計算済み」などの用語が使用されます。

インタプリタを詳細に調べる際に注目すべき点の一つは、多くのトリックコードが含まれていることです。開発者は、ルーチンへの複数のエントリポイントを提供するために、命令の途中にジャンプするのを特に好んでいるようです。例えば、次の命令を考えてみましょう。

    3E D1 通常: LD A,0D1H

通常の方法でこの命令に遭遇した場合、もちろんアキュムレータにD1Hの値がロードされます。ただし、「通常」モードで実行された場合は、「POP DE」命令として実行されます。インタープリタには、同様に分かりにくいセクションが多数あります。

<a name="268ch"></a>

    Address... 268CH

このルーチンは、Expression Evaluatorによって2つの倍精度オペランドを減算するために使用されます。最初のオペランドは[DAC](#dac)に格納され、2番目のオペランドは[ARG](#arg)に格納され、結果は[DAC](#dac)に返されます。2番目のオペランドの仮数部の符号は反転され、制御は加算ルーチンに移ります。

<a name="269ah"></a>

    Address... 269AH

このルーチンは、Expression Evaluatorによって2つの倍精度オペランドを加算するために使用されます。最初のオペランドは[DAC](#dac)に格納され、2番目のオペランドは[ARG](#arg)に格納され、結果は[DAC](#dac)に返されます。2番目のオペランドがゼロの場合、ルーチンは何もせずに終了します。最初のオペランドがゼロの場合、2番目のオペランドは[DAC](#dac) ([2F05H](#2f05h))にコピーされ、ルーチンは終了します。2つの指数が比較され、その差が10の15乗を超える場合、ルーチンは大きい方のオペランドを結果として終了させます。それ以外の場合、2つの指数の差に基づいて小さい方の仮数を右にシフトします([27A3H](#27a3h))。例:

```
19.2100 = .1921*10^2 = .192100
+ .7436 = .7436*10^0 = .007436
```

2つの仮数部符号が等しい場合は仮数を加算し([2759H](#2759h))、異なる場合は仮数を減算します([276BH](#276bh))。結果の指数は、元の2つの指数のうち大きい方になります。加算によってオーバーフローが発生した場合、結果の仮数は1桁右にシフトされ(27DBH)、指数が増分されます。減算によって先頭にゼロが発生した場合は、結果の仮数は左にシフトすることで正規化されます([2797H](#2797h))。次にガードバイトが検査され、15桁目が5以上の場合は結果が切り上げられます。

<a name="2759h"></a>

    Address... 2759H

このルーチンは、[DAC](#dac) と [ARG](#arg) に含まれる2つの倍精度仮数を加算し、結果を [DAC](#dac) に返します。加算は最下位桁の [DAC](#dac)+7 と [ARG](#arg)+7 から開始され、7バイトにわたって2桁ずつ加算が行われます。

<a name="276bh"></a>

    Address... 276BH

このルーチンは、[DAC](#dac) と [ARG](#arg) に含まれる2つの倍精度仮数部を減算し、結果を [DAC](#dac) に返します。減算はガードバイト [DAC](#dac)+8 と [ARG](#arg)+8 から開始され、8バイトにわたって2桁ずつ減算が行われます。結果がアンダーフローした場合は、ゼロから減算し、仮数部の符号を反転することで修正されます。例:

    0.17-0.85 = 0.32 = -0.68

</a>

<a name="2797h"></a>

    Address... 2797H

このルーチンは、[DAC](#dac) に含まれる倍精度仮数を 1 桁左にシフトします。

<a name="27a3h"></a>

    Address... 27A3H

このルーチンは倍精度仮数を右にシフトします。シフトする桁数はレジスタAに、仮数の最上位バイトのアドレスはレジスタペアHLに与えられます。まず、桁数を2で割ってバイト数と桁数を分離します。次に、必要なバイト数を右にシフトし、最上位バイトをゼロにします。桁数が奇数の場合、仮数部はさらに1桁右にシフトされます。

<a name="27e6h"></a>

    Address... 27E6H

このルーチンは、Expression Evaluatorによって2つの倍精度オペランドを乗算するために使用されます。最初のオペランドは[DAC](#dac)に格納され、2番目のオペランドは[ARG](#arg)に格納され、結果は[DAC](#dac)に返されます。どちらかのオペランドがゼロの場合、ルーチンはゼロの結果([2E7DH](#2e7dh))で終了します。それ以外の場合は、2つの指数を加算して結果の指数を生成します。この指数が10^-63より小さい場合、ルーチンはゼロの結果で終了します。10^63より大きい場合は、「オーバーフローエラー」が発生します([4067H](#4067h))。次に、2つの仮数部の符号が処理され、結果の符号が算出されます。仮数部の符号が同じ場合は正、異なる場合は負になります。

仮数はBCD形式ですが、通常の2進加算とシフト方式を用いて乗算されます。これを実現するために、第1オペランドは2倍([288AH](#288ah))され、[HOLD8](#hold8)バッファに定数X\*80、X\*40、X\*20、X\*10、X\*8、X\*4、X\*2、Xが生成されます。第2オペランドは[ARG](#arg)に保持され、[DAC](#dac)は積アキュムレータとして機能するためゼロに設定されます。乗算は、第2オペランドの最下位桁から順に桁を取り出すことで行われます。桁の1ビットごとに、第1オペランドの適切な倍数が積に加算されます。例えば、1823\*96という単一の乗算は、以下の結果を生成します。

    1823*10010110=(1823*80)+(1823*10)+(1823*4)+(1823*2)

各桁のペアの処理が完了すると、積は2桁右にシフトされます。7桁のペアの処理がすべて完了すると、ルーチンは積を再正規化し、切り上げを行って終了します（26FAH）。

乗算にかかる時間は、第2オペランドの1のビット数に大きく依存します。最悪のケースでは、すべての桁が7の場合、平均約7ミリ秒に対して最大11ミリ秒かかることがあります。

<a name="288ah"></a>

    Address... 288AH

このルーチンは、倍精度仮数を3回連続して倍精度化し、積X\*2、X\*4、およびX\*8を生成します。仮数部の最下位バイトのアドレスはレジスタペアDEに与えられます。積はオペランドの直下から順に下位のアドレスに格納されます。

<a name="289fh"></a>

    Address... 289FH

このルーチンは、Expression Evaluatorによって2つの倍精度オペランドの除算に使用されます。第1オペランドは[DAC](#dac)に格納され、第2オペランドは[ARG](#arg)に格納され、結果は[DAC](#dac)に返されます。第1オペランドがゼロの場合、ルーチンはゼロの結果で終了します。第2オペランドがゼロの場合、「ゼロ除算」エラー([4058H](#4058h))が生成されます。それ以外の場合、2つの指数を減算して結果の指数を算出し、2つの仮数符号を処理して結果の符号を算出します。2つの仮数符号が同じ場合、結果は正、異なる場合、結果は負になります。

仮数部の除算は通常の長除算法を用いて行われます。第2オペランドは第1オペランドからアンダーフローが発生するまで繰り返し減算され、結果の1桁目が生成されます。その後、第2オペランドが加算されて剰余（2761H）が復元され、その桁は[HOLD](#hold)に格納され、第1オペランドは1桁左にシフトされます。第1オペランドのシフトアウトが完了すると、結果は[HOLD](#hold)から[DAC](#dac)にコピーされ、正規化されて切り上げられます（2883H）。第1オペランドの大部分が9で、第2オペランドの大部分が1の場合、除算にかかる時間は最大約25ミリ秒に達します。この場合は、減算回数が最も多くなります。

<a name="2993h"></a>

    Address... 2993H

このルーチンは、Factor Evaluatorによって使用され、[DAC](#dac) に含まれる倍精度オペランドに「`COS`」関数を適用します。オペランドはまず([2C3BH](#2c3bh))、1/(2\*PI) で乗算されます。これにより、1 は完全な 360 度サイクルに相当します。次に、オペランドから 0.25 (90 度) が減算され([2C32H](#2c32h))、仮数部の符号が反転され(2E8DH)、制御は「`SIN`」ルーチンに移ります。

<a name="29ach"></a>

    Address... 29ACH

このルーチンは、Factor Evaluatorによって使用され、[DAC](#dac) に含まれる倍精度オペランドに「`SIN`」関数を適用します。オペランドはまず ([2C3BH](#2c3bh)) に 1/(2\*PI) を乗算し、1 が完全な 360 度サイクルに対応するようにします。関数は周期的であるため、ここではオペランドの小数部のみが必要です。小数部は、オペランド ([2CCCH](#2ccch)) をプッシュして整数部 ([30CFH](#30cfh)) を取得し、それを [ARG](#arg) ([2C4DH](#2c4dh)) にコピーし、オペランド全体を [DAC](#dac) ([2CE1H](#2ce1h)) にポップし、整数部 ([268CH](#268ch)) を減算することで抽出されます。

次に仮数部の最初の桁を調べて、オペランドの象限を決定します。第 1 象限にある場合は変更しません。第 2 象限にある場合は、Y 軸を中心にして 0.5 (180 度) から減算します。第 3 象限にある場合は、X 軸を中心にして 0.5 (180 度) から減算します。第 4 象限にある場合は、両方の軸を中心にして 1.0 (360 度) を減算します。次に、2DEFH の係数リストを使用して、多項式近似 ([2C88H](#2c88h)) によって関数を計算します。これらはテイラー級数 X-(X^3/3!)+(X^5/5!)-(X^7/7!) ... の最初の 8 つの項であり、係数には初期スケーリングを補正するために 2\*PI の連続する因数が乗算されます。

<a name="29fbh"></a>

    Address... 29FBH

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれる倍精度オペランドに「`TAN`」関数を適用するために用いられます。この関数は、三角関数の恒等式TAN(X) = SIN(X)/COS(X)を用いて計算されます。

<a name="2a14h"></a>

    Address... 2A14H

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれる倍精度オペランドに「`ATN`」関数を適用するために使用されます。この関数は、2E30Hにある係数リストを用いて多項式近似([2C88H](#2c88h))によって計算されます。これらはテイラー級数X-(X^3/3)+(X^5/5)-(X^7/7)…の最初の8項であり、級数を縮小するために係数がわずかに変更されています。

<a name="2a72h"></a>

    Address... 2A72H

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれる倍精度オペランドに「`LOG`」関数を適用するために使用されます。この関数は、2DA5Hにある係数リストを用いて多項式近似によって計算されます。

<a name="2affh"></a>

    Address... 2AFFH

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれる倍精度オペランドに「`SQR`」関数を適用するために用いられます。この関数はニュートン・ラプソン法を用いて計算されます。同等のBASICプログラムは以下のとおりです。

```
10 INPUT"NUMBER";X
20 GUESS=10
30 FOR N=1 To 7
40 GUESS=(GUESS+X/GUESS)/2
50 NEXT N
60 PRINT GUESS
70 PRINT SQR(X)
```

上記のプログラムは固定の初期推定値を使用しています。この初期推定値は限られた範囲では正確ですが、最大精度は初期推定値が根に近い場合にのみ達成されます。ROMが使用する方法は、指数を半分に切り上げ、オペランドの最初の2桁を4で割って最初の桁をインクリメントするというものです。

<a name="2b4ah"></a>

    Address... 2B4AH

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれる倍精度オペランドに「`EXP`」関数を適用するために用いられます。オペランドはまず0.4342944819（10進数のLOG(e)）で乗算されるため、問題はe^Xではなく10^Xを計算することになります。これにより整数部の処理が容易になり、計算が大幅に簡素化されます。次に、2D6BHにある係数リストを用いて多項式近似によって関数が計算されます。

<a name="2bdfh"></a>

    Address... 2BDFH

このルーチンは、Factor Evaluatorによって使用され、[DAC](#dac) に含まれる倍精度オペランドに「`RND`」関数を適用します。オペランドがゼロの場合、現在の乱数が [RNDX](#rndx) から [DAC](#dac) にコピーされ、ルーチンは終了します。オペランドが負の場合、[RNDX](#rndx) にコピーされ、現在の乱数が設定されます。新しい乱数は、[RNDX](#rndx) を [HOLD](#hold) に、2CF9H の定数を [ARG](#arg) に、2CF1H の定数を [DAC](#dac) にコピーし、(282EH) を乗算することで生成されます。倍精度乗算された積の下位14桁が [RNDX](#rndx) にコピーされ、新しい乱数の仮数部が生成されます。 [DAC](#dac) の指数バイトは 10^0 に設定され、0 から 1 の範囲の値を返します。

<a name="2c24h"></a>

    Address... 2C24H

このルーチンは、「`NEW`」、「`CLEAR`」、および「`RUN`」ステートメント ハンドラーによって使用され、[RNDX](#rndx) を 2D01H の定数で初期化します。

<a name="2c2ch"></a>

    Address... 2C2CH

このルーチンは、レジスタペアHLにアドレスが指定された定数を[DAC](#dac)に含まれる倍精度オペランドに追加します。

<a name="2c32h"></a>

    Address... 2C32H

このルーチンは、レジスタペアHLにアドレスが指定されている定数を[DAC](#dac)に含まれる倍精度オペランドから減算します。

<a name="2c3bh"></a>

    Address... 2C3BH

このルーチンは、[DAC](#dac) に含まれる倍精度オペランドを、レジスタ ペア HL にアドレスが指定されている定数で乗算します。

<a name="2c41h"></a>

    Address... 2C41H

このルーチンは、[DAC](#dac) に含まれる倍精度オペランドを、レジスタ ペア HL にアドレスが指定されている定数で除算します。

<a name="2c47h"></a>

    Address... 2C47H

このルーチンは、[DAC](#dac) に含まれる倍精度オペランドとレジスタペア HL にアドレスが指定されている定数との関係演算を実行します。

<a name="2c4dh"></a>

    Address... 2C4DH
このルーチンは、8 バイトの倍精度オペランドを [DAC](#dac) から [ARG](#arg) にコピーします。

<a name="2c59h"></a>

    Address... 2C59H

このルーチンは、8 バイトの倍精度オペランドを [ARG](#arg) から [DAC](#dac) にコピーします。

<a name="2c6fh"></a>

    Address... 2C6FH

このルーチンは、[DAC](#dac) 内の 8 バイトを、現在 Z80 スタックの一番下にある 8 バイトと交換します。

<a name="2c80h"></a>

    Address... 2C80H

このルーチンは、[DAC](#dac) (2E8DH) に含まれるオペランドの仮数部の符号を反転します。その後、呼び出し元が終了した際に符号を復元するため、同じアドレスがスタックにプッシュされます。

<a name="2c88h"></a>

    Address... 2C88H

このルーチンは、[DAC](#dac) に含まれる倍精度オペランドに基づいて奇数級数を生成します。この級数は次のような形式になります。

    X^1*(Kn)+X^3*(Kn-1)+x^5*(Kn-2)+X^5*(Kn-3)...

係数リストのアドレスはレジスタペアHLで与えられます。リストの最初のバイトには係数のカウントが含まれ、倍精度係数はK1からKnまで続きます。偶数列が生成され([2C9AH](#2c9ah))、元のオペランドに乗算されます([27E6H](#27e6h))。

<a name="2c9ah"></a>

    Address... 2C9AH

このルーチンは、[DAC](#dac) に含まれる倍精度オペランドに基づいて偶数級数を生成します。級数は次のような形式になります。

    X^0*(Kn)+x^2*(Kn-1)+x^4*(Kn-2)+x^6*(Kn-3) ...

係数リストのアドレスはレジスタペアHLで与えられます。リストの最初のバイトには係数の数が含まれ、倍精度係数はK1からKnまで続きます。この多項式の計算法はホーナー法として知られています。この方法では項ごとに1回の乗算と1回の加算のみが必要です。BASICでは以下のようになります。

```
10 X=X*X
20 PRODUCT=0
30 RESTORE 100
40 READ COUNT
50 FOR N=1 TO COUNT
60 READ K
70 PRODUCT= ( PRODUCT*X ) +K
80 NEXT N
90 END
100 DATA 8
110 DATA Kn-7
120 DATA Kn-6
130 DATA Kn-5
140 DATA Kn-4
150 DATA Kn-3
160 DATA Kn-2
170 DATA Kn-1
180 DATA Kn
```

多項式は最後の係数から最初の係数まで処理されるため、部分積を使用して不要な演算を省略できます。

<a name="2cc7h"></a>

    Address... 2CC7H

このルーチンは、[ARG](#arg) から 8 バイトの倍精度オペランドを Z80 スタックにプッシュします。

<a name="2ccch"></a>

    Address... 2CCCH

このルーチンは、[DAC](#dac) から 8 バイトの倍精度オペランドを Z80 スタックにプッシュします。

<a name="2cdch"></a>

    Address... 2CDCH

このルーチンは、8 バイトの倍精度オペランドを Z80 スタックから [ARG](#arg) にポップします。

<a name="2ce1h"></a>

    Address... 2CE1H

このルーチンは、8 バイトの倍精度オペランドを Z80 スタックから [DAC](#dac) にポップします。

<a name="2cf1h"></a>

    Address... 2CF1H

この表には、数学ルーチンで使用される倍精度定数が含まれています。最初の3つの定数は、乱数ジェネレータで使用される特殊な中間形式であるため、指数部がゼロになっています。

|ADDRESS|CONSTANT           |           |ADDRESS|CONSTANT           |   |
|-------|-------------------|-----------|-------|-------------------|---|
|2CF1H  |.14389820420821    |RND        |2DAEH  |6.2503651127908    |   |
|2CF9H  |.21132486540519    |RND        |2DB6H  |-13.682370241503   |   |
|2D01H  |.40649651372358    |           |2DBEH  |8.5167319872389    |   |
|2D09H  |.43429448190324    |LOG(e)     |2DC6H  |5                  |LOG|
|2D11H  |.50000000000000    |           |2DC7H  |1.0000000000000    |   |
|2D13H  |.00000000000000    |           |2DCFH  |-13.210478350156   |   |
|2D1BH  |1.0000000000000    |           |2DD7H  |47.925256043873    |   |
|2D23H  |.25000000000000    |           |2DDFH  |-64.906682740943   |   |
|2D2BH  |3.1622776601684    |SQR(10)    |2DE7H  |29.415750172323    |   |
|2D33H  |.86858896380650    |2^LOG(e)   |2DEFH  |8                  |SIN|
|2D3BH  |2.3025850929940    |1/LOG(e)   |2DF0H  |-.69215692291809   |   |
|2D43H  |1.5707963267949    |PI/2       |2DF8H  | 3.8172886385771   |   |
|2D4BH  |.26794919243112    |TAN(PI/12) |2E00H  |-15.094499474801   |   |
|2D53H  |1.7320508075689    |TAN(PI/3)  |2E08H  | 42.058689667355   |   |
|2D5BH  |.52359877559830    |PI/6       |2E10H  |-76.705859683291   |   |
|2D63H  |.15915494309190    |1/(2^PI)   |2E18H  | 81.605249275513   |   |
|2D6BH  |4                  |EXP        |2E20H  |-41.341702240398   |   |
|2D6CH  |1.0000000000000    |           |2E28H  | 6.2831853071796   |   |
|2D74H  |159.37415236031    |           |2E30H  |8                  |ATN|
|2D7CH  |2709.3169408516    |           |2E31H  |-.05208693904000   |   |
|2D84H  |4497.6335574058    |           |2E39H  |.07530714913480    |   |
|2D8CH  |3                  |EXP        |2E41H  |-.09081343224705   |   |
|2D8DH  |18.312360159275    |           |2E49H  |.11110794184029    |   |
|2D95H  |831.40672129371    |           |2E51H  |-.14285708554884   |   |
|2D9DH  |5178.0919915162    |           |2E59H  |.19999999948967    |   |
|2DA5H  |4                  |LOG        |2E61H  |-.33333333333160   |   |
|2DA6H  |-.71433382153226   |           |2E69H  |1.0000000000000    |   |

</a>

<a name="2e71h"></a>

    Address... 2E71H

このルーチンは、[DAC](#dac) に含まれる浮動小数点オペランドの仮数部の符号を返します。指数バイトがテストされ、結果がレジスタAと以下のフラグに返されます。

```
ゼロ ..... A=00H、フラグZ、NC
正 ....... A=01H、フラグNZ、NC
負 ....... A=FFH、フラグNZ、C
```

</a>

<a name="2e7dh"></a>

    Address... 2E7DH

このルーチンは、[DAC](#dac) の指数バイトを単にゼロにします。

<a name="2e82h"></a>

    Address... 2E82H

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`ABS`」関数を適用するために使用されます。まずオペランドの符号がチェックされ([2EA1H](#2ea1h))、正であればルーチンは終了します。次に、オペランドの型が[GETYPR](#getypr)標準ルーチンによってチェックされます。文字列の場合、「`Type mismatch`」エラーが生成されます([406DH](#406dh))。整数の場合、符号が反転されます([322BH](#322bh))。倍精度または単精度オペランドの場合、[DAC](#dac)の仮数部符号ビットが反転されます。

<a name="2e97h"></a>

    Address... 2E97H

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`SGN`」関数を適用するために用いられます。オペランドの符号はチェックされ([2EA1H](#2ea1h))、レジスタペアHLに拡張された後、整数として[DAC](#dac)に格納されます。

```
ゼロ ..... 0000H
正 ....... 0001H
負 ....... FFFFH
```

</a>

<a name="2ea1h"></a>

    Address... 2EA1H

このルーチンは、[DAC](#dac) に含まれるオペランドの符号を返します。オペランドの型は、まず [GETYPR](#getypr) 標準ルーチンによってチェックされます。文字列の場合、「`Type mismatch`」エラーが生成されます ([406DH](#406dh))。単精度または倍精度オペランドの場合、仮数部の符号が調べられます ([2E71H](#2e71h))。整数の場合、その値は [DAC](#dac)+2 から取得され、[2E71H](#2e71h) に示されるフラグに変換されます。

<a name="2eb1h"></a>

    Address... 2EB1H

このルーチンは、[DAC](#dac) から 4 バイトの単精度オペランドを Z80 スタックにプッシュします。

<a name="2ec1h"></a>

    Address... 2EC1H

このルーチンは、レジスタ C、B、E、D の内容を [DAC](#dac) にコピーします。

<a name="2ecch"></a>

    Address... 2ECCH

このルーチンは、[DAC](#dac) の内容をレジスタ C、B、E、D にコピーします。

<a name="2ed6h"></a>

    Address... 2ED6H

このルーチンは、レジスタ ペア HL で指定されたアドレスから始まり、上向きの連続位置からレジスタ C、B、E、および D をロードします。

<a name="2edfh"></a>

    Address... 2EDFH

このルーチンは、レジスタ ペア HL で指定されたアドレスから始まり、上向きの連続位置からレジスタ E、D、C、および B をロードします。

<a name="2ee8h"></a>

    Address... 2EE8H

このルーチンは、[DAC](#dac) からの単精度オペランドをレジスタペア HL に指定されたアドレスにコピーします。

<a name="2eefh"></a>

    Address... 2EEFH

このルーチンは、レジスタペアHLに指定されたアドレスから任意のオペランドを[ARG](#arg)にコピーします。オペランドの長さは[VALTYP](#valtyp)に格納されます。2=整数、3=文字列、4=単精度、8=倍精度です。

<a name="2f05h"></a>

    Address... 2F05H

このルーチンは、任意のオペランドを[ARG](#arg)から[DAC](#dac)にコピーします。オペランドの長さは[VALTYP](#valtyp)に格納されます。2=整数、3=文字列、4=単精度、8=倍精度です。

<a name="2f0dh"></a>

    Address... 2F0DH

このルーチンは、任意のオペランドを[DAC](#dac)から[ARG](#arg)にコピーします。オペランドの長さは[VALTYP](#valtyp)に格納されます：2=整数、3=文字列、4=単精度、8=倍精度。

<a name="2f21h"></a>

    Address... 2F21H

このルーチンは、Expression Evaluatorによって、2つの単精度オペランドの関係 (<>=) を求めるために使用されます。最初のオペランドはレジスタC、B、E、Dに格納され、2番目のオペランドは[DAC](#dac)に格納されます。結果はレジスタAに返され、以下のフラグが設定されます。

```
オペランド1 = オペランド2 ... A=00H、フラグZ、NC
オペランド1 < オペランド2 ... A=01H、フラグNZ、NC
オペランド1 > オペランド2 ... A=FFH、フラグNZ、C
```

関係演算子の場合、式評価子は最大の負の数は小さいとみなし、最大の正の数は大きいとみなすことに注意してください。

<a name="2f4dh"></a>

    Address... 2F4DH

このルーチンは、Expression Evaluatorによって2つの整数オペランドの関係 (<>=) を求めるために使用されます。第1オペランドはレジスタペアDEに格納され、第2オペランドはレジスタペアHLに格納されます。結果は単精度版 ([2F21H](#2f21h)) と同じです。

<a name="2f83h"></a>

    Address... 2F83H

このルーチンは、Expression Evaluatorによって、2つの倍精度オペランド間の関係 (<>=) を求めるために使用されます。最初のオペランドは [DAC](#dac) に格納され、2番目のオペランドは [ARG](#arg) に格納されます。結果は単精度バージョン ([2F21H](#2f21h)) と同じです。

<a name="2f8ah"></a>

    Address... 2F8AH

このルーチンは、Factor Evaluatorによって使用され、[DAC](#dac) に含まれるオペランドに「`CINT`」関数を適用します。オペランドの型はまず [GETYPR](#getypr) 標準ルーチンによってチェックされ、既に整数型の場合はルーチンが終了します。文字列型の場合は、「`Type mismatch`」エラー ([406DH](#406dh)) が生成されます。単精度または倍精度オペランドの場合は、レジスタペア DE ([305DH](#305dh)) で符号付き2進整数に変換され、その後 [DAC](#dac) に整数として格納されます。範囲外の値は「`Overflow`」エラー ([4067H](#4067h)) となります。

<a name="2fa2h"></a>

    Address... 2FA2H

このルーチンは、[DAC](#dac) に単精度オペランド -32768 が含まれているかどうかを確認し、含まれている場合はそれを整数値 8000H に置き換えます。この処理は、数値入力変換 ([3299H](#3299h)) 中に必須です。これは、整数範囲が非対称であるためです。

<a name="2fb2h"></a>

    Address... 2FB2H

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`CSNG`」関数を適用するために使用されます。オペランドの型はまず[GETYPR](#getypr)標準ルーチンによってチェックされ、既に単精度である場合はルーチンは終了します。オペランドが文字列の場合、「`Type mismatch`」エラーが発生します([406DH](#406dh))。倍精度の場合、[VALTYP](#valtyp)が変更され(3053H)、仮数が7桁目から切り上げられます(2741H)。オペランドが整数の場合、定数10000、1000、100、10、1を用いて連続的に除算することにより、2進数から最大5桁のBCDに変換されます。これらの定数は[DAC](#dac)に格納され、単精度仮数部を形成します。指数は仮数部の有効桁数に等しくなります。例えば、有効桁数が5の場合、指数は10の5乗になります。

<a name="3030h"></a>

    Address... 3030H

この表には、「`CSNG`」ルーチンで使用される5つの定数が含まれています: -10000、-1000、-100、-10、-1

<a name="303ah"></a>

    Address... 303AH

このルーチンは、Factor Evaluatorによって使用され、[DAC](#dac) に含まれるオペランドに「`CDBL`」関数を適用します。オペランドの型はまず [GETYPR](#getypr) 標準ルーチンによってチェックされ、既に倍精度である場合はルーチンは終了します。文字列の場合は「`Type mismatch`」エラー ([406DH](#406dh)) が生成されます。整数の場合は、まず単精度 (2FC8H) に変換され、最下位8桁がゼロにされ、[VALTYP](#valtyp) が8に設定されます。

<a name="3058h"></a>

    Address... 3058H

このルーチンは、現在のオペランドが文字列型であるかどうかをチェックし、そうでない場合は「`Type mismatch`」エラーが生成されます ([406DH](#406dh))。

<a name="305dh"></a>

    Address... 305DH

このルーチンは、「`CINT`」ルーチン ([2F8AH](#2f8ah)) によって使用され、BCD 単精度または倍精度オペランドをレジスタペア DE の符号付き2進整数に変換します。オーバーフローが発生した場合はフラグ C を返します。仮数部から連続する桁が取得され、最上位桁から順に積に加算されます。各加算の後、積は10倍されます。処理する桁数は指数によって決まります。例えば、指数が10^5 の場合、5桁の桁が取得されます。最後に仮数部の符号がチェックされ、必要に応じて積の符号が反転されます (3221H)。

<a name="30beh"></a>

    Address... 30BEH

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`FIX`」関数を適用するために使用されます。オペランドの型はまず[GETYPR](#getypr)標準ルーチンによってチェックされ、整数の場合、ルーチンはそのまま終了します。次に仮数部の符号がチェックされ([2E71H](#2e71h))、正の場合、「`INT`」ルーチン([30CFH](#30cfh))に制御が移ります。それ以外の場合は、符号を正に反転し、「`INT`」関数([30CFH](#30cfh))を実行して、符号を負に戻します。

<a name="30cfh"></a>

    Address... 30CFH

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`INT`」関数を適用するために使用されます。オペランドの型はまず[GETYPR](#getypr)標準ルーチンによってチェックされ、整数であればルーチンはそのまま終了します。小数部の桁数は、型の桁数から指数を減算することで決定されます。単精度の場合は6、倍精度の場合は14です。

仮数部符号が正の場合、これらの小数桁は単にゼロに設定されます。仮数部符号が負の場合、各小数桁はゼロに設定される前に検査されます。すべての桁がゼロであった場合、ルーチンは単に終了します。それ以外の場合は、単精度加算ルーチン ([324EH](#324eh)) または倍精度加算ルーチン ([269AH](#269ah)) によって、オペランドに -1.0 が加算されます。オペランドの型は通常、"`CINT`" 関数によって変更されないことに注意してください。

<a name="314ah"></a>

    Address... 314AH

このルーチンは、レジスタペアBCとDEの符号なし2進整数を乗算し、結果をレジスタペアDEに返します。標準的なシフト加算法が使用され、積は2倍され、レジスタペアDEの1ビットごとにレジスタペアBCの値が加算されます。このルーチンは、変数検索ルーチン([5EA4H](#5ea4h))によって配列内の要素の位置を計算するために使用されます。オーバーフローが発生した場合は、「`添字が範囲外`」エラー(601DH)が生成されます。

<a name="3167h"></a>

    Address... 3167H

このルーチンは、Expression Evaluatorによって2つの整数オペランドを減算するために使用されます。第1オペランドはレジスタペアDEに格納され、第2オペランドはレジスタペアHLに格納され、結果は[DAC](#dac)に返されます。第2オペランドは反転され(3221H)、制御は加算ルーチンに移ります。

<a name="3172h"></a>

    Address... 3172H

このルーチンは、Expression Evaluatorによって2つの整数オペランドを加算するために使用されます。最初のオペランドはレジスタペアDEに格納され、2番目のオペランドはレジスタペアHLに格納され、結果は[DAC](#dac)に返されます。符号付きバイナリオペランドは通常、加算されて[DAC](#dac)に格納されます。ただし、オーバーフローが発生した場合、両方のオペランドは単精度(2FCBH)に変換され、制御は単精度加算器([324EH](#324eh))に移されます。オーバーフローは、両方のオペランドが同じ符号で、結果が逆符号になる場合に発生します。例:

    30000+15000=-20536

</a>

<a name="3193h"></a>

    Address... 3193H

このルーチンは、Expression Evaluatorが 2 つの整数オペランドを乗算するために使用されます。最初のオペランドはレジスタ ペア DE に、2 番目のオペランドはレジスタ ペア HL に格納され、結果は [DAC](#dac) に返されます。2 つのオペランドの符号は一時的に保存され、両方のオペランドが正になります ([3215H](#3215h))。乗算は、標準のバイナリ シフトおよび加算方式を使用して続行され、レジスタ ペア HL が積アキュムレータとして、レジスタ ペア BC に最初のオペランドが、レジスタ ペア DE に 2 番目のオペランドが格納されます。乗算中に積が 7FFFH を超える場合はいつでも、両方のオペランドが単精度 (2FCBH) に変換され、制御が単精度乗算器 ([325CH](#325ch)) に移されます。それ以外の場合は、最初の符号が復元され、異なる場合は、積が否定されてから整数 (321DH) として [DAC](#dac) に格納されます。

<a name="31e6h"></a>

    Address... 31E6H

このルーチンは、Expression Evaluatorによって2つの整数オペランドの整数除算 (\) に使用されます。第1オペランドはレジスタペアDEに、第2オペランドはレジスタペアHLに格納され、結果は[DAC](#dac) に返されます。第2オペランドがゼロの場合、「`ゼロ除算`」エラーが生成されます ([4058H](#4058h))。それ以外の場合、2つのオペランドの符号は保存され、両方のオペランドが正になります ([3215H](#3215h))。除算は標準的な2進シフト減算方式で行われ、レジスタペアHLに剰余、レジスタペアBCに第2オペランド、レジスタペアDEに第1オペランドと積が格納されます。除算が完了すると、最初の符号が復元され、異なる場合は積が反転されて整数 (321DH) として[DAC](#dac) に格納されます。

<a name="3215h"></a>

    Address... 3215H

このルーチンは、レジスタペアHLとDEに格納されている2つの符号付き2進整数を正に変換します。最初のオペランドの符号は、レジスタBのビット7にフラグとして返されます。0=同じ、1=異なる。次に、各オペランドが検査され、負の場合は0から減算して正に変換されます。

<a name="322bh"></a>

    Address... 322BH

このルーチンは「`ABS`」関数によって使用され、[DAC](#dac) に含まれる負の整数を正に変換します。オペランドは [DAC](#dac) から取得され、符号反転された後、[DAC](#dac) (3221H) に戻されます。オペランドの値が 8000H の場合、+32768 の整数は存在しないため、単精度 (2FCCH) に変換されます。

<a name="323ah"></a>

    Address... 323AH

このルーチンは、Expression Evaluatorによって2つの整数オペランドを「MOD」するために使用されます。第1オペランドはレジスタペアDEに格納され、第2オペランドはレジスタペアHLに格納され、結果は[DAC](#dac)に返されます。第1オペランドの符号は保存され、2つのオペランドは除算されます([31E6H](#31e6h))。除算処理によって2倍された剰余が返されるため、レジスタペアDEは1つ右にシフトされ、剰余が復元されます。次に、第1オペランドの符号が復元され、剰余が負の場合は符号反転されて整数(321DH)として[DAC](#dac)に格納されます。

<a name="324eh"></a>

    Address... 324EH

このルーチンは、Expression Evaluatorによって2つの単精度オペランドを加算するために使用されます。第1オペランドはレジスタC、B、E、Dに格納され、第2オペランドは[DAC](#dac)に格納され、結果は[DAC](#dac)に返されます。第1オペランドは[ARG](#arg) ([3280H](#3280h))にコピーされ、第2オペランドは倍精度(3042H)に変換され、制御は倍精度加算器([269AH](#269ah))に移されます。

<a name="3257h"></a>

    Address... 3257H

このルーチンは、Expression Evaluatorによって2つの単精度オペランドの減算に使用されます。第1オペランドはレジスタC、B、E、Dに格納され、第2オペランドは[DAC](#dac)に格納されます。結果は[DAC](#dac)に返されます。第2オペランドは反転(2E8DH)され、制御は単精度加算器([324EH](#324eh))に移されます。

<a name="325ch"></a>

    Address... 325CH

このルーチンは、Expression Evaluatorによって2つの単精度オペランドの乗算に使用されます。第1オペランドはレジスタC、B、E、Dに格納され、第2オペランドは[DAC](#dac)に格納され、結果は[DAC](#dac)に返されます。第1オペランドは[ARG](#arg) ([3280H](#3280h)) にコピーされ、第2オペランドは倍精度(3042H)に変換され、制御は倍精度乗算器([27E6H](#27e6h)) に移されます。

<a name="3265h"></a>

    Address... 3265H

このルーチンは、Expression Evaluatorによって2つの単精度オペランドの除算に使用されます。第1オペランドはレジスタC、B、E、Dに格納され、第2オペランドは[DAC](#dac)に格納され、結果は[DAC](#dac)に返されます。第1オペランドと第2オペランドは交換され、第1オペランドは[DAC](#dac)に格納され、第2オペランドはレジスタに格納されます。次に、第2オペランドは[ARG](#arg) ([3280H](#3280h)) にコピーされ、第1オペランドは倍精度(3042H)に変換され、制御は倍精度除算器([289FH](#289fh)) に移されます。

<a name="3280h"></a>

    Address... 3280H

このルーチンは、レジスタ C、B、E、および D に含まれる単精度オペランドを [ARG](#arg) にコピーし、最下位 4 バイトをゼロにします。

<a name="3299h"></a>

    Address... 3299H

このルーチンは、テキスト形式の数値を標準の内部数値型のいずれかに変換します。この型はトークン化時、および「`VAL`」、「`INPUT`」、「`READ`」ステートメントハンドラで使用されます。入力レジスタペアHLは、変換対象となるテキスト文字列の最初の文字を指します。出力レジスタペアHLは、文字列の次の文字を指します。数値オペランドは[DAC](#dac)に格納され、型コードは[VALTYP](#valtyp)に格納されます。3つの型の例は、以下のとおりです。

<a name="figure41"></a>![][CH05F41]

**図41:** DACの数値型

整数は2の補数形式の16ビット2進数で、LSBを先頭にMSBを2番目に[DAC](#dac)+2に格納されます。整数の範囲は8000H (-32768) から 7FFFH (+32767) です。

浮動小数点数は、指数バイトと 3 バイトまたは 7 バイトの仮数部で構成されます。指数は符号付き 2 進数形式で保持され、01H (-63) から 40H (0)、最大 7FH (+63) までの範囲になります。00H は特別な値で、数値のゼロを表します。これらの指数値は、正規化された仮数部です。インタープリタは、指数形式の数値を先頭の桁と共にユーザに提示します。これにより、E-64 から E+62 までの非対称な指数範囲が生じます。指数バイトのビット 7 は仮数部の符号 (0 が正、1 が負) を保持します。仮数部自体は、1 バイトあたり 2 桁のパック BCD 形式で保持されます。インタープリタは、数値自体の形式ではなく、[VALTYP](#valtyp) の内容を使用して数値のタイプを判別することに注意してください。

変換は、テキストの最初の文字を調べることから始まります。これが「&」の場合、制御は特別な基数変換ルーチン ([4EB8H](#4eb8h)) に移り、先頭の符号文字の場合は一時的に保存されます。その後、連続する数値文字が取り出され、整数積に加算されます。新しい桁が見つかるたびに、適切な10倍の値が乗算されます。積の値が32767を超える場合、または小数点が見つかった場合、積は単精度に変換され、それ以降の文字は直接[DAC](#dac)に格納されます。7桁目が見つかった場合、積は倍精度に変換されます。14桁を超える場合、超過分の桁は読み取られますが無視されます。

数値以外の文字が見つかると、変換は停止します。これが型定義文字（"%"、"#"、または"!"）の場合、適切な変換ルーチンが呼び出され、制御は終了点（331EH）に移ります。これが指数接頭辞（"E"、"e"、"D"、または"d"）の場合、変換ルーチンのいずれかが使用され、その後、後続の桁がレジスタEの2進指数に変換されます。終了点（331EH）では、[GETYPR](#getypr)標準ルーチンによって積の型がチェックされます。単精度または倍精度の場合、指数は、まずレジスタBの小数桁数をレジスタDの総桁数から減算して先頭桁数を算出することで計算されます。次に、この先頭桁数がレジスタEに明示的に指定された指数に加算され、[DAC](#dac)+0に指数として格納されます。

先頭の符号文字が復元され、必要に応じて積の符号が反転されます (2E86H)。積が整数の場合、ルーチンは終了します。積が単精度の場合、制御は特殊値 -32768 ([2FA2H](#2fa2h)) をチェックして終了します。積が倍精度の場合、制御は15桁目から切り上げを行って終了します (273CH)。

<a name="340ah"></a>

    Address... 340AH

このルーチンはエラーハンドラによって使用され、メッセージ「 in 」（[6678H](#6678h)）と、それに続いてレジスタペアHL（[3412H](#3412h)）に指定された行番号を表示します。

<a name="3412h"></a>

    Address... 3412H

このルーチンは、レジスタペアHLに与えられた符号なし2進整数を表示します。オペランドは整数（2F99H）として[DAC](#dac)に格納され、テキスト（3441H）に変換されてから表示されます（6677H）。

<a name="3425h"></a>

    Address... 3425H

このルーチンは、[DAC](#dac) に格納されている数値オペランドを [FBUFFR](#fbuffr) に格納されるテキスト形式に変換します。変換後のテキストの先頭文字のアドレスはレジスタペア HL に返され、テキストはゼロバイトで終端されます。オペランドはまず倍精度 ([375FH](#375fh)) に変換されます。次に仮数部の BCD 桁が展開され、ASCII に変換されて [FBUFFR](#fbuffr) (36B3H) に格納されます。小数点の位置は指数によって決まります。例:

```
.999*10 ^ +2 = 99.9
.999*10 ^ +1 = 9.99
.999*10 ^ +0 = .999
.999*10 ^ -1 = .0999
```

指数が10^-1から10^14の範囲外の場合、数値は指数形式で表されます。この場合、小数点は最初の桁の後に置かれ、指数は2進数から変換され、仮数の後に続きます。

ルーチンへの別のエントリポイントは、3426Hに「`PRINT USING`」ステートメントハンドラ用に存在します。このエントリポイントでは、小数点の先頭文字数をレジスタBに、小数点を固定する文字数をレジスタCに、フォーマットバイトをレジスタAに指定します。

<a name="figure42"></a>![][CH05F42]

**図42:** フォーマットバイト

このモードでの動作は通常モードとほぼ同じですが、追加機能が追加されています。オペランドが倍精度に変換されると、フォーマットバイトのビット0が設定されている場合は指数形式が想定されます。仮数は[DAC](#dac)で右シフトされ、不要な接尾辞桁([377BH](#377bh))を削除するために切り上げられます。仮数がASCII (36B3H)に変換される際に、フォーマットバイトのビット6が設定されている場合は、適切な位置にカンマが挿入されます。変換後のフォーマット(351CH)では、ビット5が設定されている場合は未使用の接頭辞位置にアスタリスクが挿入され、ビット4を設定することでポンド記号の接頭辞を追加できます。ビット3が設定されている場合は正の数に「+」記号が有効になり、設定されていない場合はスペースが使用されます。ビット2は、リセットされている場合は任意の符号を先頭に、設定されている場合は末尾に配置します。

ルーチンへのエントリポイント3441Hは、符号なし整数、特に行番号をテキスト形式に変換するために使用されます。例えば、9000Hは通常の整数として扱われると-28672に変換されます。このエントリポイントを使用すると、代わりに36864が生成されます。オペランドは、10000、1000、100、10、1を因数とする逐次除算によって変換され、結果の数字は[FBUFFR](#fbuffr) (36DBH)に格納されます。

<a name="3710h"></a>

    Address... 3710H

この表には、数値出力ルーチンで使用される 5 つの定数 (10000、1000、100、10、1) が含まれています。

<a name="371ah"></a>

    Address... 371AH

このルーチンは、「`BIN`$」関数によって、[DAC](#dac)に含まれる数値オペランドをテキスト形式に変換するために使用されます。レジスタBにグループサイズ（1）がロードされ、制御は汎用変換ルーチン（3724H）に移ります。

<a name="371eh"></a>

    Address... 371EH

このルーチンは「`OCT`$」関数によって使用され、[DAC](#dac)に含まれる数値オペランドをテキスト形式に変換します。レジスタBにグループサイズ（3）がロードされ、制御は汎用変換ルーチン（3724H）に移ります。

<a name="3722h"></a>

    Address... 3722H

このルーチンは、「`HEX`$」関数によって、[DAC](#dac) に含まれる数値オペランドをテキスト形式に変換するために使用されます。レジスタBにはグループサイズ (4) がロードされ、オペランドはレジスタペア HL ([5439H](#5439h)) に2進整数に変換されます。1、3、または4ビットの連続するグループはオペランドから右にシフトされ、ASCII 数字に変換されて [FBUFFR](#fbuffr) に格納されます。オペランドがすべてゼロの場合、ルーチンはレジスタペア HL の最初のテキスト文字のアドレスで終了し、文字列はゼロバイトで終了します。

<a name="3752h"></a>

    Address... 3752H

このルーチンは数値出力時に使用され、オペランドの桁数をレジスタBに、最下位バイトのアドレスをレジスタペアHLに返します。単精度の場合、B=6、HL=[DAC](#dac)+3、倍精度の場合、B=14、HL=[DAC](#dac)+7となります。

<a name="375fh"></a>

    Address... 375FH

このルーチンは数値出力時に使用され、[DAC](#dac) 内の数値オペランドを倍精度 ([303AH](#303ah)) に変換します。

<a name="377bh"></a>

    Address... 377BH

このルーチンは数値出力中に [DAC](#dac) の仮数を右 (27DBH) にシフトするために使用されます。桁数の逆数はレジスタ A に供給されます。結果は 15 桁目 (2741H) から切り上げられます。

<a name="37a2h"></a>

    Address... 37A2H

このルーチンは数値出力時に使用され、浮動小数点オペランドの小数点以下の桁数の逆数を返します。これは、オペランドの桁数（6または14）から指数部を減算することで計算されます。

<a name="37b4h"></a>

    Address... 37B4H

このルーチンは数値出力時に、[DAC](#dac)に含まれる仮数部の最後の非ゼロ桁を見つけるために使用されます。そのアドレスはレジスタペアHLに返されます。

<a name="37c8h"></a>

    Address... 37C8H

このルーチンは、Expression Evaluatorによって2つの単精度オペランドの累乗(^)を求めるために使用されます。第1オペランドはレジスタC、B、E、Dに格納され、第2オペランドは[DAC](#dac)に格納され、結果は[DAC](#dac)に返されます。第1オペランドは[ARG](#arg) ([3280H](#3280h))にコピーされ、スタック([2CC7H](#2cc7h))にプッシュされ、[DAC](#dac) ([2C6FH](#2c6fh))と交換されます。第2オペランドは[ARG](#arg)にポップされ、倍精度指数演算ルーチンに制御が移ります。

<a name="37d7h"></a>

    Address... 37D7H

このルーチンは、Expression Evaluatorによって2つの倍精度オペランドの指数(^)を求めるために使用されます。最初のオペランドは[DAC](#dac)に格納され、2番目のオペランドは[ARG](#arg)に格納され、結果は[DAC](#dac)に返されます。結果は通常、以下の式で計算されます。

    X^P=EXP(P*LOG(X))

べき乗オペランドが整数の場合、より高速な代替手法が利用可能です。これは、オペランドの整数部分を抽出し、元の値 ([391AH](#391ah)) と等しいかどうかを比較することで判定されます。この判定結果が肯定的であれば、より高速な手法が使用可能であることを意味します。この手法については後述します。

<a name="383fh"></a>

    Address... 383FH

このルーチンは、Expression Evaluatorによって2つの整数オペランドのべき乗(^)を求めるために使用されます。最初のオペランドはレジスタペアDEに格納され、2番目のオペランドはレジスタペアHLに格納され、結果は[DAC](#dac)に返されます。このルーチンは、問題を単純な乗算に分解して処理を行います。

    6^13=6^1101=(6^8)*(6^4)*(6^1)

べき乗オペランドは2進数形式であるため、特定の中間積を結果に含める必要があるかどうかを判断するには、単純な右シフトで十分です。中間積自体は、計算ループを通過するたびにオペランドの累積乗算によって得られます。積がオーバーフローした場合は、単精度に変換されます。計算が完了すると、べき乗オペランドがチェックされ、負の場合は積がX^-P=1/X^Pとして逆数化されます。

<a name="390dh"></a>

    Address... 390DH

このルーチンは指数計算中に2つの整数を乗算するために使用されます([3193H](#3193h))。結果が単精度にオーバーフローした場合はフラグNZを返します。

<a name="391ah"></a>

    Address... 391AH

このルーチンは、指数計算中に倍精度の累乗オペランドが整数部分のみで構成されているかどうかを確認するために使用され、そうである場合はフラグ NC を返します。

<a name="392eh"></a>

    Address... 392EH

このアドレステーブルは、インタープリタのランループが文トークンのハンドラを見つけるために使用されます。テーブルには含まれていませんが、関連するキーワードは以下に記載されています。

|TO     |STATEMENT  |TO     |SATEMENT   |TO     |STMT   |
|-------|-----------|-------|-----------|-------|-------|
|63EAH  |END        |00C3H  |CLS        |5B11H  |CIRCLE |
|4524H  |FOR        |51C9H  |WIDTH      |7980H  |COLOR  |
|6527H  |NEXT       |485DH  |ELSE       |5D6EH  |DRAW   |
|485BH  |DATA       |6438H  |TRON       |59C5H  |PAINT  |
|4B6CH  |INPUT      |6439H  |TROFF      |00C0H  |BEEP   |
|5E9FH  |DIM        |643EH  |SWAP       |73E5H  |PLAY   |
|4B9FH  |READ       |6477H  |ERASE      |57EAH  |PSET   |
|4880H  |LET        |49AAH  |ERROR      |57E5H  |PRESET |
|47E8H  |GOTO       |495DH  |RESUME     |73CAH  |SOUND  |
|479EH  |RUN        |53E2H  |DELETE     |79CCH  |SCREEN |
|49E5H  |IF         |49B5H  |AUTO       |7BE2H  |VPOKE  |
|63C9H  |RESTORE    |5468H  |RENUM      |7A48H  |SPRITE |
|47B2H  |GOSUB      |4718H  |DEFSTR     |7B37H  |VDP    |
|4821H  |RETURN     |471BH  |DEFINT     |7B5AH  |BASE   |
|485DH  |REM        |471EH  |DEFSNG     |55A8H  |CALL   |
|63E3H  |STOP       |4721H  |DEFDBL     |7911H  |TIME   |
|4A24H  |PRINT      |4B0EH  |LINE       |786CH  |KEY    |
|64AFH  |CLEAR      |6AB7H  |OPEN       |7E4BH  |MAX    |
|522EH  |LIST       |7C52H  |FIELD      |73B7H  |MOTOR  |
|6286H  |NEW        |775BH  |GET        |6EC6H  |BLOAD  |
|48E4H  |ON         |7758H  |PUT        |6E92H  |BSAVE  |
|401CH  |WAIT       |6C14H  |CLOSE      |7C16H  |DSKO$  |
|501DH  |DEF        |6B5DH  |LOAD       |7C1BH  |SET    |
|5423H  |POKE       |6B5EH  |MERGE      |7C20H  |NAME   |
|6424H  |CONT       |6C2FH  |FILES      |7C25H  |KILL   |
|6FB7H  |CSAVE      |7C48H  |LSET       |7C2AH  |IPL    |
|703FH  |CLOAD      |7C4DH  |RSET       |7C2FH  |COPY   |
|4016H  |OUT        |6BA3H  |SAVE       |7C34H  |CMD    |
|4A1DH  |LPRINT     |6C2AH  |LFILES     |7766H  |LOCATE |
|5229H  |LLIST      |       |           |       |       |

<a name="39deh"></a>

    Address... 39DEH

このアドレステーブルは、Factor Evaluatorが関数トークンのハンドラーを見つけるために使用されます。このテーブルには含まれていませんが、関連するキーワードは以下に示すアドレスに含まれています。

|TO     |FUNCTION   |TO     |FUNCTION   |TO     |FUNCTION   |
|-------|-----------|-------|-----------|-------|-----------|
|6861H  |LEFT$      |4FCCH  |POS        |30BEH  |FIX        |
|6891H  |RIGHT$     |67FFH  |LEN        |7940H  |STICK      |
|689AH  |MID$       |6604H  |TR$        |794CH  |TRIG       |
|2E97H  |SGN        |68BBH  |VAL        |795AH  |PDL        |
|30CFH  |INT        |680BH  |ASC        |7969H  |PAD        |
|2E82H  |ABS        |681BH  |CHR$       |7C39H  |DSKF       |
|2AFFH  |SQR        |541CH  |PEEK       |6D39H  |FPOS       |
|2BDFH  |RND        |7BF5H  |VPEEK      |7C66H  |CVI        |
|29ACH  |SIN        |6848H  |SPACE$     |7C6BH  |CVS        |
|2A72H  |LOG        |7C70H  |OCT$       |7C70H  |CVD        |
|2B4AH  |EXP        |65FAH  |HEX$       |6D25H  |EOF        |
|2993H  |COS        |4FC7H  |LPOS       |6D03H  |LOC        |
|29FBH  |TAN        |6FFFH  |BIN$       |6D14H  |LOF        |
|2A14H  |ATN        |2F8AH  |CINT       |7C57H  |MKI$       |
|69F2H  |FRE        |2FB2H  |CSNG       |7C5CH  |MKS$       |
|4001H  |INP        |303AH  |CDBL       |7C61H  |MKD$       |

<a name="3a3eh"></a>

    Address... 3A3EH

このアドレステーブルは、プログラムのトークン化の際に、BASICキーワードテーブル([3A72H](#3a72h))へのインデックスとして使用されます。26個のエントリそれぞれが、キーワードサブブロックの開始アドレスを定義します。最初のエントリは文字「A」で始まるキーワードを指し、2番目のエントリは文字「B」で始まるキーワードを指し、以下同様に続きます。

```
3A72H ... A   3B9FH ... J    3C8EH ... S
3A88H ... B   3BA0H ... K    3CDBH ... T
3A9FH ... C   3BA8H ... L    3CF6H ... U
3AF3H ... D   3BE8H ... M    3CFFH ... V
3B2EH ... E   3C09H ... N    3D16H ... W
3B4FH ... F   3C18H ... O    3D20H ... X
3B69H ... G   3C2BH ... P    3D24H ... Y
3B7BH ... H   3C5DH ... Q    3D25H ... Z
3B80H ... I   3C5EH ... R
```

<a name="3a72h"></a>

    Address... 3A72H

このテーブルには、BASICのキーワードとトークンが含まれています。テーブル内の26個のブロックにはそれぞれ、特定の文字で始まるすべてのキーワードが含まれており、ゼロバイトで終端されています。各キーワードはプレーンテキストで保存され、ビット7が最後の文字を示すように設定され、その直後に関連付けられたトークンが続きます。キーワードの最初の文字は、テーブル内の位置から判断されるため、保存する必要はありません。キーワードとトークンは以下にすべて記載されています。「J」、「Q」、「Y」、「Z」のブロックは空であることに注意してください。

```
AUTO   A9H  DSKF   26H  LIST    93H  REM     8FH
AND    F6H  DRAW   BEH  LFILES  BBH  RESUME  A7H
ABS    06H  ELSE   A1H  LOG     0AH  RSET    B9H
ATN    0EH  END    81H  LOC     2CH  RIGHT$  02H
ASC    15H  ERASE  A5H  LEN     12H  RND     08H
ATTR$  E9H  ERROR  A6H  LEFT$   01H  RENUM   AAH
BASE   C9H  ERL    E1H  LOF     2DH  SCREEN  C5H
BSAVE  D0H  ERR    E2H  MOTOR   CEH  SPRITE  C7H
BLOAD  CFH  EXP    0BH  MERGE   B6H  STOP    90H
BEEP   C0H  EOF    2BH  MOD     FBH  SWAP    A4H
BIN$   1DH  EQV    F9H  MKI$    2EH  SET     D2H
CALL   CAH  FOR    82H  MKS$    2FH  SAVE    BAH
CLOSE  B4H  FIELD  B1H  MKD$    30H  SPC(    DFH
COPY   D6H  FILES  B7H  MID$    03H  STEP    DCH
CONT   99H  FN     DEH  MAX     CDH  SGN     04H
CLEAR  92H  FRE    0FH  NEXT    83H  SQR     07H
CLOAD  9BH  FIX    21H  NAME    D3H  SIN     09H
CSAVE  9AH  FPOS   27H  NEW     94H  STR$    13H
CSRLIN E8H  GOTO   89H  NOT     E0H  STRING$ E3H
CINT   1EH  GO TO  89H  OPEN    B0H  SPACE$  19H
CSNG   1FH  GOSUB  8DH  OUT     9CH  SOUND   C4H
CDBL   20H  GET    B2H  ON      95H  STICK   22H
CVI    28H  HEX$   1BH  OR      F7H  STRIG   23H
CVS    29H  INPUT  85H  OCT$    1AH  THEN    DAH
CVD    2AH  IF     8BH  OFF     EBH  TRON    A2H
COS    0CH  INSTR  E5H  PRINT   91H  TROFF   A3H
CHR$   16H  INT    05H  PUT     B3H  TAB(    DBH
CIRCLE BCH  INP    10H  POKE    98H  TO      D9H
COLOR  BDH  IMP    FAH  POS     11H  TIME    CBH
CLS    9FH  INKEY$ ECH  PEEK    17H  TAN     0DH
CMD    D7H  IPL    D5H  PSET    C2H  USING   E4H
DELETE A8H  KILL   D4H  PRESET  C3H  USR     DDH
DATA   84H  KEY    CCH  POINT   EDH  VAL     14H
DIM    86H  LPRINT 9DH  PAINT   BFH  VARPTR  E7H
DEFSTR ABH  LLIST  9EH  PDL     24H  VDP     C8H
DEFINT ACH  LPOS   1CH  PAD     25H  VPOKE   C6H
DEFSNG ADH  LET    88H  PLAY    C1H  VPEEK   18H
DEFDBL AEH  LOCATE D8H  RETURN  8EH  WIDTH   A0H
DSKO$  D1H  LINE   AFH  READ    87H  WAIT    96H
DEF    97H  LOAD   B5H  RUN     8AH  XOR     F8H
DSKI$  EAH  LSET   B8H  RESTORE 8CH
```

</a>

<a name="3d26h"></a>

    Address... 3D26H

この21バイトのテーブルは、インタープリタがプログラムのトークン化を行う際に使用されます。このテーブルには、10個の1文字キーワードとそのトークンが含まれています。

```
+ ... F1H    * ... F3H   ^ ... F5H    ' ... E6H = ... EFH
- ... F2H    / ... F4H   \ ... FCH    > ... EEH < ... F0H
```

</a>

<a name="3d3bh"></a>

    Address... 3D3BH

このテーブルは、Expression Evaluatorが特定の挿入演算子の優先順位を決定するために使用されます。テーブルの値が大きいほど、演算子の優先順位が高くなります。関係演算子 (64H)、「NOT」演算子 (5AH)、および否定演算子 (7DH) の優先順位は含まれていません。これらはExpression EvaluatorとFactor Evaluatorによって直接定義されます。

```
79H ... +       46H ... OR
79H ... -       3CH ... XOR
7CH ... *       32H ... EQV
7CH ... /       28H ... IMP
7FH ... ^       7AH ... MOD
50H ... AND     7BH ... \
```

</a>

<a name="3d47h"></a>

    Address... 3D47H

このテーブルは、ユーザー定義関数の結果を、関数定義で使用された変数と同じ型に変換するために使用されます。このテーブルには、型変換ルーチンのアドレスが含まれています。

```
303AH ... CDBL
0000H ... Not used
2F8AH ... CINT
3058H ... Check string type
2FB2H ... CSNG
```

</a>

<a name="3d51h"></a>

    Address... 3D51H

このアドレス テーブルは、両方のオペランドが倍精度の場合に、特定の中置数学演算子のハンドラーを見つけるために式評価子によって使用されます。

```
269AH ... +
268CH ... -
27E6H ... *
289FH ... /
37D7H ... ^
2F83H ... Relation (<>=)
```

</a>

<a name="3d5dh"></a>

    Address... 3D5DH

このアドレス テーブルは、両方のオペランドが単精度の場合に、特定の中置数学演算子のハンドラーを検索するために式評価子によって使用されます。

```
324EH ... +
3257H ... -
325CH ... *
3267H ... /
37C8H ... ^
2F21H ... Relation (<>=)
```

</a>

<a name="3d69h"></a>

    Address... 3D69H

このアドレス テーブルは、両方のオペランドが整数の場合に、特定の中置数学演算子のハンドラーを見つけるために式評価子によって使用されます。

```
3172H ... +
3167H ... -
3193H ... *
4DB8H ... /
383FH ... ^
2F4DH ... Relation (<>=)
```

</a>

<a name="3d75h"></a>

    Address... 3D75H

この表にはインタープリタのエラーメッセージが含まれており、各メッセージは0バイト終端文字付きのプレーンテキストで保存されます。関連するエラーコードは参考用として以下に示されており、表の一部ではありません。

```
01 NEXT without FOR             19 Device I/O error
02 Syntax error                 20 Verify error
03 RETURN without GOSUB         21 No RESUME
04 Out of DATA                  22 RESUME without error
05 Illegal function call        23 Unprintable error
06 Overflow                     24 Missing operand
07 Out of memory                25 Line buffer overflow
08 Undefined line number        50 FIELD overflow
09 Subscript out of range       51 Internal error
10 Redimensioned array          52 Bad file number
11 Division by zero             53 File not found
12 Illegal direct               54 File already open
13 Type mismatch                55 Input past end
14 Out of string space          56 Bad file name
15 String too long              57 Direct statement in file
16 String formula too complex   58 Sequential I/O only
17 Can't CONTINUE               59 File not OPEN
18 Undefined user function
```

</a>

<a name="3fd2h"></a>

    Address... 3FD2H

これは、ゼロ バイトで終了するプレーン テキスト メッセージ「` in `」です。

<a name="3fd7h"></a>

    Address... 3FD7H

これは、ゼロ バイトで終了するプレーン テキスト メッセージ「`Ok`」、CR、LF です。

<a name="3fdch"></a>

    Address... 3FDCH

これは、ゼロ バイトで終了するプレーン テキスト メッセージ「`Break`」です。

<a name="3fe2h"></a>

    Address... 3FE2H

このルーチンは、Z80スタックから、レジスタペアDEでループ変数アドレスが指定された「`FOR`」ループパラメータブロックを検索します。検索は、呼び出し元の戻りアドレスとRunloopの戻りアドレスを考慮して、現在のZ80 SPの4バイト上から開始されます。「`FOR`」トークン（82H）が存在しない場合、ルーチンはフラグNZで終了します。見つかった場合、ループ変数アドレスはパラメータブロックから取得され、チェックされます。パラメータブロックの型バイトを指すレジスタペアHLと一致すると、ルーチンはフラグZで終了します。一致しない場合は、検索は22バイト上に移動し、次のパラメータブロックの先頭に移動します。

<a name="4001h"></a>

    Address... 4001H

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`INP`」関数を適用するために使用されます。ポート番号([5439H](#5439h))がチェックされ、ポートが読み取られ、結果が整数(4FCFH)として[DAC](#dac)に格納されます。

<a name="400bh"></a>

    Address... 400BH

このルーチンは、まず-32768～+65535（[542FH](#542fh)）の範囲のオペランドを評価し、レジスタペアBCに格納します。[SYNCHR](#synchr)標準ルーチンを使用してカンマの有無をチェックした後、0～255（521CH）の範囲の2番目のオペランドを評価し、レジスタAに格納します。

<a name="4016h"></a>

    Address... 4016H

これは「`OUT`」文のハンドラです。ポート番号とデータバイトが評価され([400BH](#400bh))、データバイトが対応するZ80ポートに書き込まれます。

<a name="401ch"></a>

    Address... 401CH

これは「`WAIT`」文ハンドラです。まずポート番号と「`AND`」オペランドが評価され（[400BH](#400bh)）、続いてオプションの「`XOR`」オペランド（521CH）が評価されます。その後、ポート番号が繰り返し読み取られ、オペランドがXOR演算、次にAND演算され、ゼロ以外の結果が得られるまで実行されます。一部のMSXマニュアルに記載されている情報とは異なり、ループは[CKCNTC](#ckcntc)標準ルーチンが内部から呼び出されるため、Ctrl + Stopキーで中断できます。

<a name="4039h"></a>

    Address... 4039H

このルーチンは、プログラムモード中にプログラムテキストの末尾に到達した際に、Runloopによって使用されます。[ONEFLAG](#oneflag) がチェックされ、まだアクティブなエラーコードが含まれているかどうかが確認されます。含まれている場合は「`No RESUME`」エラーが生成され、含まれていない場合はプログラムは通常通り終了処理されます (6401H)。このルーチンの目的は、末尾に「`RESUME`」ステートメントがない「`ON ERROR`」ハンドラを捕捉することです。

<a name="404fh"></a>

    Address... 404FH

このルーチンは、「`DATA`」文でエラーが見つかった場合に、「`READ`」文ハンドラによって使用されます。[DATLIN](#datlin) に含まれる行番号が [CURLIN](#curlin) にコピーされるため、エラーハンドラはプログラム行ではなく「`DATA`」行を不正な文としてフラグ付けします。その後、制御は「`Syntax error`」ジェネレータに移ります。

<a name="4055h"></a>
<a name="4058h"></a>
<a name="405bh"></a>
<a name="405eh"></a>
<a name="4061h"></a>
<a name="4064h"></a>
<a name="4067h"></a>
<a name="406ah"></a>
<a name="406dh"></a>

    Address... 4055H

これは 9 つのエラー ジェネレーターのグループであり、レジスタ E には関連するエラー コードがロードされ、制御はエラー ハンドラーに移ります。

|ADDRESS|ERROR
|-------|-----------------------
|4055H  |Syntax error
|4058H  |Division by zero
|405BH  |NEXT without FOR
|405EH  |Redimensioned array
|4061H  |Undefined user function
|4064H  |RESUME without error
|4067H  |Overflow error
|406AH  |Missing operand
|406DH  |Type mismatch

</a>

<a name="406fh"></a>

    Address... 406FH

これはインタープリタのエラーハンドラです。すべてのエラージェネレータは、レジスタEにエラーコードを格納してここに転送されます。まず[VLZADR](#vlzadr)で、"`VAL`"文ハンドラがプログラムテキストを変更したかどうかが確認されます。変更されている場合は、[VLZDAT](#vlzdat)から元の文字が復元されます。次に、現在の行番号が[CURLIN](#curlin)から[ERRLIN](#errlin)と[DOT](#dot)にコピーされ、Z80スタックが[SAVSTK](#savstk)(62F0H)から復元されます。エラーコードは[ERRFLG](#errflg)に格納され、"`ERR`"関数で使用されます。また、現在のプログラムテキスト位置が[SAVTXT](#savtxt)から[ERRTXT](#errtxt)にコピーされ、"`RESUME`"文ハンドラで使用されます。エラー行番号とプログラムテキストの位置も、[OLDLIN](#oldlin) と [OLDTXT](#oldtxt) にコピーされ、「`CONT`」文ハンドラで使用されます。次に、[ONELIN](#onelin) が実行され、以前に「`ON ERROR`」文が実行されたかどうかが確認されます。実行された場合、かつエラーコードがまだアクティブでなければ、制御は Runloop (4620H) に移り、BASIC のエラー回復文が実行されます。

それ以外の場合、エラーコードを用いて[3D75H](#3d75h)にあるエラーメッセージテーブルをカウントし、必要なエラーコードに達するまで進みます。CR,LFが発行され([7323H](#7323h))、[TOTEXT](#totext)標準ルーチンによって画面がテキストモードに強制的に切り替えられます。その後、BELLコードが発行され、エラーメッセージが表示されます([6678H](#6678h))。インタープリタがダイレクトモードではなくプログラムモードの場合、この後に行番号([340AH](#340ah))が続き、制御は「`OK`」ポイントに移ります。

<a name="411fh"></a>

    Address... 411FH

これは、終了するプログラムがインタープリタのメインループに戻るポイントです。画面は[TOTEXT](#totext)標準ルーチンによって強制的にテキストモードになり、プリンタがクリアされ([7304H](#7304h))、I/Oバッファ0がクローズされます(6D7BH)。その後、画面にCR,LFが発行され([7323H](#7323h))、「`OK`」というメッセージが表示され([6678H](#6678h))、制御がメインループに戻ります。

<a name="4134h"></a>

    Address... 4134H

これはインタープリタのメインループです。[CURLIN](#curlin) はまず FFFFH に設定され、ダイレクトモードを示します。次に [AUTFLG](#autflg) をチェックして、"`AUTO`" モードがオンかどうかを確認します。オンになっている場合は、[AUTLIN](#autlin) から次の行番号を取得し、表示します ([3412H](#3412h))。次に、プログラムテキストエリアを検索し、この行が既に存在するかどうかを確認します ([4295H](#4295h))。存在する場合は、アスタリスクまたはスペースが表示されます。

次に、[ISFLIO](#isflio) 標準ルーチンを使用して、「`LOAD`」文がアクティブかどうかを判断します。アクティブであれば、プログラム行はカセット ([7374H](#7374h)) から取得され、そうでない場合は [PINLIN](#pinlin) 標準ルーチンを介してコンソールから取得されます。行が空であるか、Ctrl + Stop キーが押されている場合は、制御はメインループの先頭 ([4134H](#4134h)) に戻り、それ以上の処理は行われません。行が行番号で始まっている場合は、行番号はレジスタペア DE (4769H) で符号なし整数に変換されます。その後、行はトークン化され、[KBUF](#kbuf) ([42B2H](#42b2h)) に格納されます。行の先頭に行番号が見つからない場合、制御は実行ループ ([6D48H](#6d48h)) に移り、文が実行されます。

行が行番号で始まっていると仮定すると、行番号が空かどうかがテストされ、その結果が一時的に保存されます。行番号は [DOT](#dot) と [AUTLIN](#autlin) にコピーされ、[AUTINC](#autinc) の内容が加算されます。[AUTLIN](#autlin) が 65530 を超えると、"`AUTO`" モードはオフになります。次に、プログラムテキスト領域 ([4295H](#4295h)) を検索し、一致する行番号を探します。見つからない場合は、次に大きい行番号の位置を探します。一致する行番号が見つからず、行が空で、"`AUTO`" モードがオフの場合は、"`Undefined line number`" エラーが生成されます ([481CH](#481ch))。一致する行番号が見つかり、行が空で、"`AUTO`" モードがオンの場合、メインループは次のステートメント (4237H) にスキップします。

それ以外の場合、プログラムテキストエリア内のポインタはすべて行番号（54EAH）に変換され、既存のプログラム行は削除されます（5405H）。新しいプログラム行が空でない場合、プログラムテキストエリアは必要な量（[6250H](#6250h)）だけ開かれ、トークン化されたプログラム行が[KBUF](#kbuf)からコピーされます。

その後、プログラムテキスト領域のリンクが再計算され(4257H)、変数ストレージ領域がクリアされ([629AH](#629ah))、制御がメインループの開始に戻ります。

<a name="4253h"></a>

    Address... 4253H

このルーチンは、プログラムの変更後にプログラムテキストエリアのリンクを再計算します。各プログラム行の最初の2バイトには、次の行の開始アドレスが格納されており、これをリンクと呼びます。リンクによってプログラム行ごとに必要な記憶領域は増加しますが、インタープリタが特定の行を見つけるのにかかる時間を大幅に短縮します。

以下に、一般的なプログラム行の例を示します。この例では、プログラム テキスト領域 (8001H) の先頭にある行 "`10 PRINT 9`" です。

<a name="figure43"></a>![][CH05F43]

**図43:** プログラムライン

上記の例では、リンクはZ80ワードオーダー（LSB、MSB）で格納され、その直後に同じくワードオーダーでバイナリ行番号が続きます。文自体は、「`PRINT`」トークン（91H）、1つのスペース、数字の9、そして行末文字（00H）で構成されています。格納形式の詳細については、トークン化ルーチン（[42B2H](#42b2h)）を参照してください。

各リンクは、行末文字が見つかるまで行をスキャンするだけで再計算されます。この処理は、0000H という特別なリンクで示されるプログラム記憶領域の末尾に到達すると完了します。

<a name="4279h"></a>

    Address... 4279H

このルーチンは、「`LIST`」ステートメントハンドラによって使用され、プログラムテキストから最大2つの行番号オペランドを収集します。最初の行番号が存在する場合、それはレジスタペアDE ([475FH](#475fh)) に符号なし整数に変換され、存在しない場合はデフォルト値0000Hが返されます。2番目の行番号が存在する場合、その前に「-」トークン (F2H) が付加され、Z80スタックに返されます。存在しない場合はデフォルト値65530が返されます。その後、制御はプログラムテキスト検索ルーチンに移り、最初に参照されるプログラム行を検索します。

<a name="4295h"></a>

    Address... 4295H

このルーチンは、レジスタペアDEに指定された行番号を持つプログラム行をプログラムテキストエリアから検索します。[TXTTAB](#txttab)に含まれるアドレスから開始し、各プログラム行の一致を調べます。一致する行番号が見つかった場合、ルーチンはフラグZ,CとレジスタペアBCをプログラム行の先頭にセットして終了します。より大きな行番号が見つかった場合、ルーチンはフラグNZ,NCで終了し、終了リンクに達した場合はフラグZ,NCで終了します。

<a name="42b2h"></a>

    Address... 42B2H

このルーチンは、インタープリタのメインループでテキスト行をトークン化するために使用します。開始時にレジスタペアHLは[BUF](#buf)内の最初のテキスト文字を指します。終了時にトークン化された行は[KBUF](#kbuf)に格納され、レジスタペアBCはその行の長さを保持し、レジスタペアHLはその行の先頭を指します。

開始引用符の後、または「`REM`」、「`CALL`」、または「`DATA`」キーワードの後を除き、キーワードに一致する文字列は、そのキーワードのトークンに置き換えられます。キーワードの比較では、小文字のアルファベットは大文字に変換されます。文字「`?`」は「`PRINT`」トークン（91H）に置き換えられ、「'」は「:」（3AH）、「`REM`」トークン（8FH）、「'」トークン（E6H）に置き換えられます。「`ELSE`」トークン（A1H）の前には、文区切り文字（3AH）が付きます。テキスト内のその他の文字は、小文字のアルファベットが大文字に変換されることを除き、変更されずにコピーされます。80H未満のトークン（関数トークン）は、通常のテキストと競合するため、[KBUF](#kbuf)に直接格納できません。代わりに、FFH、トークン+80Hというシーケンスが使用されます。

数値定数はまず[DAC](#dac) ([3299H](#3299h)) の標準型のいずれかに変換されます。その後、型と大きさに応じて、メモリ使用量を最小限に抑えるという基本的な考え方に基づいて、いくつかの方法のいずれかで格納されます。

```
0BH LSB MSB .................8進数
0CH LSB MSB .................16進数
11H ～ 1AH ..................整数 0～9
0FH LSB .....................整数 10～255
1CH LSB MSB .................整数 256 ～ 32767
1DH EE DD DD DD .............単精度
1FH EE DD DD DD DD DD DD ... 倍精度
```

2進数には特定のトークンがなく、文字列として扱われます。これはMicrosoft BASICの以前のバージョンからの遺産と思われます。数値の先頭に付く符号は演算子とみなされ、別のトークンとして保存されます。負の数はトークン化の際に生成されません。倍精度数は多くのスペースを占有するため、例えばPRINT 1#,1#,1#のように、1行に倍精度数が多すぎると[KBUF](#kbuf)が一杯になる可能性があります。その場合、「`行バッファオーバーフロー`」エラーが発生します。

[43B5H](#43b5h) の表内のキーワード トークンの後に続く数値は行番号オペランドとみなされ、別のトークンとともに格納されます。

```
0DH LSB MSB ................... ポインタ
0EH LSB MSB ................... 行番号
```

トークン化中は通常の型 (0EH) のみ生成され、プログラムが実際に実行されると、これらの行番号オペランドはアドレス ポインター型 (0DH) に変換されます。

<a name="43b5h"></a>

    Address... 43B5H

このto kensテーブルは、トークン化の際に、行番号オペランドを取るキーワードをチェックするために使用されます。キーワード自体は以下のとおりです。

```
RESTORE    RUN
AUTO       LIST
RENUM      LLIST
DELETE     GOTO
RESUME     RETURN
ERL        THEN
ELSE       GOSUB
```

</a>

<a name="4524h"></a>

    Address... 4524H

これは「`FOR`」文ハンドラです。まずループ変数が検索され、「`LET`」ハンドラによって初期値が割り当てられます（[4880H](#4880h)）。ループ変数のアドレスはレジスタペアDEに返されます。文の終了が検索され（[485BH](#485bh)）、そのアドレスが[ENDFOR](#endfor)に格納されます。次に、Z80スタック（3FE6H）で、同じループ変数を使用するパラメータブロックが検索されます。見つかったパラメータブロックごとに、現在の[ENDFOR](#endfor)アドレスがパラメータブロックのアドレスと比較され、一致する場合はそのスタックセクションが破棄されます。これは、ループ内から「`GOTO`」で「`FOR`」文に戻った結果、ループが不完全になる可能性があるためです。

終了オペランドとオプションの「`STEP`」オペランドは評価され、ループ変数と同じ型に変換されます。スタック領域が利用可能であることを確認した後 ([625EH](#625eh))、25バイトのパラメータブロックがZ80スタックにプッシュされます。これは以下の要素で構成されます。

```
2バイト ... ENDFOR アドレス
2バイト ... 現在の行番号
8バイト ... ループ終了値
8バイト ... STEP値
1バイト ... ループ型
1バイト ... STEP方向
2バイト ... ループ変数のアドレス
1バイト ... FORトークン (82H)
```

パラメータブロックは、終了値に到達するまで「`NEXT`」文ハンドラによって使用されるためスタック上に残り、その後破棄されます。整数および単精度ループ変数の場合、終了値とSTEP値に8バイトすべてが必要ない場合でも、ブロックのサイズは一定です。これらの場合、最下位バイトはガベージデータとしてパックされます。

「`NEXT`」文ハンドラによって実行される算術演算の種類、ひいてはループ実行速度は、オペランドの型ではなく、ループ変数の型に完全に依存することに注意してください。プログラムを最速で実行するには、整数型変数（例えばN%）を使用する必要があります。

<a name="4601h"></a>

    Address... 4601H

これは実行ループです。各ステートメントハンドラは完了時にここに戻り、インタープリタは次のステートメントに進みます。エラー回復のために、現在のZ80 SPが[SAVSTK](#savstk)にコピーされ、CTRL-STOPキーは[ISCNTC](#iscntc)標準ルーチンによってチェックされます。保留中の割り込みは処理され([6389H](#6389h))、インタープリタ全体にわたってレジスタペアHLに保持されている現在のプログラムテキスト位置が[SAVTXT](#savtxt)にコピーされます。

次に、現在のプログラム文字が検査されます。これが文区切り文字 (3AH) である場合、制御は直ちに実行ポイント ([4640H](#4640h)) に移ります。行末文字 (00H) 以外の場合、文末に不正なテキストがあるため、「`構文エラー`」が生成されます ([4055H](#4055h))。レジスタペア HL は新しいプログラム行の先頭文字まで進められ、リンクが検査されます。これがゼロの場合、プログラムは終了します ([4039H](#4039h))。それ以外の場合、新しい行から行番号が取得され、[CURLIN](#curlin) に格納されます。[TRCFLG](#trcflg) がゼロ以外の場合、行番号が角括弧で囲まれて表示され ([3412H](#3412h))、制御は実行ポイントに移ります。

<a name="4640h"></a>

    Address... 4640H

これはRunloopの実行ポイントです。Runloopの開始位置([4601H](#4601h))への戻りがZ80スタックにプッシュされ、[CHRGTR](#chrgtr)標準ルーチンを介して新しい文の最初の文字が取得されます。それが下線文字(5FH)の場合、制御は「`CALL`」文ハンドラ(55A7H)に移ります。それが最小の文トークンである81Hより小さい場合、制御は「`LET`」ハンドラ([4880H](#4880h))に移ります。それが最大の文トークンであるD8Hより大きい場合、それが文として許可されている関数トークン([51ADH](#51adh))の1つであるかどうかがチェックされます。それ以外の場合、ハンドラアドレスは[392EH](#392eh)のテーブルから取得され、スタックにプッシュされます。次に、制御は [CHRGTR](#chrgtr) 標準ルーチンに移行し、ステートメント ハンドラーに制御が渡される前に次のプログラム文字を取得します。

<a name="4666h"></a><a name="chrgtr"></a>

```
Address... 4666H
Name...... CHRGTR
Entry..... HL points to current program character
Exit...... A=Next program character
Modifies.. AF, HL
```

プログラムテキストから次の文字を取得する標準ルーチンです。レジスタペアHLがインクリメントされ、文字がレジスタAに格納されます。文字がスペース、タブコード（09H）、またはLFコード（0AH）の場合はスキップされます。文区切り文字（3AH）、または行末文字（00H）の場合は、ルーチンはフラグZ,NCで終了します。0から9までの数字の場合は、ルーチンはフラグNZ,Cで終了します。数値接頭辞トークン以外の文字の場合は、ルーチンはフラグNZ,NCで終了します。文字が数値接頭辞トークンのいずれかである場合は、[CONSAV](#consav)に格納され、オペランドが[CONLO](#conlo)にコピーされます。タイプコードは[CONTYP](#contyp)に格納され、末尾のプログラム文字のアドレスは[CONTXT](#contxt)に格納されます。

<a name="46e8h"></a>

    Address... 46E8H

このルーチンは、Factor Evaluatorによって使用され、トークン分解時に[CHRGTR](#chrgtr)標準ルーチンによってプレフィックストークンの1つが返された際に数値オペランドを復元します。プレフィックストークンはまず[CONSAV](#consav)から取得されます。行番号またはポインタトークン以外の場合、オペランドは[CONLO](#conlo)から[DAC](#dac)にコピーされ、型コードは[CONTYP](#contyp)から[VALTYP](#valtyp)にコピーされます。行番号の場合、単精度に変換され[DAC](#dac)(3236H)に格納されます。ポインタの場合、参照先のプログラム行から元の行番号が復元され、単精度に変換されて[DAC](#dac)(3236H)に格納されます。

<a name="4718h"></a>

    Address... 4718H

これは「`DEFSTR`」ステートメントハンドラです。レジスタEに文字列型コード（03H）がロードされ、制御は一般的な型定義ルーチンに移ります。

<a name="471bh"></a>

    Address... 471BH

これは「`DEFINT`」ステートメントハンドラです。レジスタEに整数型コード（02H）がロードされ、制御は一般的な型定義ルーチンに移ります。

<a name="471eh"></a>

    Address... 471EH

これは「`DEFSNG`」ステートメントハンドラです。レジスタEに単精度型コード（04H）がロードされ、制御は一般的な型定義ルーチンに移ります。

<a name="4721h"></a>

    Address... 4721H

これは「`DEFDBL`」ステートメントハンドラです。レジスタEには倍精度型コード (08H) がロードされ、最初の範囲定義文字 ([64A7H](#64a7h)) がチェックされます。これが大文字のアルファベットでない場合、「`構文エラー`」が生成されます ([4055H](#4055h))。「-」トークン (F2H) が続く場合、2番目の範囲定義文字が取得されチェックされます ([64A7H](#64a7h))。この2つの文字の差によって、[DEFTBL](#deftbl) 内の型コードが格納されるエントリ数が決定されます。

<a name="4755h"></a>

    Address... 4755H

このルーチンはオペランドを評価し、レジスタペアDE（520FH）内の整数に変換します。オペランドが負の場合、「`不正な関数呼び出し`」エラーが生成されます。

<a name="475fh"></a>

    Address... 475FH

このルーチンは、表の[43B5H](#43b5h)に示されているステートメントハンドラによって使用され、プログラムテキストから単一の行番号オペランドを収集し、それをレジスタペアDEの符号なし整数に変換します。テキストの最初の文字が「.」(2EH)の場合、ルーチンは[DOT](#dot)の内容で終了します。行番号トークン(0DHまたは0EH)のいずれかの場合、ルーチンは[CONLO](#conlo)の内容で終了します。それ以外の場合は、連続する桁を取得し、適切な10倍の乗算を行って積に加算し、非数値文字が見つかるまでこれを繰り返します。

<a name="479eh"></a>

    Address... 479EH

これは「`RUN`」文ハンドラです。プログラムテキストに行番号オペランドが存在しない場合、システムはクリアされ（[629AH](#629ah)）、制御はRunloopに戻り、レジスタペアHLはプログラム記憶領域の先頭を指します。行番号オペランドが存在する場合、システムはクリアされ（62A1H）、制御は「`GOTO`」文ハンドラ（47E7H）に移ります。それ以外の場合は、ファイル名（例えば「RUN "CAS:FILE"」）が想定され、制御は「`LOAD`」文ハンドラ（[6B5BH](#6b5bh)）に移ります。

<a name="47b2h"></a>

    Address... 47B2H

これは「`GOSUB`」文ハンドラです。スタック領域が利用可能かどうかを確認した後 ([625EH](#625eh))、行番号オペランドが収集され、レジスタペア DE (4769H) に格納されます。その後、7バイトのパラメータブロックがスタックにプッシュされ、制御が「`GOTO`」ハンドラ (47EBH) に移ります。パラメータブロックは以下の要素で構成されます。

```
2バイト ... ステートメント終了アドレス
2バイト ... 現在の行番号
2バイト ... 0000H
1バイト ... GOSUBトークン（8DH）
```

パラメータブロックは、「`RETURN`」文が実行されるまでスタック上に残ります。その後、元のプログラムテキストの位置を決定するために使用され、その後は破棄されます。

<a name="47cfh"></a>

    Address... 47CFH

このルーチンは、Runloop割り込みプロセッサ([6389H](#6389h))によって使用され、Z80スタック上に「`GOSUB`」型のパラメータブロックを作成します。割り込みブロックは、上記の2つのゼロバイトが[TRPTBL](#trptbl)内のデバイスエントリのアドレスに置き換えられることを除いて、通常のブロックと同じです。このアドレスは、サブルーチン終了後にデバイスの割り込みステータスを更新するために「`RETURN`」ステートメントハンドラによって使用されます。パラメータブロックをプッシュした後、制御はRunloopに移行し、レジスタペアDEで指定されたアドレスのプログラム行を実行します。

<a name="47e8h"></a>

    Address... 47E8H

これは「`GOTO`」文ハンドラです。行番号オペランド（4769H）が収集され、レジスタペアHLに格納されます。ポインタの場合、制御は直ちにRunloopに移り、新しいプログラムテキスト位置から実行を開始します。それ以外の場合は、行番号と現在の行番号を比較して、プログラムテキスト検索の開始位置を決定します。現在の行番号の方が大きい場合は、この行の末尾（4298H）から検索を開始し、小さい場合はプログラムテキスト領域の先頭（[4295H](#4295h)）から検索を開始します。参照先の行が見つからない場合は、「`未定義の行番号`」エラーが生成されます（[481CH](#481ch)）。それ以外の場合は、行番号オペランドは参照先のプログラム行のアドレスに置き換えられ、そのトークンはポインタ型（5583H）に変更されます。その後、制御はRunloopに移り、参照先のプログラム行を実行します。

<a name="481ch"></a>

    Address... 481CH

これは「`Undefined line number`」エラージェネレータです。

<a name="4821h"></a>

    Address... 4821H

これは「`RETURN`」文ハンドラです。ダミーのループ変数アドレスがレジスタペアDEに配置され、Z80スタックが検索([3FE2H](#3fe2h))され、「`FOR`」ループに属さない最初のパラメータブロックが見つかります。その後、このスタックセクションは破棄されます。この時点で「`GOSUB`」トークン(8DH)が見つからない場合、「`RETURN without GOSUB`」エラーが生成されます。

次の2バイトがブロックから取得されます。これらの値が0でない場合、ブロックは割り込みによって生成されたことを意味し、一時的な「`STOP`」状態は解除されます（[633EH](#633eh)）。次にプログラムテキストが検査され、「`RETURN`」トークン自体に何かが続く場合は、行番号オペランドとみなされ、制御は「`GOTO`」ハンドラ（[47E8H](#47e8h)）に移ります。それ以外の場合、以前の行番号とプログラムテキストアドレスがブロックから取得され、制御はRunloopに戻ります。

<a name="485bh"></a>

    Address... 485BH

これは「`DATA`」文ハンドラです。プログラムテキストは、文区切り文字（3AH）または行末文字（00H）が見つかるまでスキップされます。このルーチンは、エントリポイント485DHを介して「`REM`」および「`ELSE`」文ハンドラとしても機能します。この場合、行末文字のみがターミネータとして機能します。

<a name="4880h"></a>

    Address... 4880H

これは「`LET`」文ハンドラです。まず変数が検索され（[5EA4H](#5ea4h)）、そのアドレスが[TEMP](#temp)に保存され、オペランドが評価されます（[4C64H](#4c64h)）。必要に応じて、オペランドの型は変数の型（517AH）に合わせて変更されます。オペランドが3つの数値型のいずれかである場合は、[DAC](#dac)から変数記憶域（2EF3H）の変数にコピーされます。オペランドが文字列型の場合、文字列本体のアドレスがディスクリプタから取得され、チェックされます。文字列本体が[KBUF](#kbuf)にある場合（直接文内の明示的な文字列の場合と同様）、まず文字列本体が文字列記憶域にコピーされ、新しいディスクリプタ（6611H）が作成されます。その後、ディスクリプタは [TEMPST](#tempst) (67EEH) から解放され、変数記憶領域 (2EF3H) 内の変数にコピーされます。

<a name="48e4h"></a>

    Address... 48E4H

これは「`ON ERROR`」、「`ON DEVICE GOSUB`」、および「`ON EXPRESSION`」文のハンドラです。次のプログラムテキスト文字が「`ERROR`」トークン（A6H）でない場合、制御は「`ON DEVICE GOSUB`」および「`ON EXPRESSION`」ハンドラ（[490DH](#490dh)）に移ります。プログラムテキストがチェックされ、その後に「`GOTO`」トークン（89H）が続くことが確認され、その後行番号オペランド（4769H）が収集されます。プログラムテキストが検索され、参照行のアドレス（4293H）が取得され、[ONELIN](#onelin)に格納されます。行番号オペランドが0でない場合、ルーチンは終了します。行番号オペランドが0の場合、[ONEFLG](#oneflg)がチェックされ、エラー状況が既に発生しているかどうかが確認されます（つまり、文がBASICエラー回復ルーチン内にあることを意味します）。そうであれば、制御はエラー ハンドラー (4096H) に移行して即時エラーを強制し、そうでない場合はルーチンは正常に終了します。

<a name="490dh"></a>

    Address... 490DH

これは「`ON DEVICE GOSUB`」および「`ON EXPRESSION`」文ハンドラです。次のプログラムテキスト文字がデバイストークン（[7810H](#7810h)）でない場合、制御は「`ON EXPRESSION`」ハンドラ（[4943H](#4943h)）に移ります。プログラムテキスト内で「`GOSUB`」トークン（8DH）を検索した後、特定のデバイスに必要な行番号オペランドが順に収集されます（4769H）。指定された行番号オペランドがゼロでない場合、プログラムテキスト内で参照行のアドレス（4293H）が検索され、そのアドレスが[TRPTBL](#trptbl)（[785CH](#785ch)）内のデバイスエントリに格納されます。行番号オペランドが見つからなくなると、ルーチンは終了します。

<a name="4943h"></a>

    Address... 4943H

これは「`ON EXPRESSION`」文ハンドラです。オペランドが評価され（521CH）、それに続く「`GOSUB`」トークン（8DH）または「`GOTO`」トークン（89H）がレジスタAに格納されます。その後、このオペランドはプログラムテキストに沿ってカウントされ、レジスタペアHLが必要な行番号オペランドを指すまで続きます。その後、制御はRunloop実行ポイント（4646H）に戻り、「`GOSUB`」または「`GOTO`」トークンをデコードします。

<a name="495dh"></a>

    Address... 495DH

これは「`RESUME`」文ハンドラです。まず[ONEFLG](#oneflg)をチェックし、エラー状態が既に存在しているかどうかを確認します。存在しない場合は、「`RESUME without error`」が生成されます([4064H](#4064h))。この後に0以外の行番号オペランドが続く場合、制御は「`GOTO`」ハンドラ(47EBH)に移ります。「`NEXT`」トークン(83H)が続く場合、エラー位置は[ERRTXT](#errtxt)と[ERRLIN](#errlin)から復元され、次の文の開始位置([485BH](#485bh))が検索され、ルーチンは終了します。行番号オペランドがない場合、または0の場合は、[ERRTXT](#errtxt)と[ERRLIN](#errlin)からエラー位置が検索され、ルーチンは終了します。

<a name="49aah"></a>

    Address... 49AAH

これは「`ERROR`」文ハンドラです。オペランドは評価され、レジスタE（521CH）に格納されます。オペランドがゼロの場合、「`Illegal function call`」エラー（475AH）が生成され、それ以外の場合はエラーハンドラ（[406FH](#406fh)）に制御が移ります。

<a name="49b5h"></a>

    Address... 49B5H

これは「`AUTO`」ステートメントハンドラです。オプションの開始行番号オペランドと増分行番号オペランド（どちらもデフォルト値は10）が収集され（[475FH](#475fh)）、[AUTLIN](#autlin)と[AUTINC](#autinc)に格納されます。[AUTFLG](#autflg)を非ゼロにすると、Runloopの戻り値は破棄され、制御はMainloop（[4134H](#4134h)）に直接移ります。

<a name="49e5h"></a>

    Address... 49E5H

これは「`IF`」文ハンドラです。オペランドが評価され（[4C64H](#4c64h)）、"`GOTO`"トークン（89H）または"`THEN`"トークン（DAH）をチェックした後、その符号がテストされます（[2EA1H](#2ea1h)）。オペランドがゼロ以外（true）の場合、後続のテキストがRunloop（4646H）への即時転送によって実行されるか、行番号オペランドの場合は"`GOTO`"ハンドラ（[47E8H](#47e8h)）によって実行されます。オペランドがゼロ（false）の場合、文のテキストがスキャンされ（[485BH](#485bh)）、"`IF`"トークン（8BH）とバランスが取れていない"`ELSE`"トークン（A1H）が見つかるまで実行が再開されます。

<a name="4a1dh"></a>

    Address... 4A1DH

これは「`LPRINT`」ステートメントハンドラです。[PRTFLG](#prtflg) はプリンタへの出力を直接行うために 01H に設定され、制御は「`PRINT`」ハンドラ (4A29H) に移ります。

<a name="4a24h"></a>

    Address... 4A24H

これは「`PRINT`」文ハンドラです。まずプログラムテキストの末尾にバッファ番号があるかチェックし、必要に応じて[PTRFIL](#ptrfil)を設定して、必要なI/Oバッファ([6D57H](#6d57h))に出力先を指定します。プログラムテキストがもう存在しない場合は、CR,LF(7328H)が発行され、ルーチンは終了します([4AFFH](#4affh))。それ以外の場合は、プログラムテキストから次の文字が取得され、解析されます。「`USING`」トークン(E4H)が見つかった場合、制御は「`PRINT USING`」ハンドラ([60B1H](#60b1h))に移ります。「;」文字が見つかった場合、制御は先頭に戻り、次の項目を取得します(4A2EH)。カンマが見つかった場合、[TTYPOS](#ttypos)、[LPTPOS](#lptpos)、またはI/OバッファFCBから、現在の印刷位置を14の整数倍にするために必要なスペースが発行されます。出力が画面に向けられ、印刷位置が[CLMLST](#clmlst)の内容と等しいかそれより大きい場合、または出力がプリンタに向けられ、印刷位置が238以上の場合は、代わりにCR,LFが発行されます(7328H)。 "`SPC(`"トークン(DFH)が見つかった場合、オペランドが評価され([521BH](#521bh))、必要な数のスペースが出力されます。 "`TAB(`"トークン(DBH)が見つかった場合、オペランドが評価され([521BH](#521bh))、現在の印刷位置を[TTYPOS](#ttypos)、[LPTPOS](#lptpos)、またはI/OバッファFCBから必要なポイントまで移動するために十分なスペースが発行されます。

これらの文字が見つからない場合、プログラム テキストにはデータ項目が含まれ、それが評価されます ([4C64H](#4c64h))。オペランドが文字列の場合は、そのまま表示されます (667BH)。数値の場合は、最初に [FBUFFR](#fbuffr) ([3425H](#3425h)) 内のテキストに変換され、文字列ディスクリプタが作成されます (6635H)。出力が I/O バッファに送られる場合は、結果の文字列が表示されます (667BH)。出力が画面またはプリンタに送られる場合は、[TTYPOS](#ttypos) または [LPTPOS](#lptpos) からの現在の印刷位置が行の長さと比較され、出力が行に収まらない場合は CR、LF が発行されます (7328H)。最大行長はプリンタの場合は 255 で、画面の場合は [LINLEN](#linlen) から取得されます。文字列が表示されると、制御はハンドラーの先頭に戻ります。

<a name="4affh"></a>

    Address... 4AFFH

このルーチンは、[PRTFLG](#prtflg) と [PTRFIL](#ptrfil) をゼロにして、インタープリタの出力を画面に返します。

<a name="4b0eh"></a>

    Address... 4B0EH

これは「`LINE INPUT`」、「`LINE INPUT#`」、および「`LINE`」ステートメントハンドラです。後続のプログラムテキスト文字が「`INPUT`」トークン（85H）以外の場合、制御は「`LINE`」ステートメントハンドラ（[58A7H](#58a7h)）に移ります。後続のプログラムテキスト文字が「#」トークン（23H）の場合、制御は「`LINE INPUT#`」ステートメントハンドラ（[6D8FH](#6d8fh)）に移ります。

後続のプロンプト文字列は評価され、表示されます (4B7BH)。また、変数が検索され ([5EA4H](#5ea4h))、文字列型であるかどうかが確認されます ([3058H](#3058h))。テキスト行は、[INLIN](#inlin) 標準ルーチンを介してコンソールから収集されます。フラグC (CTRL-STOP) が返された場合、制御は「`STOP`」ステートメントハンドラ (63FEH) に移ります。それ以外の場合、入力文字列が解析され、ディスクリプタが作成され (6638H)、その後、制御は代入のために「`LET`」ステートメントハンドラ (4892H) に移ります。入力が収集される前に、画面がテキストモードに強制されないことに注意してください。

<a name="4b3ah"></a>

    Address... 4B3AH

これは、ゼロ バイトで終了する「`?Redo from start`」、CR、LF のプレーン テキスト メッセージです。

<a name="4b4dh"></a>

    Address... 4B4DH

このルーチンは、「`READ/INPUT`」ステートメントハンドラがデータ項目を数値形式に変換できなかった場合に使用されます。「`READ`」モード（[FLGINP](#flginp) がゼロ以外）の場合、「`構文エラー`」が生成されます（[404FH](#404fh)）。それ以外の場合は、「`?Redo from start`」というメッセージが表示され（[6678H](#6678h)）、制御がステートメントハンドラに戻ります。

<a name="4b62h"></a><a name="input#"></a>

    Address... 4B62H

これは「`INPUT#`」ステートメントハンドラです。バッファ番号が評価され、[PTRFIL](#ptrfil) が要求されたI/Oバッファ（6D55H）からの直接入力に設定され、その後、制御は「`READ/INPUT`」ステートメントハンドラ（4B9BH）に移ります。

<a name="4b6ch"></a><a name="input"></a>

    Address... 4B6CH

これは「`INPUT`」文ハンドラです。次のプログラムテキスト文字が「#」の場合、制御は「`INPUT#`」文ハンドラ（[4B62H](#4b62h)）に移ります。それ以外の場合、[TOTXT](#totxt)標準ルーチンによって画面がテキストモードに強制的に切り替えられ、プロンプト文字列が解析（[6636H](#6636h)）され、表示されます（667BH）。その後、疑問符が表示され、[QINLIN](#qinlin)標準ルーチンによってコンソールからテキスト行が収集されます。フラグC（CTRL-STOP）が返された場合、制御は「`STOP`」ハンドラ（63FEH）に移ります。[BUF](#buf)の最初の文字がゼロ（ヌル入力）の場合、ハンドラは文の末尾（485AH）までスキップして終了します。それ以外の場合、制御は「`READ/INPUT`」複合ハンドラに移ります。

<a name="4b9fh"></a><a name="read"></a>

    Address... 4B9FH

これは「`READ`」ステートメントハンドラです。大きなセクションは「`INPUT`」および「`INPUT#`」ステートメントでも使用されるため、構造がやや複雑になっています。プログラムテキスト内の各変数は順番に（[5EA4H](#5ea4h)）配置され、それぞれに対応するデータ項目が「`LET`」ハンドラ（4893H）によって取得され、変数に割り当てられます。「`READ`」モードでは、[DATPTR](#datptr)（[4C40H](#4c40h)）の初期内容を使用して、プログラムテキストからデータ項目が取得されます。「`INPUT`」または「`INPUT#`」モードでは、データ項目はテキストバッファ[BUF](#buf)から取得されます。

「`READ`」モードでデータ項目が尽きた場合は、「`Out of DATA`」エラーが発生します。「`INPUT`」モードでデータ項目が尽きた場合は、2つの疑問符が表示され、[QINLIN](#qinlin)標準ルーチンを介してコンソールから別の行が取得されます。「`INPUT#`」モードでデータ項目が尽きた場合は、関連するI/Oバッファ([6D83H](#6d83h))から別のテキスト行が[BUF](#buf)にコピーされます。「`INPUT`」モードで変数リストが尽きた場合は、「`Extra ignore`」というメッセージが表示され([6678H](#6678h))、ハンドラが終了します([4AFFH](#4affh))。「`INPUT#`」モードではメッセージは表示されませんが、「`READ`」モードでは[DATPTR](#datptr)(63DEH)を更新することで制御が終了します。データ項目を数値形式 ([3299H](#3299h)) に変換して数値変数と一致できない場合、制御は「`?最初からやり直す`」ルーチン ([4B4DH](#4b4dh)) に転送されます。

<a name="4c2fh"></a>

    Address... 4C2FH

これは、プレーン テキスト メッセージ「`?Extra ignore`」、CR、LF で、ゼロ バイトで終了しています。

<a name="4c40h"></a>

    Address... 4C40H

このルーチンは、「`READ`」ハンドラによってプログラムテキスト内の次の「`DATA`」文を見つけるために使用されます。開始アドレスはレジスタペアHLで提供されます。各プログラム文は、「`DATA`」トークン（84H）が見つかるまで検査され、見つかった時点でルーチンは終了します（4BD1H）。終了リンクに達すると、「`Out of DATA`」エラーが生成されます。検索が進むにつれて、各プログラム行の行番号が[DATLIN](#datlin)に格納され、エラーハンドラによって使用されます。

<a name="4c5fh"></a>

    Address... 4C5FH

このルーチンは、プログラムテキスト内の次の文字が「=」トークン（EFH）であることを確認し、式評価関数に渡します。4C62Hで実行されると、「(」をチェックします。

<a name="4c64h"></a>

    Address... 4C64H

これはExpression Evaluatorです。入口レジスタHLペアは、評価される式の最初の文字を指します。出口レジスタHLペアは式の次の文字を指します。結果は[DAC](#dac)に、型コードは[VALTYP](#valtyp)に格納されます。結果が文字列の場合、文字列ディスクリプタのアドレスは[DAC](#dac)+2に返されます。ディスクリプタ自体は、文字列の長さを表す1バイトとアドレスを表す2バイトで構成され、[TEMPST](#tempst)または文字列変数に格納されます。

式とは、優先順位の異なる演算子によって連結された要素のリスト ([4DC7H](#4dc7h)) です。このような式を正しく処理するには、Expression Evaluatorが、次の演算子の優先順位が現在の演算子よりも高い場合に、中間結果を一時的にスタックし、新たな計算を開始できる必要があります。そのため、Expression Evaluatorには STACK と APPLY という2つの基本演算があります。例えば、次のようになります。

```
3+250\2^2*3^3+1,

STACK:    3+        (\ follows)
STACK:    250\      (^ follows)
APPLY:    2^2=4     (* follows)
STACK:    4*        (^ follows)
APPLY:    3^3=27    (+ follows)
APPLY:    4*27=108  (+ follows)
APPLY:    250\108=2 (+ follows)
APPLY:    3+2=5     (+ follows)
APPLY:    5+1=6     (, follows)
```

次の演算子の優先順位が初期優先順位と同等かそれ以下で、スタックが空になった時点で評価は終了します。例でカンマとして示されている式区切り文字は、優先順位が0であるとみなされるため、常に評価が停止します。通常、Expression Evaluatorは初期優先順位0から開始しますが、4C67Hのエントリポイントを使用してレジスタDに別の値を代入することができます。この機能は、Factor Evaluatorによって、モナド否定演算子と「NOT」演算子を適用する際の評価範囲を制限するために使用されます。

<a name="4d22h"></a>

    Address... 4D22H

このルーチンはExpression Evaluatorによって使用され、中置数学演算子 (+-\*/ ) を数値オペランドのペアに適用します。関係演算子 ([4F57H](#4f57h)) と論理演算子 ([4F78H](#4f78h)) には別々のルーチンがあります。最初のオペランド、その型コード、および演算子トークンは Z80 スタックで提供され、2 番目のオペランドとその型コードは [DAC](#dac) と [VALTYP](#valtyp) で提供されます。両方のオペランドの型が最初に比較され、異なる場合は、最も低い精度のオペランドがより高い精度のオペランドと一致するように変換されます。次に、オペランドは数学ルーチンで必要な位置に移動されます。整数の場合、最初のオペランドはレジスタ ペア DE に配置され、2 番目のオペランドはレジスタ ペア HL に配置されます。単精度の場合、最初のオペランドはレジスタ C、B、E、D に配置され、2 番目のオペランドは [DAC](#dac) に配置されます。倍精度の場合、最初のオペランドは[DAC](#dac)に格納され、2番目のオペランドは[ARG](#arg)に格納されます。その後、演算子トークンを使用して、オペランドの種類に応じて3D51H、3D5DH、または3D69Hのテーブルから必要なアドレスを取得し、制御は関連する演算ルーチンに移ります。

<a name="4db8h"></a>

    Address... 4DB8H

このルーチンは、Expression Evaluatorによって2つの整数オペランドの除算に使用されます。第1オペランドはレジスタペアDEに格納され、第2オペランドはレジスタペアHLに格納され、結果は[DAC](#dac)に返されます。両方のオペランドは単精度(2FCBH)に変換され、制御は単精度除算ルーチン([3265H](#3265h))に移されます。

<a name="4dc7h"></a>

    Address... 4DC7H

これはFactor Evaluatorです。入口レジスタペアHLは、評価する因子の前の文字を指します。出口レジスタペアHLは、因子の次の文字を指します。結果は[DAC](#dac)に格納され、型コードは[VALTYP](#valtyp)に格納されます。因子は以下のいずれかになります。

1. 数値または文字列定数
2. 数値または文字列変数
3. 関数
4. モナド演算子（+-NOT）
5. 括弧で囲まれた式

最初の文字は[CHRGTR](#chrgtr)標準ルーチンを介してプログラムテキストから取得され、検査されます。それが文の終了文字である場合、「`Missing operand`」エラーが生成されます([406AH](#406ah))。それがASCII数字である場合は、テキスト形式から[DAC](#dac)の標準数値型のいずれかに変換されます([3299H](#3299h))。

大文字のアルファベット (64A8H) の場合、それは変数であり、その現在の値が返されます ([4E9BH](#4e9bh))。数値トークンの場合、数値は [CONLO](#conlo) から [DAC](#dac) (46B8H) にコピーされます。表の 39DEH に示されている FFH で始まる関数トークンのいずれかの場合、デコードされて関連する関数ハンドラ (4ECFH) に制御が移されます。モナドの "+" 演算子の場合、単にスキップされます。モナドの "-" 演算子 ([4E8DH](#4e8dh)) とモナドの "`NOT`" 演算子 ([4F63H](#4f63h)) の場合のみ、何らかの処理が必要です。

開始引用符の場合、後続の明示的な文字列が解析され、ディスクリプタが作成されます ([6636H](#6636h))。「&」の場合、非10進数値定数であり、[DAC](#dac) の標準数値型のいずれかに変換されます ([4EB8H](#4eb8h))。以下に示す関数のいずれにも該当しない場合は、括弧で囲まれた式 (4E87H) でなければなりません。それ以外の場合は、「`構文エラー`」が生成されます。以下の関数トークンは直接テストされ、制御が示されたアドレスに渡されます。

```
ERR .... 4DFDH   ATTR$ .... 7C43H
ERL .... 4E0BH   VARPTR ... 4E41H
POINT .. 5803H   USR....... 4FD5H
TIME ... 7900H   INSTR .... 68EBH
SPRITE . 7A84H   INKEY$ ... 7347H
VDP .... 7B47H   STRING$ .. 6829H
BASE ... 7BCBH   INPUT$ ... 6C87H
PLAY ... 791BH   CSRLIN ... 790AH
DSKI$ .. 7C3EH   FN ....... 5040H
```

</a>

<a name="4dfdh"></a>

    Address... 4DFDH

このルーチンは、Factor Evaluatorが「`ERR`」関数を適用するために使用します。[ERRFLG](#errflg) の内容は整数 (4FCFH) として [DAC](#dac) に格納されます。

<a name="4e0bh"></a>

    Address... 4E0BH

このルーチンは、Factor Evaluatorが「`ERL`」関数を適用するために使用します。[ERRLIN](#errlin) の内容は、単精度数値 (3236H) として [DAC](#dac) にコピーされます。

<a name="4e41h"></a>

    Address... 4E41H

このルーチンは、Factor Evaluatorによって「`VARPTR`」関数を適用するために使用されます。関数トークンの後に「#」が続く場合、バッファ番号が評価され（[521BH](#521bh)）、I/OバッファFCBが特定され（[6A6DH](#6a6dh)）、そのアドレスが整数（2F99H）として[DAC](#dac)に格納されます。それ以外の場合、変数が特定され（5F5DH）、そのアドレスが整数（2F99H）として[DAC](#dac)に格納されます。

<a name="4e8dh"></a>

    Address... 4E8DH

このルーチンは、Factor Evaluatorによってモナド演算子「-」を適用するために使用されます。レジスタDは優先順位値7DHに設定され、係数は評価（4C67H）され、その後反転（2E86H）されます。

<a name="4e9bh"></a>

    Address... 4E9BH

このルーチンは、Factor Evaluatorによって変数の現在の値を返すために使用されます。まず、変数が([5EA4H](#5ea4h))に配置されます。文字列変数の場合、そのアドレスはディスクリプタを指すように[DAC](#dac)に格納されます。文字列変数でない場合、変数の内容は[DAC](#dac)(2F08)にコピーされます。

<a name="4ea9h"></a>

    Address... 4EA9H

このルーチンは、レジスタ ペア HL によって指される単一の文字をレジスタ A に返します。小文字のアルファベットの場合は大文字に変換します。

<a name="4eb8h"></a>

    Address... 4EB8H

このルーチンは、Factor Evaluatorと数値入力ルーチン([3299H](#3299h))によって使用され、アンパサンド("&")で始まる数値をテキスト形式から[DAC](#dac)の整数に変換します。有効な文字が見つかるたびに、アンパサンドの後に最初にあった文字と、それに追加された新しい数字に応じて、積が2、8、または16倍になります。積がオーバーフローした場合は、「`オーバーフロー`」エラーが発生します([4067H](#4067h))。許容されない文字が見つかると、ルーチンは終了します。

<a name="4efch"></a>

    Address... 4EFCH

このルーチンは、FFH で始まる関数トークンを処理するためにFactor Evaluatorによって使用されます。トークンが "`LEFT$`"、"`RIGHT$`"、または "`MID$`" の場合、文字列オペランドが評価され (4C62H)、そのディスクリプタのアドレスが Z80 スタックにプッシュされ、後続の数値オペランドも評価され (521CH)、スタックにスタックされます。それ以外の場合、関数の括弧で囲まれたオペランドが評価され (4E87H)、"`SQR`"、"`RND`"、"`SIN`"、"`LOG`"、"`EXP`"、"`COS`"、"`TAN`"、または "`ATN`" の場合のみ、倍精度 ([303AH](#303ah)) に変換されます。その後、関数トークンを使用して 39DEH のテーブルから必要なアドレスを取得し、関数ハンドラに制御が移ります。

<a name="4f47h"></a>

    Address... 4F47H

このルーチンは、数値入力変換ルーチン ([3299H](#3299h)) によって、「+」または「-」の文字またはトークンの有無を判定するために使用されます。正の場合はレジスタD=0、負の場合はレジスタD=FFHを返します。

<a name="4f57h"></a>

    Address... 4F57H

このルーチンは、Expression Evaluatorによって、2つのオペランドに関係演算子（<>= または組み合わせ）を適用するために使用されます。オペランドが数値の場合、Expression Evaluatorはまず算術演算子ルーチン ([4D22H](#4d22h)) を使用して、オペランドに一般的な関係演算を適用します。オペランドが文字列の場合、まず文字列比較ルーチン ([65C8H](#65c8h)) が使用されます。制御がここに移ると、関係の結果はレジスタ A に格納され、Z80 フラグは以下のようになります。

```
オペランド1 = オペランド2 ... A=00H、フラグZ、NC
オペランド1 < オペランド2 ... A=01H、フラグNZ、NC
オペランド1 > オペランド2 ... A=FFH、フラグNZ、C
```

Expression Evaluatorは、Z80スタック上の元の演算子を定義するビットマスクも提供します。このマスクは、関連する演算が必要な場合、各位置に1が入ります（例：00000<=>）。このマスクは関係式の結果に適用され、いずれの条件も満たされない場合は0が生成されます。この値は[DAC](#dac)に真（-1）または偽（0）の整数（2E9AH）として格納されます。

<a name="4f63h"></a>

    Address... 4F63H

このルーチンは、Factor Evaluatorによってモナド演算子「`NOT`」を適用するために使用されます。レジスタDは初期優先順位レベル5AHに設定され、式が評価され(4C67H)、整数([2F8AH](#2f8ah))に変換されます。その後、式は反転され、[DAC](#dac)に復元されます。

<a name="4f78h"></a>

    Address... 4F78H

このルーチンは、Expression Evaluatorによって使用され、数値オペランドのペアに論理演算子（「`OR`」、「`AND`」、「`XOR`」、「`EQV`」、「`IMP`」）または「`MOD`」および「\」演算子を適用します。最初のオペランドは既に整数に変換されており、Z80スタックに渡され、2番目のオペランドは[DAC](#dac)に渡されます。演算子トークン（実際にはその優先順位）はレジスタBに渡されます。2番目のオペランドを整数（[2F8AH](#2f8ah)）に変換した後、演算子が検査されます。「`MOD`」（[323AH](#323ah)）と「\」（[31E6H](#31e6h)）にはそれぞれ別のルーチンがありますが、これらの論理演算子はレジスタDEとHLの対応するZ80論理命令を使用してローカルに処理されます。結果は整数(2F99H)として[DAC](#dac)に格納されます。

<a name="4fc7h"></a>

    Address... 4FC7H

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`LPOS`」関数を適用するために使用されます。[LPTPOS](#lptpos)の内容は整数(4FCFH)として[DAC](#dac)に格納されます。

<a name="4fcch"></a>

    Address... 4FCCH

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`POS`」関数を適用するために使用されます。[TTYPOS](#ttypos)の内容は整数(2F99)として[DAC](#dac)に格納されます。

<a name="4fd5h"></a>

    Address... 4FD5H

このルーチンは、Factor Evaluator によって「`USR`」関数を適用するために使用されます。ユーザー番号はプログラムテキストから直接取得されます。式は使用できず、対応するアドレスは [USRTAB](#usrtab) (4FF4H) から取得されます。次に、括弧で囲まれた次のオペランドが評価され (4E87H)、渡されたパラメータとして [DAC](#dac) に残されます。文字列型の場合、そのストレージは解放されます (67D3H)。現在のプログラムテキスト位置は Z80 スタックにプッシュされ、3297H に戻ります。このアドレスのルーチンは、ユーザー関数の終了後にプログラムテキスト位置を復元します。その後、制御はユーザーアドレスに移り、レジスタペア HL は [DAC](#dac) の最初のバイトを指し、[VALTYP](#valtyp) から取得した型コードがレジスタ A に格納されます。さらに、文字列パラメータの場合、ディスクリプタアドレスは [DAC](#dac) から取得され、レジスタペア DE に格納されます。

ユーザールーチンはZ80 SPを除く任意のレジスタを変更でき、RET命令で終了する必要があります。割り込みは必要に応じて無効のままにしておくことができます。Runloopによって再度有効にされます。インタープリタに返す数値パラメータはすべて[DAC](#dac)に格納する必要があります。厳密に言えば、これは渡されたパラメータと同じ数値型である必要がありますが、[VALTYP](#valtyp)が変更された場合でも、インタープリタは常にそれを受け入れます。

文字列型を返すのはより困難です。Factor Evaluator 文字列関数と同じ方法（文字列を文字列記憶領域にコピーし、新しいディスクリプタを [TEMPST](#tempst) にプッシュする）を使用する方法は複雑で、MSX システムの変更の影響を受けやすくなります。よりシンプルで信頼性の高い方法は、渡されたパラメータを使用して結果を格納する領域を作成することです。プログラムテキストを変更する必要があるため、明示的に文字列を記述するのではなく、暗黙的なパラメータを使用する必要があります。ただし、これは慎重に行う必要があります。インタープリタが実際には文字列を受け入れていないにもかかわらず、受け入れたという印象を与えてしまう可能性が非常に高いためです。渡されたパラメータを返すだけの次の例を見てみましょう。

```
10 POKE &H9000,&HC9
20 DEFUSR=&H9000
30 A$=USR(STRING$(12,"!"))
40 PRINT A$
50 B$=STRING$(9,"X")
60 PRINT A$
```

一見すると、渡された文字列はA$に正しく代入されているように見えます。しかし、60行目に到達すると、その後のB$への文字列代入によってA$が破損していることが明らかになります。これは、渡されたパラメータに割り当てられた一時記憶領域が、制御がユーザールーチンに移る前に文字列記憶領域から回収されたためです。この領域はその後、B$に属する文字列の格納に使用され、A$が変更されました。

この状況は、事前にパラメータを変数に割り当ててから変数を渡すことで回避できます。次に例を示します。

```
10 A$=STRING$(12,"!")
20 A$=USR(A$)
```

10行目では、文字列ストレージ領域の12バイトがA$に永続的に割り当てられます。ユーザー関数が実行されると、レジスタペアDEが指すディスクリプタに、結果を格納する12バイト領域の開始アドレスが格納されます。返される文字列が渡された文字列よりも短い場合、ディスクリプタの長さバイトは副作用なく変更できます。文字列ストレージの詳細については、ガベージコレクタ([66B6H](#66b6h))を参照してください。

注目すべき点は、機械語プログラムをロードする前に「`CLEAR`」操作が必ずしも必要ではないということです。配列記憶領域の先頭とZ80スタックのベースとの間の領域は、インタープリタによって使用されることはありません。この領域にプログラムを配置できるのは、2つの領域が重ならない限りです。

<a name="500eh"></a><a name="defusr"></a>

    Address... 500EH

これは「`DEFUSR`」文ハンドラです。ユーザー番号はプログラムテキストから直接取得されます（式として扱うことはできません）。[USRTAB](#usrtab) 内の対応するエントリは (4FF4H) に配置されます。その後、アドレスオペランドが評価され ([542FH](#542fh))、[USRTAB](#usrtab) に格納されます。

<a name="501dh"></a><a name="def fn"></a>

    Address... 501DH

これは「`DEF FN`」および「`DEFUSR`」文ハンドラです。後続の文字が「`USR`」トークン（DDH）の場合、制御は「`DEFUSR`」文ハンドラ（[500EH](#500eh)）に移ります。そうでない場合は、プログラムテキストの末尾に「`FN`」トークン（DEH）があるかどうかがチェックされます。関数名変数が（[51A1H](#51a1h)）検索され、インタープリタがプログラムモード（[5193H](#5193h)）であることを確認した後、現在のプログラムテキスト位置がそこに配置されます。次に、仮パラメータリスト内の各変数が順に検索されます（[5EA4H](#5ea4h)）。これは、変数が確実に作成されるようにするためです。関数本体はこの時点では不要なため、ルーチンは文の残りの部分をスキップして終了します（[485BH](#485bh)）。

<a name="5040h"></a>

    Address... 5040H

このルーチンは、Factor Evaluator によって「`FN`」関数を適用するために使用されます。まず関数名変数 ([51A1H](#51a1h)) が検索され、プログラムテキスト内の関数定義のアドレスが取得されます。関数定義内の各仮変数 ([5EA4H](#5ea4h)) が順に検索され、そのアドレスが Z80 スタックにプッシュされます。各仮変数が見つかるたびに、対応する実パラメータ ([4C64H](#4c64h)) が評価され、スタックにプッシュされます。必要に応じて、実パラメータの型は仮パラメータ (517AH) の型と一致するように変換されます。

両方のリストが使い果たされると、各仮変数アドレスと実パラメータが順にスタックからポップされます。次に、各変数は変数ストレージ領域から [PARM2](#parm2) にコピーされ、その値が実パラメータに置き換えられます。 [PARM2](#parm2) は 100 バイト長しかないため、最大 9 個の倍精度パラメータが許可されることに注意してください。すべての実パラメータが [PARM2](#parm2) にコピーされると、[PARM1](#parm1) (現在のパラメータ領域) の内容全体が Z80 スタックにプッシュされ、[PARM2](#parm2) が [PARM1](#parm1) (518EH) にコピーされます。次に、レジスタ ペア HL がプログラム テキスト内の関数本体の先頭に設定され、式が評価されます ([4C5FH](#4c5fh))。 [PARM1](#parm1) の古い内容がスタックからポップされ、復元されます。最後に、評価の結果は、必要に応じて関数名の型 (517AH) と一致するように型変換されます。

ユーザー定義関数は、通常の式と 1 つの点のみ異なります。それは、独自のローカル変数セットを持つことです。これらの変数は、関数が呼び出されたときに [PARM1](#parm1) に作成され、関数が終了すると消えます。式評価によって通常の変数検索が開始されると、検査される領域は変数ストレージ領域です。ただし、[NOFUNS](#nofuns) が 0 以外で、少なくとも 1 つのアクティブなユーザー関数があることを示す場合は、代わりに [PARM1](#parm1) が検索され、これが失敗した場合にのみ、検索は変数ストレージ領域のグローバル変数に移ります。関数の各呼び出しに固有のローカル変数領域を使用するということは、変数が互いに上書きされたり、グローバル変数が上書きされたりすることなく、全体で同じ変数名を使用できることを意味します。

ユーザー定義関数は、インライン式やサブルーチンよりも遅いことに注意してください。関数名変数を見つけるための検索と、大量のスタックとデスタックは、大きなオーバーヘッドとなります。

<a name="5189h"></a>

    Address... 5189H

このルーチンは、レジスタ ペア DE が指すアドレスからレジスタ ペア HL が指すアドレスにメモリ ブロックを移動します。レジスタ ペア BC は長さを定義します。

<a name="5193h"></a>

    Address... 5193H

このルーチンは、[CURLIN](#curlin) がインタープリタがダイレクト モードであることを示す場合、「`Illegal direct`」エラーを生成します。

<a name="51a1h"></a>

    Address... 51A1H

このルーチンは、プログラムテキスト中に「`FN`」トークン（DEH）が存在するかどうかを確認し、関数名変数（5EA9H）を作成します。これらの変数は、変数名の先頭文字のビット7がセットされていることにより、通常の変数と区別されます。

<a name="51adh"></a>

    Address... 51ADH

文の先頭にD8Hより大きいトークンが見つかった場合、Runloop実行ポイント([4640H](#4640h))からこのルーチンに制御が移ります。トークンがFFHで始まる関数トークンでない場合は、「`構文エラー`」が生成されます([4055H](#4055h))。関数トークンが文としても機能するものの1つである場合は、制御が関連するハンドラに移り、それ以外の場合は「`構文エラー`」が生成されます。問題となる文は、「`MID$`」([696EH](#696eh))、「`STRIG`」([77BFH](#77bfh))、「`INTERVAL`」([77B1H](#77b1h))です。実際には「`INTERVAL`」には個別のトークンはなく、「`INT`」トークン(85H)で十分であり、残りの文字は文ハンドラによってチェックされます。

<a name="51c9h"></a><a name="width"></a>

    Address... 51C9H

これは「`WIDTH`」文ハンドラです。オペランドが評価され（521CH）、その大きさがチェックされます。オペランドが0、または32もしくは40（[OLDSCR](#oldscr)に保持されている画面モードに応じて）より大きい場合、「`不正な関数呼び出し`」エラーが生成されます（475AH）。オペランドが[LINLEN](#linlen)の現在の内容と同じ場合、ルーチンはそれ以上の処理を行わずに終了します。それ以外の場合、画面を小さくする必要がある場合は、[OUTDO](#outdo)標準ルーチンを介してFORMFEED制御コード（0CH）で現在の画面をクリアします。その後、オペランドは[LINLEN](#linlen)に格納され、[OLDSCR](#oldscr)に保持されている画面モードに応じて[LINL32](#linl32)または[LINL40](#linl40)に格納されます。画面が大きくなっている場合は、再度クリアされます。変更する行長変数は[SCRMOD](#scrmod)ではなく[OLDSCR](#oldscr)によって選択されるため、画面が[グラフィックモード](#graphics_mode)または[マルチカラーモード](#multicolour_mode)であっても、行幅を変更できます。この場合、変更はインタープリタのメインループに戻ったとき、または「`INPUT`」文が実行されたときに有効になります。

<a name="520eh"></a>

    Address... 520EH

このルーチンは、プログラムテキスト内の次の式 ([4C64H](#4c64h)) を評価し、それを整数 ([2F8AH](#2f8ah)) に変換し、結果をレジスタペア DE に格納します。その後、MSB の絶対値と符号がテストされ、ルーチンは終了します。

<a name="521bh"></a>

    Address... 521BH

このルーチンは、プログラムテキスト内の次のオペランド ([4C64H](#4c64h)) を評価し、それを整数 (5212H) に変換します。オペランドが255より大きい場合、「`不正な関数呼び出し`」エラー (475AH) が生成されます。

<a name="5229h"></a><a name="llist"></a>

    Address... 5229H

これは「`LLIST`」ステートメント ハンドラです。[PRTFLG](#prtflg) は 01H に設定され、出力がプリンタに送られ、制御は「`LIST`」ステートメント ハンドラに移ります。

<a name="522eh"></a><a name="リスト"></a>

    Address... 522EH

これは「`LIST`」文ハンドラです。オプションの開始行番号オペランドと終了行番号オペランドが収集され、プログラムテキスト内の開始位置([4279H](#4279h))が特定されます。終了リンクが見つかるか、Ctrl-Stopキーが押されるか、終了行番号に達するまで、プログラム行が順次リストアップされ、その後、制御はメインループの「`OK`」ポイント([411FH](#411fh))に直接移ります。各プログラム行は、行番号([3412H](#3412h))、トークン化解除([5284H](#5284h))、行自体の表示(527BH)、CR,LF(7328H)の順にリストアップされます。

<a name="5284h"></a>

    Address... 5284H

このルーチンは、「`LIST`」文ハンドラによって使用され、トークン化されたプログラム行をテキスト形式に変換します。開始時にレジスタペアHLはトークン化された行の先頭文字を指します。終了時にテキスト行は[BUF](#buf)に格納され、ゼロバイトで終端されます。

通常トークンまたはFFHで始まるトークンは、3A72Hのテーブルにあるトークンの単純な線形検索によって、対応するキーワードに変換されます。ただし、開始引用符文字、"`REM`"トークン、または"`DATA`"トークンが既に見つかった場合は例外となります。通常、これらのトークンの後にはプレーンテキストが続くため、グラフィック文字がトークンとして解釈されないようにチェックが行われます。3バイトシーケンスの ":" (3AH)、"`REM`"トークン (8FH)、" "トークン (E6H) は単一の " " 文字 (27H) に変換され、"`ELSE`"トークン (A1H) の前のステートメント区切り文字 (3AH) は削除されます。

数値トークンのいずれかが見つかった場合、その値と型はまず[CONLO](#conlo)と[CONTYP](#contyp)から[DAC](#dac)と[VALTYP](#valtyp)([46E8H](#46e8h))にコピーされます。その後、10進数([3425H](#3425h))、8進数([371EH](#371eh))、または16進数([3722H](#3722h))の変換ルーチンによって[FBUFFR](#fbuffr)内のテキスト形式に変換されます。8進数と16進数の場合、数値の前にアンパサンドと文字「`O`」または「`H`」が付きます。型サフィックス「'」または「#」は、小数部と指数部がない場合にのみ、単精度または倍精度の数値に追加されます (「`E`」または「`D`」)。

<a name="53e2h"></a><a name="削除"></a>

    Address... 53E2H

これは「`DELETE`」文のハンドラです。オプションの開始行番号と終了行番号のオペランドが収集され、プログラムテキスト内の開始位置が検索されます ([4279H](#4279h))。プログラムテキスト内にポインタが存在する場合は、行番号 (54EAH) に変換されます。終了行はプログラムテキスト ([4295H](#4295h)) を検索することで検索されます。このアドレスが開始行のアドレスよりも小さい場合は「`Illegal function call`」エラー (475AH) が生成され、それ以外の場合は「`OK`」メッセージが表示されます ([6678H](#6678h))。終了行の末尾から変数記憶領域の先頭までのメモリブロックが開始行の先頭にコピーされ、[VARTAB](#vartab)、[ARYTAB](#arytab)、[STREND](#strend) がプログラムテキストの新しい（下側の）末尾にリセットされます。その後、制御はメインループの末尾（4237H）に直接移り、残りのポインタをリセットし、プログラムテキスト領域を再リンクします。制御が通常の「`OK`」ポイントに戻らないため、画面はテキストモードに戻らないことに注意してください。「`DELETE`」が実行された際に画面が[グラフィックモード](#graphics_mode)または[マルチカラーモード](#multicolour_mode)になっている場合（これはあまり考えられませんが）、システムがクラッシュします。

<a name="541ch"></a>

    Address... 541CH

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`PEEK`」関数を適用するために使用されます。オペランドのアドレス([5439H](#5439h))がチェックされ、メモリからバイトが読み出され、整数(4FCFH)として[DAC](#dac)に格納されます。

<a name="5423h"></a><a name="poke"></a>

    Address... 5423H

これは「`POKE`」文ハンドラです。アドレスオペランドが評価され（[542FH](#542fh)）、次にデータオペランドが評価され（521CH）、メモリに書き込まれます。

<a name="542fh"></a>

    Address... 542FH

このルーチンはプログラムテキスト内の次のオペランド([4C64H](#4c64h))を評価し、それをレジスタペアDEに整数([5439H](#5439h))として配置します。

<a name="5439h"></a>

    Address... 5439H

このルーチンは、[DAC](#dac) に含まれる数値オペランドをレジスタペア HL の整数に変換します。オペランドは -32768 から +65535 の範囲でなければならず、通常は「`POKE`」、「`PEEK`」、「`BLOAD`」などで要求されるアドレスです。オペランドの型はまず [GETYPR](#getypr) 標準ルーチンによってチェックされ、既に整数である場合はレジスタペア HL ([2F8AH](#2f8ah)) に格納されます。オペランドが単精度または倍精度の場合、符号がチェックされ、負の場合は整数 ([2F8AH](#2f8ah)) に変換されます。それ以外の場合は単精度 ([2FB2H](#2fb2h)) に変換され、その絶対値 ([2F21H](#2f21h)) がチェックされます。 32767より大きく65536より小さい場合は、整数([2F8AH](#2f8ah))に変換する前に-65536が加算されます([324EH](#324eh))。

<a name="5468h"></a><a name="renum"></a>

    Address... 5468H

これは「`RENUM`」文ハンドラです。新しい初期行番号オペランドが存在する場合は、それが収集されます ([475FH](#475fh))。存在しない場合は、デフォルト値の10が使用されます。古い初期行番号オペランドが存在する場合は、それが収集されます ([475FH](#475fh))。存在しない場合は、デフォルト値の0が使用されます。増分行番号オペランドが存在する場合は、それが収集されます (4769H)。存在しない場合は、デフォルト値の10が使用されます。

次に、プログラムテキスト内で、新しい初期行番号 ([4295H](#4295h)) と古い初期行番号 ([4295H](#4295h)) と等しいかそれより大きい既存の行番号を検索します。新しいアドレスが古いアドレスよりも小さい場合、「`不正な関数呼び出し`」エラー (475AH) が生成されます。これは、上位のプログラム行を既存の下位の行に合わせて番号変更しようとする試みを捕捉するためです。

まず、プログラムテキストのダミー再番号付け実行が実行され、65529より大きい値を持つ新しい行番号が生成されないことを確認します。これは、変換の途中でエラーが発生するとプログラムテキストが混乱状態になるため、必ず実行する必要があります。すべてが正常であると仮定すると、プログラムテキスト内の行番号オペランドはすべてポインタに変換されます（[54F6H](#54f6h)）。これにより、再番号付け中にプログラムテキストが移動しないため、例えば「GOTO 50」のような行番号参照の問題が適切に解決されます。以前の初期プログラムテキスト位置から開始し、既存の各プログラム行番号が新しい値に置き換えられます。終了リンクに到達すると、プログラムテキストポインタはすべて行番号オペランド（54F1H）に再変換され、制御はメインループの「`OK`」ポイント（411EH）に直接移ります。

<a name="54f6h"></a>

    Address... 54F6H

54F6Hから入ると、このルーチンはプログラムテキスト内のすべての行番号オペランドをポインタに変換します。54F7Hから入ると、逆の操作を実行し、プログラムテキスト内のすべてのポインタを行番号オペランドに戻します。プログラムテキスト領域の先頭から開始し、モードに応じて各行でポインタトークン（0DH）または行番号オペランドトークン（0EH）が調べられます。ポインタから行番号オペランドへのモードでは、ポインタは参照先のプログラム行の行番号に置き換えられ、トークンは0EHに変更されます。行番号オペランドからポインタへのモードでは、プログラムテキストが検索され（[4295H](#4295h)）、該当する行が見つかります。行番号オペランドは行番号オペランドに置き換えられ、トークンは0DHに変更されます。検索に失敗した場合は、「`NNNN内の未定義行NNNN`」という形式のメッセージが表示され（[6678H](#6678h)）、変換処理が続行されます。 「`ON ERROR GOTO 0`」文については、誤ったエラーメッセージの生成を防ぐための特別なチェックが行われますが、「`RESUME 0`」文については同様のチェックは行われません。この場合、エラーメッセージが表示されますが、無視してください。

<a name="555ah"></a>

    Address... 555AH

これは、ゼロ バイトで終了するプレーン テキスト メッセージ「`Undefined line `」です。

<a name="558ch"></a><a name="synchr"></a>

```
Address... 558CH
Name...... SYNCHR
Entry..... HL points to character to check
Exit...... A=Next program character
Modifies.. AF, HL
```

レジスタペアHLにアドレスが指定された現在のプログラムテキスト文字を参照文字と比較する標準ルーチン。参照文字は、`CALL` または `RST` 命令の直後に1バイトとして提供されます。例:

```
RST 08H
DEFB ","
```

文字が一致しない場合は「`構文エラー`」が生成されます([4055H](#4055h))。それ以外の場合は、次のプログラム文字を取得するために制御が[CHRGTR](#chrgtr)標準ルーチンに移行します([4666H](#4666h))。

<a name="5597h"></a><a name="getypr"></a>

```
Address... 5597H
Name...... GETYPR
Entry..... なし
Exit...... AF=Type
Modifies.. AF
```

次のように、[VALTYP](#valtyp) によって決定される現在のオペランドの型を返す標準ルーチン:

```
整数 ..... A=FFH、フラグM、NZ、C
文字列 ... A=00H、フラグP、Z、C
単精度 ... A=01H、フラグ P、NZ、C
倍精度 ... A=05H、フラグ P、NZ、NC
```

</a>

<a name="55a8h"></a><a name="電話"></a>

    Address... 55A8H

これは「`CALL`」ステートメントハンドラです。拡張ステートメント名は、最大15文字の引用符なし文字列で、「(」、「:」、または行末文字(00H)で終了し、まずプログラムテキストから[PROCNM](#procnm)にコピーされます。未使用バイトはゼロで埋められます。次に、[SLTATR](#sltatr)の各エントリのビット5を調べて、ステートメントハンドラを含む拡張ROMを検索します。適切なROMが見つかった場合、[SLTATR](#sltatr)内のその位置は、レジスタAのスロットIDとレジスタHのROMベースアドレス([7E2AH](#7e2ah))に変換されます。ステートメントハンドラのアドレスは、ROMの4番目と5番目のアドレス([7E1AH](#7e1ah))から読み出され、レジスタペアIXに格納されます。スロットIDはレジスタペアIYの上位バイトに格納され、ROMステートメントハンドラは[CALSLT](#calslt)標準ルーチンを介して呼び出されます。

ROMは文名を調べ、認識できない場合はフラグCを返し、認識できる場合は必要な処理を実行します。ROM呼び出しが失敗した場合、[SLTATR](#sltatr)の検索はテーブルが尽きるまで継続され、テーブルが尽きると「`構文エラー`」([4055H](#4055h))が生成されます。ROM呼び出しが成功した場合、ハンドラは終了します。

<a name="55f8h"></a>

    Address... 55F8H

このルーチンは、プログラム テキストで見つかったデバイス名を認識できない場合に、デバイス名パーサー ([6F15H](#6f15h)) によって使用されます。エントリ時に、レジスタ ペア HL は名前の最初の文字を指し、レジスタ B はその長さを保持します。名前は最初に [PROCNM](#procnm) にコピーされ、ゼロ バイトで終了します。次に、[SLTATR](#sltatr) の各エントリのビット 6 で、デバイス ハンドラーを含む拡張 ROM が調べられます。適切な ROM が見つかった場合、[SLTATR](#sltatr) 内での位置が、レジスタ A のスロット ID とレジスタ H ([7E2AH](#7e2ah)) の ROM ベース アドレスに変換されます。デバイス ハンドラーのアドレスは、ROM 位置 6 と 7 ([7E1AH](#7e1ah)) から読み取られ、レジスタ ペア IX に配置されます。スロット ID はレジスタ ペア IY の上位バイトに配置され、不明なデバイス コード (FFH) はレジスタ A に配置され、ROM デバイス ハンドラーは [CALSLT](#calslt) 標準ルーチンを介して呼び出されます。

ROMはデバイス名を調べ、認識できない場合はフラグCを返し、認識できた場合は0から3までの内部コードを返します。ROM呼び出しが失敗した場合、[SLTATR](#sltatr)の検索はテーブルが尽きるまで続けられ、尽きると「`Bad file name`」エラー（[6E6BH](#6e6bh)）が生成されます。ROM呼び出しが成功した場合、ROMの内部コードが[SLTATR](#sltatr)の位置に追加され、4倍されてグローバルデバイスコードが生成されます。[SLTATR](#sltatr)の各エントリのベースコードは、以下に16進数で示されています。「SS」と「PS」のマーカーは、対応するセカンダリスロット番号とプライマリスロット番号を示しており、各スロットは4ページで構成されています。

<a name="figure44"></a>![][CH05F44]

**図44:** デバイスコード

グローバルデバイスコードは、ROMが実際のデバイス操作を実行するまで、インタープリタによって使用されます。その後、ROMのスロットID、ベースアドレス、および内部デバイスコードに変換され、ROMアクセスが実行されます。0から8までのコードはディスクドライブ識別子用に予約されており、FCHからFFHまでのコードは標準デバイス（GRP、CRT、LPT、CAS）用に予約されていることに注意してください。現在のMSXハードウェア構造では、これらのコードは物理的に不可能なROM構成に対応するため、インタープリタが特定の目的に使用するのに安全です。

<a name="564ah"></a>

    Address... 564AH

このルーチンは、関数ディスパッチャ ([6F8FH](#6f8fh)) が標準デバイスに属さないデバイスコードを検出したときに使用されます。デバイスコードはまず [SLTATR](#sltatr) の位置に変換され、次にレジスタ A のスロット ID とレジスタ H (7E2DH) の ROM ベースアドレスに変換されます。ROM デバイスハンドラのアドレスは、ROM の 6 番目と 7 番目の位置 ([7E1AH](#7e1ah)) から読み取られ、レジスタペア IX に格納されます。スロット ID はレジスタペア IY の上位バイトに格納され、ROM の内部デバイスコードは DEVICE に格納され、ROM デバイスハンドラは [CALSLT](#calslt) 標準ルーチンによって呼び出されます。

<a name="566ch"></a>

    Address... 566CH

マクロ言語パーサーへのこのエントリポイントは「`DRAW`」ステートメントハンドラーによって使用され、後のエントリポイント([56A2H](#56a2h))は「`PLAY`」ステートメントハンドラーによって使用されます。コマンド文字列は評価され([4C64H](#4c64h))、そのストレージは解放されます([67D0H](#67d0h))。ゼロ終端ブロックをZ80スタックにプッシュした後、文字列本体の長さとアドレスが[MCLLEN](#mcllen)と[MCLPTR](#mclptr)に格納され、制御はパーサーのメインループに移ります。

<a name="56a2h"></a>

    Address... 56A2H

これはマクロ言語パーサーのメインループで、「`DRAW`」または「`PLAY`」ステートメントに関連付けられたコマンド文字列を処理するために使用されます。エントリ時には、文字列の長さは[MCLLEN](#mcllen)、文字列のアドレスは[MCLPTR](#mclptr)、関連するコマンドテーブルのアドレスは[MCLTAB](#mcltab)に格納されます。コマンドテーブルには、各ステートメントの有効なコマンド文字と、関連するコマンドハンドラーアドレスが含まれています。「`DRAW`」テーブルは5D83H、「`PLAY`」テーブルは752EHにあります。

パーサーのメインループはまず、コマンド文字列 ([56EEH](#56eeh)) から次の文字を取得します。文字が残っていない場合は、次の文字列ディスクリプタがスタック (568CH) からポップされます。この値がゼロの場合、[MCLFLG](#mclflg) で「`DRAW`」文がアクティブであることが示されていればパーサーは終了し (5709H)、それ以外の場合は「`PLAY`」文ハンドラ (7494H) に制御が移ります。

コマンド文字が存在すると仮定すると、現在のコマンドテーブルが検索され、その正当性がチェックされます。一致するものが見つからない場合は、「`不正な関数呼び出し`」エラー（475AH）が生成されます。次に、コマンドテーブルのエントリが調べられます。ビット7が設定されている場合、コマンドはオプションの数値パラメータを取ります。このパラメータが存在する場合は収集され、レジスタペアDE（571CH）に格納されます。存在しない場合は、デフォルト値の1が使用されます。パーサーのメインループの先頭へのリターンをZ80スタックにプッシュした後、制御はコマンドテーブルから取得したアドレスにあるコマンドハンドラーに移ります。

<a name="56eeh"></a>

    Address... 56EEH

このルーチンは、マクロ言語パーサーによってコマンド文字列から次の文字を取得するために使用されます。[MCLLEN](#mcllen)がゼロの場合、ルーチンはフラグZで終了し、文字は残っていません。それ以外の場合、[MCLPTR](#mclptr)に格納されているアドレスから次の文字が取得され、レジスタAに返されます。文字が小文字の場合は大文字に変換されます。その後、[MCLPTR](#mclptr)がインクリメントされ、[MCLLEN](#mcllen)がデクリメントされます。

<a name="570bh"></a>

    Address... 570BH

このルーチンは、マクロ言語パーサーによって使用され、コマンド文字列に不要な文字を返します。[MCLLEN](#mcllen) が増分され、[MCLPTR](#mclptr) が減分されます。

<a name="5719h"></a>

    Address... 5719H

このルーチンは、マクロ言語パーサーによってコマンド文字列から数値パラメータを収集するために使用されます。結果は符号付き整数でレジスタペア DE に返されます。式は指定できません。最初の文字を取得して検査し、それが「+」の場合は無視して次の文字 ([5719H](#5719h)) を取得します。「-」の場合は、否定ルーチン (5795H) に戻り、次の文字 ([5719H](#5719h)) を取得します。「=」の場合は、次の変数の値 ([577AH](#577ah)) を返します。それ以外の場合は、連続する文字を取得し、数値以外の文字が見つかるまでバイナリ積を累積します。

<a name="575ah"></a>

    Address... 575AH

このルーチンは、マクロ言語パーサーの「=」および「X」ハンドラーによって使用されます。変数名は「;」区切り文字が見つかるまで[BUF](#buf)にコピーされます。「;」区切り文字が見つかるまで39文字以上かかる場合は、「`不正な関数呼び出し`」エラー(475AH)が生成されます。それ以外の場合は、制御は因子評価変数ハンドラー([4E9BH](#4e9bh))に移り、変数の内容が[DAC](#dac)に返されます。

<a name="577ah"></a>

    Address... 577AH

このルーチンは、マクロ言語パーサーがコマンドパラメータ内の「=」文字を処理するために使用されます。変数の値([575AH](#575ah))が取得され、整数([2F8AH](#2f8ah))に変換されてレジスタペアDEに格納されます。

<a name="5782h"></a>

    Address... 5782H

このルーチンは、マクロ言語パーサーが「X」コマンドを処理するために使用されます。変数が処理され（[575AH](#575ah)）、スタック領域が利用可能かどうかが確認された後（[625EH](#625eh)）、現在の[MCLLEN](#mcllen)と[MCLPTR](#mclptr)の内容がスタックされます。その後、制御はパーサーのエントリポイント（5679H）に移り、変数のディスクリプタが取得され、新しいコマンド文字列が処理されます。

<a name="579ch"></a>

    Address... 579CH

このルーチンは、プログラムテキスト内の座標ペアを評価するために、様々なグラフィックスステートメントで使用されます。座標は括弧で囲み、各要素オペランドをカンマで区切る必要があります。座標ペアの前に「`STEP`」トークン (DCH) が付いている場合は、各要素の値が [GRPACX](#grpacx) および [GRPACY](#grpacy) 内の現在のグラフィックス座標の対応する要素に加算されます。そうでない場合は、絶対値が返されます。X座標は [GRPACX](#grpacx)、[GXPOS](#gxpos)、およびレジスタペア BC に返されます。Y座標は [GRPACY](#grpacy)、[GYPOS](#gypos)、およびレジスタペア DE に返されます。

このルーチンには2つのエントリポイントがあり、どちらが使用されるかは、呼び出し元が複数の座標ペアを期待しているかどうかによって異なります。例えば、「`LINE`」ステートメントは2つの座標ペアを期待しており、最初の座標ペアの方が柔軟性が高いです。579CHのエントリポイントは最初の座標ペアを取得するために使用され、現在のグラフィックス座標を表す文字として「-」または「@-」を受け入れます。57ABHのエントリポイントは2番目の座標ペアを取得するために使用され、明示的なオペランドが必要です。

<a name="57e5h"></a><a name="プリセット"></a>

    Address... 57E5H

これは「`PRESET`」文のハンドラです。現在の背景色は[BAKCLR](#bakclr)から取得され、制御は「`PSET`」ハンドラに渡されます。

<a name="57eah"></a><a name="pset"></a>

    Address... 57EAH

これは「`PSET`」ステートメントハンドラです。座標ペアが評価された後（57ABH）、現在の前景色が[FORCLR](#forclr)から取得され、インク色を設定する際のデフォルトとして使用されます（[5850H](#5850h)）。現在のグラフィックス座標は、[SCALXY](#scalxy)および[MAPXYC](#mapxyc)標準ルーチンを介して物理アドレスに変換され、[SETC](#setc)標準ルーチンを介して現在のピクセルの色が設定されます。

<a name="5803h"></a>

    Address... 5803H

このルーチンは、Factor Evaluatorによって「`POINT`」関数を適用するために使用されます。[CLOC](#cloc)、[CMASK](#cmask)、[GYPOS](#gypos)、[GXPOS](#gxpos)、[GRPACY](#grpacy)、[GRPACX](#grpacx) の現在の内容がスタックされ、座標ペアのオペランドが評価されます (57ABH)。新しいピクセルの色は、[SCALXY](#scalxy)、[MAPXYC](#mapxyc)、[READC](#readc) 標準ルーチンを介して読み取られ、[DAC](#dac) に整数 (2F99H) として格納されます。その後、以前の座標値がポップされ、復元されます。ポイント座標が画面外にある場合は、-1 が返されることに注意してください。

<a name="5850h"></a>

    Address... 5850H

このグラフィックスルーチンは、プログラムテキスト内の任意のカラーオペランドを評価し、それを現在のインク色に設定するために使用されます。画面モード([59BCH](#59bch))をチェックした後、カラーオペランドが評価され(521CH)、[ATRBYT](#atrbyt)に格納されます。オペランドが存在しない場合は、レジスタAに指定されたカラーコードが代わりに[ATRBYT](#atrbyt)に格納されます。

<a name="5871h"></a>

    Address... 5871H

このグラフィックスルーチンは、[GXPOS](#gxpos) とレジスタペア BC の内容の差をレジスタペア HL に返します。結果が負数 ([GXPOS](#gxpos)\<BC) の場合、絶対値を生成するために符号反転され、フラグ C が返されます。

<a name="5883h"></a>

    Address... 5883H

このグラフィックスルーチンは、[GYPOS](#gypos) とレジスタペア DE の内容の差をレジスタペア HL に返します。結果が負数 ([GYPOS](#gypos)\<DE) の場合、絶対値を生成するために符号反転され、フラグ C が返されます。

<a name="588eh"></a>

    Address... 588EH

このグラフィックス ルーチンは、[GYPOS](#gypos) とレジスタ ペア DE の内容を交換します。

<a name="5898h"></a>

    Address... 5898H

このグラフィックスルーチンは、まず[GYPOS](#gypos)とレジスタペアDE([588EH](#588eh))の内容を入れ替え、次に[GXPOS](#gxpos)とレジスタペアBCの内容を入れ替えます。589BHで実行された場合は、2番目の操作のみが実行されます。

<a name="58a7h"></a><a name="line"></a>

    Address... 58A7H

これは「`LINE`」文ハンドラです。最初の座標ペア (X1,Y1) が評価され ([579CH](#579ch))、レジスタペア BC,DE に格納されます。「-」トークン (F2H) をチェックした後、2 番目の座標ペア (X2,Y2) が評価され (57ABH)、[GRPACX](#grpacx)、[GRPACY](#grpacy)、[GXPOS](#gxpos)、[GYPOS](#gypos) に格納されます。インク色 (584DH) を設定した後、プログラムテキストに続く「B」または「BF」オプションがチェックされ、ボックス ([5912H](#5912h))、ボックスフィル ([58BFH](#58bfh))、または線描画 ([58FCH](#58fch)) のいずれかの操作が実行されます。これらの操作はいずれも [GRPACX](#grpacx) および [GRPACY](#grpacy) の現在のグラフィック座標には影響せず、X2、Y2 のままになります。

<a name="58bfh"></a>

    Address... 58BFH

このルーチンはボックスフィル操作を実行します。指定された座標ペアはボックスの対角点を定義するため、それらから2つの値を導出する必要があります。ボックスの水平方向のサイズはX1とX2の差から得られ、これにより1行あたりに設定するピクセル数が決定されます。垂直方向のサイズはY1とY2の差から得られ、これにより必要な行数が決定されます。X1,Y1の物理アドレスから開始し、[DOWNC](#downc)標準ルーチンを介して順次下位に移動し、[NSETCX](#nsetcx)標準ルーチンを繰り返し使用することで、必要な数のピクセル行が埋められます。

<a name="58fch"></a>

    Address... 58FCH

このルーチンは線描画操作を実行します。線 ([593CH](#593ch)) を描画した後、[GXPOS](#gxpos) と [GYPOS](#gypos) は、[GRPACX](#grpacx) と [GRPACY](#grpacy) から X2,Y2 にリセットされます。

<a name="5912h"></a>

    Address... 5912H

このルーチンはボックス演算を実行します。ボックスは、4つのコーナーポイントそれぞれの間に直線 ([58FCH](#58fch)) を描くことで生成されます。各コーナーの座標は、初期オペランドの対応する要素を入れ替えることで得られます。描画シーケンスは以下のとおりです。

1. X1,Y2 to X2,Y2
2. X1,Y1 to X2,Y1
3. X2,Y1 to X2,Y2
4. X1,Y1 to X1,Y2

</a>

<a name="593ch"></a>

    Address... 593CH

このルーチンは、レジスタペアBCとDEに指定された点X1、Y1と、[GXPOS](#gxpos)と[GYPOS](#gypos)に指定された点X2、Y2を結ぶ直線を描画します。描画メインループ(5993H)の動作は、LINE(0,0)-(10,4)のような例で分かりやすく説明します。始点から終点まで直線を描画するには、水平方向に10ステップ(X2-X1)、下方向に4ステップ(Y2-Y1)を移動する必要があります。したがって、直線に最も近似するには、下方向に1ステップ(X2-X1/Y2-Y1)ごとに水平方向に2.5ステップが必要です。実際には整数ステップしか実行できないため、この比率は実現不可能ですが、平均的には正しい比率を実現できます。

採用されている方法は、右へ1ステップ進むごとにY方向の差をカウンタに加算するというものです。カウンタがX方向の差の値を超えるとカウンタはリセットされ、1ステップ下降します。これは実質的に、2つの差の値を整数で割る処理です。下降ステップは、右へ2ステップごとに発生する場合もあれば、3ステップごとに発生する場合もあります。しかし、平均すると、右へ2.5ステップごとに1ステップ下降します。比較のために、同等のBASICプログラムを以下に示します。BASICの行はわずかにオフセットされていますが、比較対象としています。

```
10 SCREEN 0
20 INPUT"START X,Y";X1,Y1
30 INPUT"END X,Y",X2,Y2
40 SCREEN 2
50 X=X1:Y=Y1:L=X2-X1:S=Y2-Y1:CTR=L/2
60 PSET(X,Y)
70 CTR=CTR+S:IF CTR<L THEN 90
80 CTR=CTR-L:Y=Y+1
90 X=X+1:IF X<=X2 THEN 60
100 LINE(X1,Y1+5)-(X2,Y2+5)
110 GOTO 110
```

上記の例には3つの制限があります。線は下向きに傾斜し、右向きに傾斜し、水平からの傾斜は45度を超えてはなりません（右向き1段につき下向き1段）。

このルーチンは、描画を開始する前にY1とY2の座標を調べることで、最初の制限を克服します。Y2がY1以上、つまり線が上向きまたは水平になることを示す場合、両方の座標ペアが交換されます。線は下向きになり、終点から始点に向かって描画されます。

2つ目の制限は、X1とX2を事前に調べて、直線の傾きを判断することで克服できます。X2がX1以上の場合、直線は右に傾き、描画メインループで使用するために[RIGHTC](#rightc)標準ルーチンへのZ80 JPが[MINUPD](#minupd)/[MAXUPD](#maxupd)（下記参照）に配置されます。それ以外の場合は、[LEFTC](#leftc)標準ルーチンへのJPがそこに配置されます。

3つ目の制限は、描画前にX座標の差とY座標の差を比較して傾斜の度合いを決定することで克服されます。X2-X1がY2-Y1より小さい場合、直線の傾斜は水平から45度未満です。上記で示したLINE(0,0)-(10,4)の単純な方法は、水平方向に1ステップ進むごとに1ステップ下降することで最大降下速度が得られるため、45度を超える傾斜には機能しません。ただし、ステップ方向を入れ替えれば機能します。例えば、LINE(0,0)-(4,10)では、2.5ステップ下降するごとに1ステップ右向きにする必要があります。[MINUPD](#minupd)は、描画メインループの「通常」ステップ方向標準ルーチンへのZ80 JPを保持し、[MAXUPD](#maxupd)は、「傾斜」ステップ方向標準ルーチンへのJPを保持します。浅い角度の場合、[MINUPD](#minupd) は [DOWNC](#downc) に、[MAXUPD](#maxupd) は [LEFTC](#leftc) または [RIGHTC](#rightc) にベクトル化されます。急な角度の場合、[MINUPD](#minupd) は [LEFTC](#leftc) または [RIGHTC](#rightc) に、[MAXUPD](#maxupd) は [DOWNC](#downc) にベクトル化されます。急な角度の場合、カウンターの値も交換する必要があり、X の差をカウンターに追加し、Y の差をカウンターの制限として使用する必要があります。変数 [MINDEL](#mindel) と [MAXDEL](#maxdel) は、これらのカウンター値を保持するために描画メインループによって使用されます。[MINDEL](#mindel) は小さい方の終点の差を保持し、[MAXDEL](#maxdel) は大きい方の終点の差を保持します。

興味深い点は、上記のプログラムではCTRに保持され、ROMではレジスタペアDEに保持されている参照カウンタが、ゼロに設定されるのではなく、最大終点差の半分がプリロードされていることです。これにより、行の最初の「階段」が行の始端と終端の2つのセクションに分割され、行の見栄えが良くなります。

<a name="59b4h"></a>

    Address... 59B4H

このグラフィックス ルーチンは、レジスタ ペア DE の内容を 1 ビット右にシフトします。

<a name="59bch"></a>

    Address... 59BCH

このルーチンは、画面が [グラフィック モード](#graphics_mode) または [マルチカラー モード](#multicolour_mode) でない場合、「`不正な関数呼び出し`」エラー (475AH) を生成します。

<a name="59c5h"></a><a name="ペイント"></a>

    Address... 59C5H

これは「`PAINT`」文ハンドラです。開始座標ペアが評価され([579CH](#579ch))、インクカラーセット(584DH)、およびオプションの境界色オペランドが評価され(521CH)、[BDRATR](#bdratr)に格納されます。開始座標ペアは画面内([5E91H](#5e91h))にあることが確認され、[MAPXYC](#mapxyc)標準ルーチンによって現在のピクセル物理アドレスに設定されます。次に、右側の境界までの距離が測定され([5ADCH](#5adch))、ゼロの場合、ハンドラは終了します。それ以外の場合は、左側の境界までの距離が測定され([5AEDH](#5aedh))、その2つの合計がゾーン幅としてレジスタペアDEに格納されます。現在の位置は2回スタックされ(5ACEH)、最初に終了フラグ(00H)、次に下方向フラグ(40H)がスタックされます。次に、制御はレジスタBの上方向フラグ(C0H)とともにペイントメインループ([5A26H](#5a26h))に移ります。

<a name="5a26h"></a>

    Address... 5A26H

これはペイントのメインループです。ゾーン幅はレジスタペア DE に、ペイント方向（上または下）はレジスタ B に保持され、現在のピクセル物理アドレスは左側の境界に隣接するピクセルの物理アドレスです。[TUPC](#tupc) または [TDOWNC](#tdownc) 標準ルーチンを介して次のラインに垂直ステップが実行され、右側の境界までの距離が測定されます ([5ADCH](#5adch))。次に、左側の境界までの距離が測定され、境界間の線が塗りつぶされます ([5AEDH](#5aedh))。どちらの境界の位置にも変化が見られない場合、制御はメインループの先頭に移り、同じ方向へのペイントが続行されます。変化が見られた場合、変化が発生したことを意味し、適切なアクションを実行する必要があります。

屈折には4つの種類があります。左手または右手の侵入型（該当する境界が内側に移動する）と、左手または右手の遠回り型（該当する境界が外側に移動する）です。以下に各種類の例を示します。番号付きの領域は、上向きの移動中に描画される順序を示しています。完全性を保つため、各屈折領域内に二次領域が表示されています。

<a name="figure45"></a>![][CH05F45]

**図45:** 境界の変曲点

左端境界までの距離が0以外の場合、左方向の逸脱が発生しています。現在のゾーン幅が前の行の幅よりも大きい場合、右方向の逸脱が発生しています。逸脱が2ピクセル未満の場合は無視されますが、現在の位置（図45のゾーン3の左下）がスタックされ（[5AC2H](#5ac2h)）、ペイント方向が反転され、逸脱領域の左上からペイントが再開されます。

現在のゾーン幅が前の行の幅よりも小さい場合、RH侵入が発生しています。侵入が完全である場合、つまり現在のゾーン幅が0の場合、行き止まりに達し、最後の位置と方向がポップされ(5AIFH)、その地点から描画が再開されます。そうでない場合、現在の位置と方向がスタックされ([5AC2H](#5ac2h))、侵入領域の左下から描画が再開されます。

LH 侵入は、右側の境界の検索中に自動的に処理され、ペイント メインループによる明示的なアクションは必要ありません。

<a name="5ac2h"></a>

    Address... 5AC2H

このルーチンは、「`PAINT`」文ハンドラによって使用され、現在のペイント位置と方向をZ80スタックに保存します。6バイトのパラメータブロックは、以下の要素で構成されます。

```
2 bytes ... Current contents of CLOC
1 byte  ... Current direction
1 byte  ... Current contents of CMASK
2 bytes ... Current zone width
```

パラメータがスタックされた後、十分なスタックスペースがまだ存在するかどうかのチェックが行われます([625EH](#625eh))。

<a name="5adch"></a>

    Address... 5ADCH

このルーチンは、「`PAINT`」文ハンドラによって右境界の位置を特定するために使用されます。前の行のゾーン幅は、レジスタペアDEに格納された[SCANR](#scanr)標準ルーチンに渡され、これにより、最初にスキップできる境界カラーピクセルの最大数が決定されます。返されたスキップカウントの残りは[SKPCNT](#skpcnt)に格納され、走査された境界以外のカラーピクセルの数は[MOVCNT](#movcnt)に格納されます。

<a name="5aedh"></a>

    Address... 5AEDH

このルーチンは、「`PAINT`」ステートメントハンドラによって左側の境界を特定するために使用されます。右側の境界検索の終点は一時的に保存され、開始点は[CSAVEA](#csavea)と[CSAVEM](#csavem)から取得され、現在のピクセル物理アドレスになります。次に、左側の境界は[SCANL](#scanl)標準ルーチンによって特定され、このルーチンは領域全体を塗りつぶします。そして、右側の終点が復元され、[CSAVEA](#csavea)と[CSAVEM](#csavem)に格納されます。

<a name="5b0bh"></a>

    Address... 5B0BH

このルーチンは、レジスタ ペア DE の内容を否定するために "`CIRCLE`" ステートメント ハンドラーによって使用されます。

<a name="5b11h"></a><a name="circle"></a>

    Address... 5B11H

これは「`CIRCLE`」ステートメントハンドラです。中心座標ペア ([579CH](#579ch)) を評価した後、半径 (520FH) が評価され、([325CH](#325ch)) に SIN(PI/4) が乗算されて [CNPNTS](#cnpnts) に格納されます。インク色 (584DH) が設定され、開始角度 ([5D17H](#5d17h)) が評価されて [CSTCNT](#cstcnt) に格納され、終了角度 ([5D17H](#5d17h)) が評価されて [CENCNT](#cencnt) に格納されます。終了角度が開始角度よりも小さい場合、2つの値が入れ替えられ、[CPLOTF](#cplotf) が非ゼロになります。アスペクト比が評価され([4C64H](#4c64h))、1より大きい場合はその逆数が取られ(3267H)、[CSCLXY](#csclxy)が0以外の値にされ、X軸の押し潰しを示します。アスペクト比は([325CH](#325ch))256倍され、整数([2F8AH](#2f8ah))に変換され、1バイトのバイナリ小数として[ASPECT](#aspect)に格納されます。レジスタHLとDEのペアは円周上の開始位置(X=RADIUS,Y=0)に設定され、制御は円のメインループに移行します。

<a name="5bbdh"></a>

    Address... 5BBDH

これが円のメインループです。円は対称性が高いため、0度から45度までの円弧の座標を計算するだけで済みます。残りの7つの線分は、これらの点の回転と鏡映によって生成されます。単位円の媒介変数方程式は、0度からπ/4までの角度をTとすると、次のようになります。

```
X=COS(T)
Y=SIN(T)
```

この方程式、または対応する関数形式 X=SQR(1-Y^2) を使用した直接計算は遅すぎるため、代わりに 1 次導関数が使用されます。

```
 dx
---- = -Y/X
 dy
```

開始位置が既知（X=半径、Y=0）であれば、微分を用いてY座標の単位変化に対するX座標の変化を計算できます。さらに、グラフィックスの解像度は1ピクセルに制限されているため、X座標の変化の合計が1に達した時点を把握し、その後X座標を減算するだけで済みます。したがって、

```
(Y1/X)+(Y2/X)+(Y3/X)+... => 1 のとき、X をデクリメントします。
したがって、(Y1+Y2+Y3+...)/X => 1 のときにデクリメントします。
したがって、Y1+Y2+Y3+... => X のときにデクリメントします。
```

X座標の変化を識別するために必要なのは、X座標値が指定された値を超えるまで、各ステップのY座標値を合計することだけです。円のメインループは、X座標をレジスタペアHLに、Y座標をレジスタペアDEに、そして累計を[CRCSUM](#crcsum)に保持します。任意の半径160ピクセルの円を表す同等のBASICプログラムは次のとおりです。

```
10 SCREEN 2
20 X=160:Y=0:CRCSUM=0
30 PSET(X,191-Y)
40 CRCSUM=CRCSUM+Y :Y=Y+1
50 IF CRCSUM<X THEN 30
60 CRCSUM=CRCSUM-X:X=X-1
70 IF X>Y THEN 30
80 CIRCLE(0,191),155
90 GOTO 90
```

メインループによって生成される座標ペアは「仮想」円の座標ペアであり、軸反射、楕円押し潰し、中心移動などのタスクはより低いレベルで処理されます ([5C06H](#5c06h))。

<a name="5c06h"></a>

    Address... 5C06H

このルーチンは、circleメインループで、レジスタHLとDEの座標ペアを画面上の8つの対称点に変換するために用いられます。まずY座標が反転され([5B0BH](#5b0bh))、X軸を中心に回転します。そして、時計回りに90度回転させて最初の4点を生成します(5C48H)。次にY座標が再び反転され([5B0BH](#5b0bh))、さらに4点が生成されます(5C48H)。

時計回りの回転は、X座標とY座標を交換し、新しいY座標を反転させることで実行されます。したがって、点(40,10)は(10,-40)になります。例えば、アスペクト比を0.5と仮定すると、8つの点の完全な配列は次のようになります。

1. X,-Y\*0.5
2. -Y,-X\*0.5
3. -X, Y\*0.5
4. Y, X\*0.5
5. Y,-X\*0.5
6. -X,-Y\*0.5
7. -Y, X\*0.5
8. X、Y\*0.5

上記から、座標の符号を一旦無視すると、関係する項は4つだけであることがわかります。したがって、各点に対して比較的時間のかかるアスペクト比の乗算 ([5CEBH](#5cebh)) を実行する代わりに、X\*0.5 と Y\*0.5 という項を事前に用意し、4つの項を入れ替えて反転させることで完全なシーケンスを生成できます。上記のアスペクト比では、初期条件としてレジスタペア HL=X、レジスタペア DE=-Y\*0.5、CXOFF=Y、CYOFF=X\*0.5 が設定され、以下の演算によって連続する点が生成されます。

1. HL と CXOFF を交換し、HL を否定します。
2. DE と CYOFF を交換し、DE を否定します。

各円座標の計算と並行して、その点を含む線分の始点に到達するために必要な点の数が [CPCNT8](#cpcnt8) に保持されます。この値は最初はゼロで、90度回転するごとに 2\*RADIUS\*SIN(PI/4) ずつ増加します。8つの点がそれぞれ生成されると、そのY座標値が [CPCNT8](#cpcnt8) の内容に加算され、開始角度と終了角度と比較されて適切な処理が決定されます。点が2つの角度の間にあり [CPLOTF](#cplotf) がゼロの場合、または点が2つの角度の外側にあり [CPLOTF](#cplotf) がゼロでない場合、座標は円中心座標 (5CDCH) と、標準ルーチン [SCALXY](#scalxy)、[MAPXYC](#mapxyc)、[SETC](#setc) によって設定された点に追加されます。点が2つの角度のいずれかに等しく、[CLINEF](#clinef)の対応するビットが設定されている場合、その座標が円の中心座標(5CDCH)に追加され、中心まで直線([593CH](#593ch))が引かれます。これらの条件のいずれにも該当しない場合は、次の点に進む以外の処理は行われません。

<a name="5cebh"></a>

    Address... 5CEBH

このルーチンは、レジスタペアDEに与えられた座標値と[ASPECT](#aspect)に含まれるアスペクト比を乗算し、結果をレジスタペアDEに返します。標準的なバイナリシフト加算方式が使用されますが、オーバーフローの問題を回避するため、この演算は2つのシングルバイト乗算として実行されます。

<a name="5d17h"></a>

    Address... 5D17H

このルーチンは、「`CIRCLE`」文ハンドラによって使用され、角度オペランドを円のメインループで必要な形式に変換します。結果はレジスタペアDEに返されます。この方法は基本的に正しく、角度ごとに三角関数の計算を1回行う必要がなくなりますが、生成される結果は不正確です。これは、円周上の真の30度点に線を引く次の例で確認できます。

```
10 SCREEN 2
20 PI = 4 * ATN(1)
30 CIRCLE(100,100),80,,PI/6
40 LINE(100,100)-(100+80*COS(PI/6),100-80*SIN(PI/6))
50 GOTO 50
```

ルーチンが生成する結果は、必要な角度に達するまでに円のメインループで生成する必要がある点の数です。これは、まず、必要な角度を含むセグメントの前に、INT(ANGLE/(PI/4)) 個の 45 度セグメントがあることに留意することで計算できます。さらに、各 45 セグメントには、終了 Y 座標の値である RADIUS\*SIN(PI/4) 個の点が含まれます。したがって、角度を含むセグメントの開始点に到達するために必要な点の数は、これら 2 つの数値の積になります。合計数は、この数値に、最終セグメント内の残りの角度をカバーするために必要な点の数、つまり RADIUS\*SIN(REMAINING ANGLE) 個を加算することで算出されます。

残念ながら、このルーチンは、連続する点が等しい角度を成すという誤った仮定に基づき、セグメント全体のサイズから線型近似によってセグメント内の点の数を計算します。そのため、上記の例では、角度に対して計算される点の数は、正しい値である40ではなく、30/45\*(80\*0.707107)=37となります。したがって、このルーチンによって生成される誤差は、45度セグメントの中心で最大となり、端点でゼロになります。

<a name="5d6eh"></a><a name="draw"></a>

    Address... 5D6EH

これは「`DRAW`」ステートメントハンドラです。レジスタペアDEは5D83Hのコマンドテーブルを指すように設定され、制御はマクロ言語パーサー([566CH](#566ch))に移ります。

<a name="5d83h"></a>

    Address... 5D83H

この表には、「`DRAW`」文のコマンドに有効なコマンド文字と対応するアドレスが記載されています。パラメータを取り、その結果表のビット7がセットされるコマンドには、アスタリスクが付けられています。

|CMD    |TO
|-------|-------
|U\*    |5DB1H
|D\*    |5DB4H
|L\*    |5DB9H
|R\*    |5DBCH
|M      |5DD8H
|E\*    |5DCAH
|F\*    |5DC6H
|G\*    |5DD1H
|H\*    |5DC3H
|A\*    |5E4EH
|B      |5E46H
|N      |5E42H
|X      |5782H
|C\*    |5E87H
|S\*    |5E59H

</a>

<a name="5db1h"></a>

    Address... 5DB1H

これは「`DRAW`」文の「`U`」コマンドハンドラです。「`D`」、「`L`」、「`R`」、「`E`」、「`F`」、「`G`」、および「`H`」コマンドの動作は非常に似ているため、それぞれのハンドラについては個別に説明しません。オプションの数値パラメータは、マクロ言語パーサによってレジスタペアDEに提供されます。この初期パラメータは、指定されたハンドラによってレジスタペアBCの水平オフセットとレジスタペアDEの垂直オフセットに変更されます。例えば、左または上方向の移動が必要な場合はパラメータが反転され（[5B0BH](#5b0bh)）、斜め方向の移動が必要な場合はパラメータが複製され、水平オフセットと垂直オフセットが等しくなります。オフセットが準備されると、制御は線描画ルーチン（5DFFH）に移ります。

<a name="5dd8h"></a>

    Address... 5DD8H

これは「`DRAW`」文の「`M`」コマンドハンドラです。コマンド文字に続く文字が検査され、次にコマンド文字列([5719H](#5719h))から2つのパラメータが収集されます。先頭文字が「+」または「-」の場合、パラメータはオフセットとみなされ、スケーリング([5E66H](#5e66h))され、[DRWANG](#drwang)によって決定される90度ステップで回転され、現在のグラフィックス座標(5CDCH)に加算されて終了点が決定されます。[DRWFLG](#drwflg)によって「`B`」モードが非アクティブであることが示される場合、現在のグラフィックス座標から終了点まで線が描画されます(5CCDH)。 [DRWFLG](#drwflg) が "`N`" モードが非アクティブであることを示している場合、終了座標が [GRPACX](#grpacx) と [GRPACY](#grpacy) に設定され、新しい現在のグラフィックス座標となります。最後に [DRWFLG](#drwflg) がゼロに設定され、 "`B`" モードと "`N`" モードがオフになり、ハンドラが終了します。

<a name="5e42h"></a>

    Address... 5E42H

これは「`DRAW`」ステートメントの「`N`」コマンド ハンドラーで、[DRWFLG](#drwflg) は単に 40H に設定されます。

<a name="5e46h"></a>

    Address... 5E46H

これは「`DRAW`」ステートメントの「`B`」コマンド ハンドラーで、[DRWFLG](#drwflg) は単に 80H に設定されます。

<a name="5e4eh"></a>

    Address... 5E4EH

これは「`DRAW`」ステートメントの「`A`」コマンドハンドラです。パラメータの大きさがチェックされ、[DRWANG](#drwang)に格納されます。

<a name="5e59h"></a>

    Address... 5E59H

これは「`DRAW`」ステートメントの「`S`」コマンドハンドラです。パラメータの値をチェックし、[DRWSCL](#drwscl)に格納します。

<a name="5e66h"></a>

    Address... 5E66H

このルーチンは、「`DRAW`」ステートメントの「`U`」、「`D`」、「`L`」、「`R`」、「`E`」、「`F`」、「`G`」、「`H`」、および「`M`」（オフセットモード）コマンドハンドラによって使用され、レジスタペアDEに指定されたオフセットを[DRWSCL](#drwscl)の内容でスケーリングします。[DRWSCL](#drwscl)が0の場合（その場合ルーチンは単に終了します）、オフセットは繰り返し加算を使用して乗算され、4で除算されます（[59B4H](#59b4h)）。スケーリングを省略するには、「`S0`」または「`S4`」コマンドを使用する必要があります。

<a name="5e87h"></a>

    Address... 5E87H

これは「`DRAW`」ステートメントの「`C`」コマンドハンドラです。パラメータは[SETATR](#setatr)標準ルーチンを介して[ATRBYT](#atrbyt)に格納されます。パラメータのMSBはチェックされないため、「`C265`」などの不正な値もエラーメッセージなしで受け入れられます。

<a name="5e91h"></a>

    Address... 5E91H

このルーチンは、「`PAINT`」文ハンドラによって[SCALXY](#scalxy)標準ルーチンを介して使用され、レジスタペアBCとDEの座標が画面内に含まれているかどうかを確認します。画面内に収まらない場合は、「`不正な関数呼び出し`」エラー（475AH）が生成されます。

<a name="5e9fh"></a><a name="dim"></a>

    Address... 5E9FH

これは「`DIM`」文のハンドラです。複数の配列を処理できるように、戻り値は5E9AHに設定されています。[DIMFLG](#dimflg)は非ゼロに設定され、制御は変数検索ルーチンに移ります。

<a name="5ea4h"></a>

    Address... 5EA4H

これは変数検索ルーチンです。ルーチン開始時に、レジスタペアHLはプログラムテキスト内の変数名の最初の文字を指します。ルーチン終了時に、レジスタペアHLは変数名に続く文字を指し、レジスタペアDEは変数記憶領域内の変数内容の最初のバイトを指します。変数名の最初の文字はプログラムテキストから取得され、大文字のアルファベット([64A7H](#64a7h))であることを確認した後、レジスタCに格納されます。オプションの2番目の文字はデフォルト値0でレジスタBに格納されます。この文字はアルファベットまたは数字です。それ以降の英数字は単にスキップされます。変数名の後に型接尾辞文字("%", "$", "!" または "#")が続く場合、これは対応する型コード(2、3、4、または8)に変換され、[VALTYP](#valtyp)に格納されます。それ以外の場合、変数のデフォルト型は、変数名の最初の文字を使用して適切なエントリを検索し、[DEFTBL](#deftbl)から取得されます。

次に、[SUBFLG](#subflg) がチェックされ、名前の後に続く括弧付き添字の扱い方が決定されます。このフラグは通常ゼロですが、「`ERASE`」(01H)、「`FOR`」(64H)、「`FN`」(80H)、または「`DEF FN`」(80H) ステートメントハンドラによって変更され、特定の処理が強制されます。「`ERASE`」の場合、制御は配列検索ルーチン (5FE8H) に直接移り、括弧付き添字は不要です。「`FOR`」、「`FN`」、および「`DEF FN`」の場合、制御は単純な変数検索ルーチン ([5F08H](#5f08h)) に直接移り、括弧付き添字のチェックは行われません。状況が正常であると仮定すると、プログラム テキストに文字 "(" または "\[" が含まれているかどうかがチェックされます。どちらかが存在する場合、制御は配列検索ルーチン ([5FBAH](#5fbah)) に渡され、それ以外の場合は制御は単純な変数検索ルーチンに渡されます。

<a name="5f08h"></a>

    Address... 5F08H

これは単純な変数検索ルーチンです。単純な変数には4つの種類があり、それぞれヘッダーとそれに続く変数の内容で構成されます。ヘッダーの最初のバイトには型コードが含まれ、次の2バイトには変数名が含まれます。変数の内容は、3つの標準的な数値形式のいずれか、または文字列型の場合は文字列の長さとアドレスになります。4つのそれぞれの型を以下に示します。

<a name="figure46"></a>![][CH05F46]

**図46:** 単純な変数

まず [NOFUNS](#nofuns) がチェックされ、ユーザー定義関数が現在評価中かどうかが判断されます。評価中の場合、まず [PARM1](#parm1) の内容が検索され、これが失敗した場合にのみメインの変数記憶域に移動します。線形検索方式が使用され、記憶域内の各変数の 2 つの名前文字とタイプ バイトが、一致が見つかるか記憶域の終わりに達するまで参照文字およびタイプと比較されます。検索が成功した場合、ルーチンは、レジスタ ペア DE の変数の内容の最初のバイトのアドレスで終了します。検索が失敗した場合、配列記憶域が上方に移動され、新しい変数が既存の変数の末尾に追加され、ゼロに初期化されます。

この新しい変数の自動作成には2つの例外があります。検索が「`VARPTR`」関数によって実行されている場合（戻りアドレスを調べることで判断されます）、変数は作成されません。代わりに、ルーチンはレジスタペアDEをゼロ（5F61H）に設定して終了し、その後「`Illegal function call`」エラーが発生します。2つ目の例外は、検索がFactor Evaluatorによって実行されている場合、つまり変数が式内で新しく宣言された場合に発生します。この場合、[DAC](#dac)は数値型の場合はゼロに設定され、文字列型の場合はダミーのゼロ長ディスクリプタのアドレスがロードされるため、ゼロの結果（5FA7H）が返されます。これらの動作は、Expression Evaluatorが新しい変数を作成しないようにするように設計されています（「`VARPTR`」は式を介さずに直接変数引数を取る唯一の関数であるため、別途保護が必要です）。そうでない場合、式の評価中に作成された単純な変数によって配列のアドレスが変更されるため、「`LET`」ステートメント ハンドラーを介した配列への割り当ては失敗します。

<a name="5fbah"></a>

    Address... 5FBAH

これは配列検索ルーチンです。配列には4つの種類があり、それぞれヘッダーと要素数で構成されています。ヘッダーの最初のバイトには種類コード、次の2バイトには配列名、次の2バイトには後続の配列の先頭へのオフセットが含まれます。その後に、配列の次元と要素数リストを含む1バイトが続きます。各2バイトの要素数には、各次元の最大要素数が含まれます。これらは逆順に格納され、最初の要素が最後の添字に対応します。各配列要素の内容は、対応する単純な変数の内容と同一です。以下は整数配列AB%(3,4)です。各要素は添字で識別され、上位メモリはページの先頭に向かっています。

<a name="figure47"></a>![][CH05F47]

**図47:** 整数配列

各添字は評価され、整数 ([4755H](#4755h)) に変換され、閉じ括弧が見つかるまで Z80 スタックにプッシュされます。閉じ括弧は開き括弧と一致する必要はありません。次に、配列記憶領域で2つの名前文字と型に一致するものを探す線形検索が実行されます。検索が成功した場合、[DIMFLG](#dimflg) がチェックされ、"`DIM`" 文がアクティブであることを示す場合は "`Redimensioned array`" エラー ([405EH](#405eh)) が生成されます。"`ERASE`" 文がアクティブでない場合は (アクティブである場合は、レジスタペア BC が配列の先頭 (3297H) を指した状態でルーチンが終了します)、配列の次元が添字カウントと照合され、一致しない場合は "`Subscript out of range`" エラーが生成されます。これらのテストが成功したと仮定すると、制御は要素アドレス計算ポイント (607DH) に移ります。

検索に失敗し、"`ERASE`" 文が有効な場合は "`Illegal function call`" エラー (475AH) が生成されます。それ以外の場合は、新しい配列が既存の配列記憶領域の末尾に追加されます。新しい配列の初期化は、2 つの名前文字、型コード、次元数 (添字数)、そして各次元の要素数を格納することで行われます。[DIMFLG](#dimflg) で "`DIM`" 文が有効であることが示される場合、要素数は添字によって決定されます。配列がデフォルトで作成される場合 (例えば "`A(1,2,3)=5`" 文) は、デフォルト値の 11 が使用されます。各要素数が格納されるたびに、要素数と要素サイズ (配列型) の乗算 ([314AH](#314ah)) によって、配列の合計サイズがレジスタペア DE に累積されます。このメモリ量（6267H）が利用可能であることを確認した後、[STREND](#strend) が増加し、新しい領域がゼロにクリアされ、配列のサイズが若干変更された形で、名前の2文字の直後に格納されます。配列がデフォルトで作成される場合を除き（その場合は要素のアドレスを計算する必要があります）、ルーチンは終了します。

これは、配列検索ルーチンの要素アドレス計算ポイントです。配列内の特定の要素の位置は、添字、要素数、および要素サイズの乗算 ([314AH](#314ah)) によって算出されます。この計算にはさまざまな方法があるため、実際の方法を例で説明するのが最適です。4\*5\*6 配列内の要素 (1,2,3) の位置は、最初に (((3\*5)+2)\*4)+1 として計算されます。次に、これに要素サイズ (型) を乗算し、配列のベースアドレスに加算することで、必要な要素のアドレスが得られます。この計算方法は、必要なステップ数を最小限に抑える最適化された形式であり、(3\*(4\*5))+(2\*4)+(1) を評価することと同等です。要素アドレスはレジスタペア DE に返されます。

<a name="60b1h"></a>

    Address... 60B1H

これは「`PRINT USING`」文ハンドラです。適切な出力デバイスが設定された後、制御は汎用の「`PRINT`」文ハンドラからここに移ります。終了すると、制御は汎用の「`PRINT`」文の終了点（[4AFFH](#4affh)）に戻り、通常のビデオ出力に戻ります。フォーマット文字列が評価され（4C65H）、ディスクリプタから文字列本体のアドレスと長さが取得されます。その後、プログラムテキストポインタが一時的に保存されます。フォーマット文字列の各文字は、テンプレート文字の候補が見つかるまで検査されます。文字がテンプレートに属さない場合は、[OUTDO](#outdo)標準ルーチンによって出力されます。テンプレートの開始が見つかると、テンプレートに属さない文字が見つかるまでスキャンされます。その後、制御は数値出力ルーチン（6192H）または文字列出力ルーチン（6211H）に移ります。

いずれの場合も、プログラムテキストポインタはレジスタペアHLに復元され、次のオペランドが評価されます（[4C64H](#4c64h)）。数値出力の場合、テンプレートスキャンから得られた情報はレジスタA、B、Cの数値変換ルーチン（3426H）に渡され、結果の文字列が表示されます（[6678H](#6678h)）。文字列出力の場合、必要な文字数はレジスタCの「`LEFT$`」ステートメントハンドラ（6868H）に渡され、結果の文字列が表示されます（667BH）。どちらの出力タイプでも、プログラムテキストとフォーマット文字列が検査され、さらに文字があるかどうかが判断されます。オペランドが存在しない場合、ハンドラは終了します。フォーマット文字列が尽きた場合は先頭（60BFH）から再開され、そうでない場合は現在の位置から次のオペランド（60f6H）のスキャンが続行されます。

<a name="6250h"></a>

    Address... 6250H

このルーチンは、インタープリタのメインループと変数検索ルーチンによって使用され、メモリブロックを上方に移動します。まず、十分なメモリ（6267H）が存在することを確認してから、メモリブロックを移動します。コピー元アドレスの先頭はレジスタペアBCに、コピー先アドレスの先頭はレジスタペアHLに渡されます。コピーは、レジスタペアBCの内容がレジスタペアDEの内容と一致すると停止します。

<a name="625eh"></a>

    Address... 625EH

このルーチンは、配列記憶領域の先頭とZ80スタックの末尾の間に十分なメモリがあるかどうかを確認するために使用されます。エントリ時にレジスタCには、呼び出し側が必要とするワード数が格納されます。この差が200バイト未満になると、「`メモリ不足`」エラーが生成されます。

<a name="6286h"></a>

    Address... 6286H

これは「`NEW`」ステートメントハンドラです。[TRCFLG](#trcflg)、[AUTFLG](#autflg)、[PTRFLG](#ptrflg) はゼロに設定され、ゼロ終了リンクがプログラムテキスト領域の先頭に配置されます。[VARTAB](#vartab) は終了リンクに続くバイトを指すように設定され、制御は実行クリアルーチンに移行します。

<a name="629ah"></a>

    Address... 629AH

このルーチンは、"`NEW`"、"`RUN`"、および "`CLEAR`" ステートメントハンドラによってインタープリタ変数を初期化するために使用されます。すべての割り込みがクリアされ (636EH)、[DEFTBL](#deftbl) 内のデフォルトの変数型が倍精度に設定されます。[RNDX](#rndx) はリセットされ ([2C24H](#2c24h))、[ONEFLG](#oneflg)、[ONELIN](#onelin)、[OLDTXT](#oldtxt) はゼロに設定されます。[MEMSIZ](#memsiz) は [FRETOP](#fretop) にコピーされ、文字列記憶領域がクリアされます。[DATPTR](#datptr) はプログラムテキスト領域の先頭 ([63C9H](#63c9h)) に設定されます。 [VARTAB](#vartab) の内容が [ARYTAB](#arytab) と [STREND](#strend) にコピーされ、変数をクリアするためにすべてのI/Oバッファが閉じられ([6C1CH](#6c1ch))、[NLONLY](#nlonly) がリセットされます。[SAVSTK](#savstk) とZ80 SPは [STKTOP](#stktop) からリセットされ、[TEMPPT](#temppt)は [TEMPST](#tempst) の先頭にリセットされ、文字列ディスクリプタがクリアされます。プリンタはシャットダウンされ([7304H](#7304h))、出力が画面に復元されます([4AFFH](#4affh))。最後に、[PRMLEN](#prmlen)、[NOFUNS](#nofuns)、[PRMLN2](#prmln2)、[FUNACT](#funact)、[PRMSTK](#prmstk)、[SUBFLG](#subflg) がゼロに設定され、ルーチンが終了します。

<a name="631bh"></a>

    Address... 631BH

このルーチンは、「`DEVICE ON`」ステートメントハンドラによって使用され、割り込みソース（該当デバイスの[TRPTBL](#trptbl)のアドレス）を有効にします。ステータスバイトはレジスタペアHLに提供されます。割り込みは、ステータスバイトのビット0をセットすることで有効になります。次にビット1とビット2が検査され、デバイスが停止していて割り込みが発生している場合は、[ONGSBF](#ongsbf)がインクリメント（634FH）され、Runloopがステートメントの最後にその割り込みを処理します。最後に、ステータスバイトのビット1がリセットされ、既存の停止条件が解除されます。

<a name="632eh"></a>

    Address... 632EH

このルーチンは、「`DEVICE OFF`」ステートメントハンドラによって割り込みソースを無効にするために使用されます。該当デバイスの[TRPTBL](#trptbl)ステータスバイトのアドレスがレジスタペアHLに提供されます。ビット0と2を調べて、最後のステートメントの終了以降に割り込みが発生したかどうかを判断します。発生した場合、[ONGSBF](#ongsbf)をデクリメント(6362H)し、Runloopがそれを拾わないようにします。その後、ステータスバイトはゼロに設定されます。

<a name="6331h"></a>

    Address... 6331H

このルーチンは、「`DEVICE STOP`」ステートメントハンドラによって使用され、割り込みソースからの割り込み処理を一時停止します。該当するデバイスの[TRPTBL](#trptbl)ステータスバイトのアドレスがレジスタペアHLに提供されます。ビット0と2を調べて、最後のステートメントの終了以降に割り込みが発生したかどうかを判断します。発生した場合は、[ONGSBF](#ongsbf)をデクリメント(6362H)し、Runloopがそれを拾わないようにします。その後、ステータスバイトのビット1がセットされます。

<a name="633eh"></a>

    Address... 633EH

このルーチンは、「`RETURN`」ステートメントハンドラによって使用され、割り込み駆動型BASICサブルーチン中に課された一時停止状態を解除します。該当デバイスの[TRPTBL](#trptbl)ステータスバイトのアドレスは、レジスタペアHLに提供されます。ビット0と2を調べて、サブルーチンが最初に起動されてから停止割り込みが発生したかどうかを判断します。発生した場合、[ONGSBF](#ongsbf)がインクリメント(634FH)され、Runloopがステートメントの最後でそれを取得できるようになります。その後、ステータスバイトのビット1がリセットされます。したがって、割り込み駆動型サブルーチン内の「`DEVICE STOP`」ステートメントは無効になることに注意してください。

<a name="6358h"></a>

    Address... 6358H

このルーチンは、Runloop割り込みプロセッサ([6389H](#6389h))によって使用され、BASICサブルーチンをアクティブにする前に割り込みをクリアします。関連デバイスの[TRPTBL](#trptbl)ステータスバイトのアドレスがレジスタペアHLに提供されます。[ONGSBF](#ongsbf)がデクリメントされ、ステータスバイトのビット2がリセットされます。

<a name="636eh"></a>

    Address... 636EH

このルーチンは、実行クリアルーチン ([629AH](#629ah)) によってすべての割り込みをクリアするために使用されます。[TRPTBL](#trptbl) の78バイトと[FNKFLG](#fnkflg) の10バイトがゼロに設定されます。

<a name="6389h"></a>

    Address... 6389H

これは Runloop 割り込みプロセッサです。最初に [ONEFLG](#oneflg) が調べられ、エラー状態が存在するかどうかが判断されます。エラー状態である場合、ルーチンは終了し、エラーが解消されるまで割り込みは処理されません。次に [CURLIN](#curlin) が調べられ、インタープリタが直接モードである場合、ルーチンは終了します。すべてが正常であると仮定すると、[TRPTBL](#trptbl) の 26 個のステータス バイトが検索され、最初のアクティブな割り込みが検索されます。したがって、テーブルの先頭に近いデバイスは、下位にあるデバイスよりも優先順位が高くなります。最初のアクティブなステータス バイト (ビット 0 と 2 がセットされているバイト) が見つかると、関連付けられたアドレスが [TRPTBL](#trptbl) から取得され、レジスタ ペア DE に格納されます。その後、割り込みはクリアされ ([6358H](#6358h))、デバイスは停止し ([6331H](#6331h))、制御は「`GOSUB`」ハンドラ ([47CFH](#47cfh)) に移ります。

<a name="63c9h"></a>

    Address... 63C9H

これは「`RESTORE`」文のハンドラです。行番号オペランドが存在しない場合は、[DATPTR](#datptr) がプログラム記憶領域の先頭に設定されます。存在する場合は、オペランドが収集され (4769H)、プログラムテキストから該当する行 ([4295H](#4295h)) が検索され、そのアドレスが [DATPTR](#datptr) に格納されます。

<a name="63e3h"></a>

    Address... 63E3H

これは「`STOP`」ステートメントハンドラです。ステートメント内にさらにテキストが存在する場合、制御は「`STOP ON/OFF/STOP`」ステートメントハンドラ ([77A5H](#77a5h)) に移ります。それ以外の場合、レジスタAは01Hに設定され、制御は「`END`」ステートメントハンドラに移ります。

<a name="63eah"></a>

    Address... 63EAH

これは「`END`」文ハンドラです。これは、異なるエントリポイントで「`STOP`」文、CTRL-STOP、およびテキストプログラムの終了時にも使用されます。[ONEFLG](#oneflg) は最初にゼロに設定され、その後、「`END`」文の場合のみ、すべてのI/Oバッファが閉じられます([6C1CH](#6c1ch))。現在のプログラムテキスト位置は[SAVTXT](#savtxt)と[OLDTXT](#oldtxt)に格納され、現在の行番号は[OLDLIN](#oldlin)に格納され、後続の「`CONT`」文で使用されます。プリンタはシャットダウンされ([7304H](#7304h))、画面にCR LFが出力され([7323H](#7323h))、レジスタペアHLは3FDCHの「`Break`」メッセージを指すように設定されます。 "`END`" 文およびテキスト終了の場合、制御はメインループの "`OK` ポイント (411EH) に移ります。CTRL-STOP の場合、制御はエラーハンドラの終了 (40FDH) に移り、"`Break`" メッセージを表示します。

<a name="6424h"></a>

    Address... 6424H

これは「`CONT`」文ハンドラです。値がゼロでない限り（ゼロの場合は「`Can't CONTINUE`」エラーが生成されます）、[OLDTXT](#oldtxt) の内容はレジスタペアHLに格納され、[OLDLIN](#oldlin) の内容は[CURLIN](#curlin)に格納されます。その後、制御はRunloopに戻り、古いプログラムテキストの位置から実行されます。文間ではなく、標準ルーチン[CKCNTC](#ckcntc)を介して文内でCTRL-STOPキーを使用してブレークした場合は、プログラムを続行できません。

<a name="6438h"></a>

    Address... 6438H

これは「`TRON`」ステートメント ハンドラーであり、[TRCFLG](#trcflg) は単にゼロ以外にされます。

<a name="6439h"></a>

    Address... 6439H

これは「`TROFF`」ステートメント ハンドラーであり、[TRCFLG](#trcflg) は単にゼロになります。

<a name="643eh"></a>

    Address... 643EH

これは「`SWAP`」文ハンドラです。最初の変数が([5EA4H](#5ea4h))に配置され、その内容が[SWPTMP](#swptmp)にコピーされます。この変数と変数記憶領域の末尾の位置は一時的に保存されます。次に、2番目の変数が([5EA4H](#5ea4h))に配置され、その型が最初の変数と比較されます。型が一致しない場合は、「`Type mismatch`」エラー([406DH](#406dh))が生成されます。次に、変数記憶領域の現在の末尾が以前の末尾と比較され、異なる場合は「`Illegal function call`」エラー(475AH)が生成されます。最後に、2番目の変数の内容が最初の変数の位置(2EF3H)にコピーされ、[SWPTMP](#swptmp)の内容が2番目の変数の位置(2EF3H)にコピーされます。

ハンドラによって実行されるチェックは、2番目の変数が配列ではなく単純な変数である場合、「`SWAP`」ステートメントが実行される前に必ず存在している必要があることを意味します。そうでない場合、エラーが発生します。これは、最初の変数が配列である場合、2番目の（単純な）変数を作成すると配列ストレージ領域が上位に移動し、保存場所が無効になるためです。最初の変数が単純な変数で、2番目の変数が新しく作成されるという完全に有効なケースも拒否されることに注意してください。

<a name="6477h"></a>

    Address... 6477H

これは「`ERASE`」文のハンドラです。[SUBFLG](#subflg) はまず01Hに設定され、変数検索ルーチンと、([5EA4H](#5ea4h) で見つかった配列を制御します。後続の配列はすべて下方に移動し、[STREND](#strend) は新しい低い値に設定されます。次にプログラムテキストがチェックされ、カンマが続く場合はハンドラの先頭に制御が戻ります。

<a name="64a7h"></a>

    Address... 64A7H

このルーチンは、レジスタ ペア HL にアドレスが指定されている文字が大文字のアルファベットであるかどうかをチェックし、大文字の場合はフラグ NC を返します。

<a name="64afh"></a>

    Address... 64AFH

これは「`CLEAR`」文ハンドラです。オペランドが存在しない場合は、制御は実行クリアルーチン（62A1H）に移り、現在のすべての変数を削除します。そうでない場合は、文字列空間オペランド（4756H）が評価され、続いてオプションのメモリ先頭オペランド（[542FH](#542fh)）が評価されます。メモリ先頭値がチェックされ、8000H未満またはF380Hより大きい場合は「`不正な関数呼び出し`」エラー（475AH）が生成されます。I/Oバッファ（それぞれ267バイト）と文字列記憶領域に必要なスペースがメモリ先頭値から差し引かれ、変数記憶領域のベースまでの残りが160バイト未満の場合は「`メモリ不足`」エラー（6275H）が生成されます。すべてが正常であると仮定すると、[HIMEM](#himem)、[MEMSIZ](#memsiz)、[STKTOP](#stktop)は新しい値に設定され、残りのストレージポインタはrun-clearルーチン(62A1H)によってリセットされます。I/Oバッファストレージは再割り当てされ([7E6BH](#7e6bh))、ハンドラは終了します。

残念ながら、メモリの新たな先頭値が指定された場合の[MEMSIZ](#memsiz)と[STKTOP](#stktop)の計算が正しく行われず、文字列記憶領域の先頭値が1バイト多く設定されてしまいます。これは、不正な文字列が受け入れられる以下の例で確認できます。

```
10 CLEAR 200,&HF380
20 A$=STRING$(201,"A")
30 PRINT FRE("")
```

64EBHにDEC HL命令が追加されるため、[MEMSIZ](#memsiz)と[STKTOP](#stktop)の新しい値は初期値として1バイト高く設定されます。run-clearルーチンが呼び出されると、[MEMSIZ](#memsiz)が文字列記憶領域の先頭である[FRETOP](#fretop)にコピーされ、結果として[FRETOP](#stktop)も1バイト高く設定されます。ファイルポインタがリセットされると、[MEMSIZ](#memsiz)と[STKTOP](#stktop)は正しく再計算されますが、[FRETOP](#fretop)は誤った値のままになります。30行目で「`FRE`」文が実行され、文字列ガベージコレクションが開始されると、[FRETOP](#fretop)は正しい値に復元されますが、文字列が文字列記憶領域を1バイトオーバーフローするため、表示される空き容量は-1バイトになります。すべてのシステム ポインタを正しく設定するには、メモリの先頭を変更した後、すぐにオペランドのない別の「`CLEAR`」ステートメントを実行する必要があります。

<a name="6520h"></a>

    Address... 6520H

このルーチンは、レジスタペアHLとDEの内容の差を計算します。これは64ECHから64F1Hまでの短いコードセクションの複製であり、完全に未使用です。

<a name="6527h"></a>

    Address... 6527H

これは「`NEXT`」文ハンドラです。文中にさらにテキストが存在する場合、ループ変数が配置されます（[5EA4H](#5ea4h)）。存在しない場合は、デフォルトのアドレス0が採用されます。次に、スタック上で対応する「`FOR`」パラメータブロックが検索されます（[3FE2H](#3fe2h)）。パラメータブロックが見つからない場合、または「`GOSUB`」パラメータブロックが先に見つかった場合は、「`NEXT without FOR`」エラーが発生します（[405BH](#405bh)）。パラメータブロックが見つかった場合、スタックの中間セクションと、そこに含まれる可能性のある「`FOR`」ブロックは破棄されます。次に、パラメータブロックからループ変数の型が取得され、後続の操作に必要な精度を決定するために検査されます。

STEP値はパラメータブロックから取得され、ループ変数の現在の内容に加算（3172H、324EH、または2697H）され、その後更新されます。新しい値はパラメータブロックの終了値と比較（2F4DH、2F21H、または2F5CH）され、ループが終了したかどうか（65B6H）が判定されます。新しいループ値が終了値より大きい場合、ループは正のSTEPで終了します。新しいループ値が終了値より小さい場合、ループは負のSTEPで終了します。ループが終了していない場合は、元のプログラムテキストの位置と行番号がパラメータブロックから取得され、制御はRunloop（45FDH）に移ります。ループが終了した場合は、パラメータブロックはスタックから破棄され、ハンドラの先頭に制御が移る次のプログラムテキストが存在しない限り、制御はRunloopに移り、次のステートメント（[4601H](#4601h)）を実行します。

<a name="65c8h"></a>

    Address... 65C8H

このルーチンは、Expression Evaluatorによって2つの文字列オペランド間の関係 (<>=) を求めるために使用されます。最初の文字列ディスクリプタのアドレスはZ80スタックに、2番目の文字列ディスクリプタのアドレスは[DAC](#dac)に格納されます。結果はレジスタAに返され、数値関係ルーチンと同様にフラグが設定されます。

```
String 1=String 2 ... A=00H, Flag Z,NC
String 1<String 2 ... A=01H, Flag NZ,NC
String 1>String 2 ... A=FFH, Flag NZ,C
```

比較は各文字列の最初の文字から開始され、2つの文字が一致するか、いずれかの文字列が尽きるまで続けられます。その後、制御は式評価子 ([4F57H](#4f57h)) に戻り、真偽の数値結果が [DAC](#dac) に格納されます。

<a name="65f5h"></a>

    Address... 65F5H

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`OCT$`」関数を適用するために使用されます。数値はまず[FBUFFR](#fbuffr) ([371EH](#371eh)) でテキスト形式に変換され、その後結果文字列 (6607H) が作成されます。

<a name="65fah"></a>

    Address... 65FAH

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`HEX$`」関数を適用するために使用されます。数値はまず[FBUFFR](#fbuffr) ([3722H](#3722h)) でテキスト形式に変換され、その後結果文字列 (6607H) が作成されます。

<a name="65ffh"></a>

    Address... 65FFH

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`BIN$`」関数を適用するために使用されます。数値はまず[FBUFFR](#fbuffr)([371AH](#371ah))でテキスト形式に変換され、その後結果文字列(6607H)が作成されます。

<a name="6604h"></a>

    Address... 6604H

このルーチンは、Factor Evaluatorによって使用され、[DAC](#dac) に含まれるオペランドに「`STR$`」関数を適用します。数値はまず[FBUFFR](#fbuffr) ([3425H](#3425h)) でテキスト形式に変換され、その後解析されて長さとアドレス (6635H) が決定されます。十分な空き領域があることを確認した後 ([668EH](#668eh))、文字列は文字列記憶領域 (67C7H) にコピーされ、結果ディスクリプタが作成されます ([6654H](#6654h))。

<a name="6627h"></a>

    Address... 6627H

このルーチンはまず、レジスタA（668EH）に指定された長さの文字列を格納するのに十分なスペースが文字列記憶領域にあるかどうかを確認します。次に、文字列の長さと文字列記憶領域内の文字列を格納するアドレスを[DSCTMP](#dsctmp)にコピーします。

<a name="6636h"></a>

    Address... 6636H

このルーチンは、レジスタペアHLにアドレスが指定された文字列を解析するためにFactor Evaluatorによって使用されます。文字列は、終端文字（00Hまたは "）が見つかるまでスキャンされます。文字列の長さと開始アドレスは[DSCTMP](#dsctmp) (662AH)に格納され、制御はディスクリプタ作成ルーチンに移ります。

<a name="6654h"></a>

    Address... 6654H

このルーチンは、文字列関数によって結果ディスクリプタを作成するために使用されます。ディスクリプタは[DSCTMP](#dsctmp)から[TEMPST](#tempst)内の次の利用可能な位置にコピーされ、そのアドレスが[DAC](#dac)に格納されます。[TEMPST](#tempst)が一杯でない場合は（一杯の場合は「`文字列式が複雑すぎます`」というエラーが発生します）、[TEMPPT](#temppt)が3バイト増加され、ルーチンは終了します。

<a name="6678h"></a>

    Address... 6678H

このルーチンは、レジスタペアHLに指定されたアドレスのメッセージ（文字列）を表示します。文字列は解析され（6635H）、その記憶領域が解放されます（67D3H）。その後、[OUTDO](#outdo)標準ルーチンを介して、文字列から文字が順次取り出され、文字列がなくなるまで表示されます。

<a name="668eh"></a>

    Address... 668EH

このルーチンは、レジスタAに長さが指定された文字列を文字列記憶領域に追加できるだけの空き容量があるかどうかを確認します。終了時に、レジスタペアDEは文字列記憶領域内の文字列を配置する先頭アドレスを指します。まず、文字列の長さが[FRETOP](#fretop)に格納されている現在の空き領域から減算されます。次に、この値が文字列記憶領域として許容される最小位置である[STKTOP](#stktop)と比較され、文字列を配置できる空き容量があるかどうかが判断されます。空き容量がある場合、[FRETOP](#fretop)は新しい位置で更新され、ルーチンは終了します。文字列を配置できる十分な空き容量がない場合は、不要な文字列を削除するためにガベージコレクションが開始されます([66B6H](#66b6h))。ガベージコレクション後も十分な空き容量がない場合は、「`Out of string space`」エラーが生成されます。

<a name="66b6h"></a>

    Address... 66B6H

これは文字列ガベージコレクタであり、文字列記憶領域から不要な文字列を削除する機能です。数値変数とは異なり、文字列変数の基本的な問題は、長さが一定ではないことです。文字列本体を変数記憶領域に変数と共に保存すると、A$=A$+"X" のような一見単​​純な文でさえ、数千バイトのメモリ移動が必要になり、実行速度が著しく低下します。インタープリタがこの問題を解決するために用いる方法は、文字列本体を変数から分離することです。つまり、文字列は文字列記憶領域に保持され、各変数は対応する文字列の長さとアドレスを含む3バイトのディスクリプタを保持します。文字列が変数に割り当てられるたびに、文字列記憶領域内の既存の文字列ヒープに追加され、変数のディスクリプタが変更されます。変数に属していた以前の文字列をヒープの再構築によって削除することは行われません。そうしないと、スループットの向上が損なわれてしまうからです。

変数への十分な割り当てが行われると、文字列ストレージ領域が一杯になることは避けられません。一般的なプログラムでは、これらの文字列の多くは未使用になります。これは、以前の割り当ての結果として使用されます。ガベージコレクションは、これらの不要な文字列を削除するプロセスです。配列や、ユーザー定義関数の評価中に存在するローカル変数を含む、メモリ内のすべての文字列変数が検査され、ヒープ内の最上位に格納されている文字列を持つ変数が見つかります。見つかった文字列は文字列ストレージ領域の先頭に移動され、変数の内容は新しい場所を指すように変更されます。次に、次に上位の文字列の所有者が見つかり、変数に属するすべての文字列が圧縮されるまで、このプロセスが繰り返されます。

多数の変数が存在する場合、ガベージコレクションにかなりの時間がかかることがあります。このプロセスは、配列A$の各要素に文字列「`AAAA`」を繰り返し代入する以下のプログラムで確認できます。プログラムは最初の250回の代入をフルスピードで実行し、その後、不要な50個の文字列を削除するために一時停止します。その後、さらに50回の代入を行うと、ガベージコレクションが必要になります。

```
10 CLEAR 1000
20 DIM A$(200)
30 FOR N=0 TO 200
40 A$(N)=STRING$(4,"A")
50 PRINT".";
60 NEXT N
70 GOTO 30
```

文字列記憶域は、式の評価中に生成される中間文字列の保持にも使用されます。多くの文字列関数は複数の引数（例えば「`MID$`」は3つの引数）を取るため、中間結果の管理は大きな問題となります。この問題に対処するため、インタープリタ全体で文字列結果に対する標準化されたアプローチが採用されています。文字列を生成する関数は、文字列本体を文字列記憶域のヒープに追加し、[TEMPST](#tempst) 内のディスクリプタヒープにディスクリプタを追加し、ディスクリプタのアドレスを [DAC](#dac) に格納するだけです。文字列の処理が完了したら、結果のユーザーがこの記憶域 ([67D0H](#67d0h)) を解放する必要があります。このルールは、個々の関数ハンドラからExpression Evaluator、そして文ハンドラに至るまで、システムのすべての部分に適用されますが、2つの例外があります。

最初の例外は、Factor Evaluatorがプログラムテキスト内に「`SOMETHING`」のような明示的に記述された文字列を見つけた場合に発生します。この場合、元の文字列で十分なので、文字列保存領域にコピーする必要はありません。

2つ目の例外は、Factor Evaluatorが変数への参照を発見した場合に発生します。この場合、変数内に既にディスクリプタが存在するため、[TEMPST](#tempst) にディスクリプタのコピーを配置する必要はありません。

<a name="6787h"></a>

    Address... 6787H

このルーチンは、Expression Evaluatorによって2つの文字列オペランドを連結するために使用されます。文字列オペランドの後に「+」トークンが見つかると制御がここへ移るため、まずFactor Evaluator ([4DC7H](#4dc7h)) を介して2番目の文字列オペランドを取得します。次に、両方の文字列ディスクリプタから長さを取得し、それらを加算して、結合された文字列の長さをチェックします。長さが255文字を超える場合は、「`文字列が長すぎます`」エラーが生成されます。文字列記憶領域 ([6627H](#6627h)) に空き領域があることを確認した後、両方のオペランドの記憶領域が解放されます (67D6H)。次に、最初の文字列が文字列記憶領域 (67BFH) にコピーされ、続いて2番目の文字列 (67BFH) がコピーされます。結果ディスクリプタが作成され([6654H](#6654h))、制御はExpression Evaluator(4C73H)に戻ります。

<a name="67d0h"></a>

    Address... 67D0H

このルーチンは、ディスクリプタアドレスが [DAC](#dac) に含まれる文字列が占有しているストレージを解放します。ディスクリプタのアドレスは [DAC](#dac) から取得され、それが [TEMPST](#tempst) (67EEH) の最後のディスクリプタのアドレスかどうかが調べられ、そうでない場合はルーチンが終了します。そうでない場合は、[TEMPPT](#temppt) が 3 バイト減らされ、このディスクリプタが [TEMPST](#tempst) からクリアされます。次に、文字列本体のアドレスがディスクリプタから取得され、[FRETOP](#fretop) と比較され、これが文字列ストレージ領域の最下位の文字列かどうかが調べられ、そうでない場合はルーチンが終了します。そうでない場合は、文字列の長さが [FRETOP](#fretop) に追加され、この新しい値で更新されて、文字列本体が占有していたストレージが解放されます。

<a name="67ffh"></a>

    Address... 67FFH

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`LEN`」関数を適用するために使用されます。オペランドのストレージは解放され([67D0H](#67d0h))、ディスクリプタから文字列の長さが取得され、整数(4FCFH)として[DAC](#dac)に格納されます。

<a name="680bh"></a>

    Address... 680BH

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`ASC`」関数を適用するために使用されます。オペランドのストレージが解放され、文字列の長さが調べられます(6803H)。長さが0の場合は「`不正な関数呼び出し`」エラーが生成されます(475AH)。そうでない場合は、文字列から最初の文字が取得され、整数(4FCFH)として[DAC](#dac)に格納されます。

<a name="681bh"></a>

    Address... 681BH

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`CHR$`」関数を適用するために使用されます。十分な領域(6625H)が利用可能であることを確認した後、オペランドは1バイト整数(521FH)に変換されます。その後、この文字は文字列記憶領域に格納され、結果ディスクリプタ([6654H](#6654h))が作成されます。

<a name="6829h"></a>

    Address... 6829H

このルーチンは、Factor Evaluator によって「`STRING$`」関数を適用するために使用されます。開き括弧文字をチェックした後、長さオペランドが評価され、レジスタ E (521CH) に格納されます。次に、2番目のオペランドが評価されます ([4C64H](#4c64h))。数値の場合は、1バイト整数 (521FH) に変換され、レジスタ A に格納されます。文字列の場合は、最初の文字が取得され、レジスタ A (680FH) に格納されます。その後、制御は「`SPACE$`」関数に移り、結果の文字列が作成されます。

<a name="6848h"></a>

    Address... 6848H

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`SPACE$`」関数を適用するために使用されます。オペランドはまず、レジスタE(521FH)で1バイト整数に変換されます。十分なスペースが利用可能であることを確認した後([6627H](#6627h))、必要な数のスペースが文字列記憶領域にコピーされ、結果ディスクリプタが作成されます([6654H](#6654h))。

<a name="6861h"></a>

    Address... 6861H

このルーチンは、Factor Evaluatorによって「`LEFT$`」関数を適用するために使用されます。第1オペランドのディスクリプタアドレスと第2オペランドの整数はZ80スタック上に提供されます。スライスサイズはスタックから取得され ([68E3H](#68e3h))、ソース文字列の長さと比較されます。ソース文字列の長さがスライスサイズより短い場合は、スライスサイズを抽出対象の長さとして置き換えます。十分なスペースが利用可能であることを確認した後 ([668EH](#668eh))、必要な数の文字がソース文字列の先頭から文字列記憶領域 (67C7H) にコピーされます。その後、ソース文字列の記憶領域が解放され (67D7H)、結果ディスクリプタが作成されます ([6654H](#6654h))。

<a name="6891h"></a>

    Address... 6891H

このルーチンは、Factor Evaluator が「`RIGHT$`」関数を適用するために使用します。第1オペランドのディスクリプタアドレスと第2オペランドの整数は、Z80スタック上に提供されます。スライスサイズはスタック ([68E3H](#68e3h)) から取得され、ソース文字列の長さから減算されてスライスの開始位置が決定されます。その後、制御は「`LEFT$`」ルーチンに移り、スライス (6865H) が抽出されます。

<a name="689ah"></a>

    Address... 689AH

このルーチンは、Factor Evaluator が「`MID$`」関数を適用するために使用します。第1オペランドのディスクリプタアドレスと第2オペランドの整数は、Z80スタック上に提供されます。開始位置はスタック (68E6H) から取得され、チェックされます。開始位置がゼロの場合、「`Illegal function call`」エラー (475AH) が生成されます。次に、オプションのスライスサイズが評価され ([69E4H](#69e4h))、スライス (6869H) を抽出する「`LEFT$`」ルーチンに制御が移ります。

<a name="68bbh"></a>

    Address... 68BBH

このルーチンは、Factor Evaluatorによって使用され、[DAC](#dac) に含まれるオペランドに「`VAL`」関数を適用します。文字列の長さはディスクリプタ (6803H) から取得され、チェックされます。ゼロの場合は整数 (4FCFH) として [DAC](#dac) に格納されます。次に、この長さが文字列本体の開始アドレスに加算され、その直後の文字の位置が算出されます。この位置は一時的にゼロバイトに置き換えられ、文字列は [DAC](#dac) ([3299H](#3299h)) で数値形式に変換されます。その後、元の文字が復元され、ルーチンは終了します。一時的なゼロバイト区切り文字は、文字列が文字列記憶領域にまとめて格納されるため必要です。これがないと、数値変換は後続の文字列にまで実行されてしまいます。

<a name="68e3h"></a>

    Address... 68E3H

このルーチンは、「`LEFT$`」、「`MID$`」、および「`RIGHT$`」関数ハンドラーによって使用され、次のプログラム テキスト文字が「)」であることを確認し、次に Z80 スタックからレジスタ ペア DE にオペランドをポップします。

<a name="68ebh"></a>

    Address... 68EBH

このルーチンは、Factor Evaluator が「`INSTR`」関数を適用するために使用します。最初のオペランド（開始位置またはソース文字列）が評価され（4C62H）、その型がテストされます。ソース文字列の場合、デフォルトの開始位置である1が採用されます。開始位置オペランドの場合、その値がチェックされ、ソース文字列オペランドが評価されます（[4C64H](#4c64h)）。次に、パターン文字列が評価され（[4C64H](#4c64h)）、両方のオペランドの記憶域が解放されます（[67D0H](#67d0h)）。パターン文字列の長さがチェックされ、長さが0の場合、開始位置が[DAC](#dac)（4FCFH）に格納されます。次に、パターン文字列が開始位置からソース文字列の連続する文字と照合され、一致するかソース文字列が尽きるまで、照合が行われます。検索が成功すると、部分文字列の文字位置が整数 (4FCFH) として [DAC](#dac) に格納され、それ以外の場合はゼロの結果が返されます。

<a name="696eh"></a>

    Address... 696EH

これは「`MID$`」ステートメントハンドラです。開き括弧文字をチェックした後、コピー先の変数（[5EA4H](#5ea4h)）が検索され、文字列型（[3058H](#3058h)）であることを確認します。次に、変数から文字列本体のアドレスを取得し、明示的に指定された文字列の場合と同様に、プログラムテキスト領域内にあるかどうかを判定します。プログラムテキスト領域内にある場合、文字列本体は文字列記憶領域（6611H）にコピーされ、新しいディスクリプタが変数（2EF3H）にコピーされます。これは、プログラムテキストの変更を防ぐためです。次に、開始位置が評価（521CH）され、チェックされます。開始位置がゼロの場合、「`不正な関数呼び出し`」エラー（475AH）が生成されます。オプションのスライス長オペランドが評価され ([69E4H](#69e4h))、続いて置換文字列 (4C5FH) が評価されます。置換文字列の記憶領域は解放されます ([67D0H](#67d0h))。その後、スライス長が完了するか、置換文字列がなくなるまで、置換文字列からコピー先の文字列に文字がコピーされます。

<a name="69e4h"></a>

    Address... 69E4H

このルーチンは、さまざまな文字列関数によって使用され、オプションのオペランド (521CH) を評価し、結果をレジスタ E に返します。オペランドが存在しない場合は、デフォルト値 255 が返されます。

<a name="69f2h"></a>

    Address... 69F2H

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`FRE`」関数を適用するために使用されます。オペランドが数値型の場合、Z80スタックポインタと[STREND](#strend)の内容との単精度差分が[DAC](#dac)(4FC1H)に格納されます。オペランドが文字列型の場合、そのストレージが解放され(67D3H)、ガベージコレクションが開始されます([66B6H](#66b6h))。[FRETOP](#fretop)と[STKTOP](#stktop)の内容との単精度差分が[DAC](#dac)(4FC1H)に格納されます。

<a name="6a0eh"></a>

    Address... 6A0EH

このルーチンは、ファイルI/Oハンドラによって「`A:FILENAME.BAS`」のようなファイル仕様を解析するために使用されます。ファイル仕様は、デバイス、ファイル名、およびタイプ拡張子の3つの部分で構成されます。エントリ時にレジスタペアHLはプログラムテキスト内のファイル仕様の先頭を指します。終了時にレジスタDはデバイスコードを保持し、[FILNAM](#filnam)の0～7番目の位置にファイル名、8～10番目の位置にタイプ拡張子が保持されます。未使用の位置はスペースで埋められます。

ファイル仕様文字列は評価され([4C64H](#4c64h))、その記憶領域が解放されます([67D0H](#67d0h))。文字列の長さが0の場合、「`Bad file name`」エラーが生成されます([6E6BH](#6e6bh))。デバイス名は解析され([6F15H](#6f15h))、ファイル仕様から連続する文字が[FILNAM](#filnam)に格納されます。これは、文字列が尽きるか、「.」文字が見つかるか、[FILNAM](#filnam)が一杯になるまで行われます。ファイル仕様に制御文字（つまり、値が20H未満の文字）が含まれている場合、「`Bad file name`」エラーが生成されます([6E6BH](#6e6bh))。ファイル仕様に型拡張子が含まれている場合、拡張子が3文字を超えるか、ファイル名が8文字を超えると、「`Bad file name`」エラー ([6E6BH](#6e6bh)) が発生します。型拡張子がない場合、ファイル名の長さは任意で、余分な文字は無視されます。

<a name="6a6dh"></a>

    Address... 6A6DH

このルーチンは、ファイルI/Oハンドラによって、レジスタAで指定された番号のI/OバッファFCBを見つけるために使用されます。バッファ番号はまず[MAXFIL](#maxfil)と比較され、大きすぎる場合は「`Bad file number`」エラー([6E7DH](#6e7dh))が生成されます。それ以外の場合は、必要なアドレスがファイルポインタブロックから取得され、レジスタペアHLに格納されます。また、FCBのバイト0からバッファのモードが取得され、レジスタAに格納されます。

<a name="6a9eh"></a>

    Address... 6A9EH

このルーチンは、ファイルI/OハンドラによってI/Oバッファ番号を評価し、そのFCBを特定するために使用されます。「#」文字はスキップされ（[4666H](#4666h)）、バッファ番号が評価されます（521CH）。バッファモードバイトが0の場合、FCBが特定され（[6A6DH](#6a6dh)）、"`File not open`"エラーが発生します（[6E77H](#6e77h)）。それ以外の場合、FCBアドレスは[PTRFIL](#ptrfil)に格納され、インタープリタの出力をリダイレクトします。

<a name="6ab7h"></a>

    Address... 6AB7H

これは「`OPEN`」文ハンドラです。ファイル仕様が解析され（[6A0EH](#6a0eh)）、後続のモードが対応するモードバイトに変換されます。これらのモードバイトは、「`FOR INPUT`」(01H)、「`FOR OUTPUT`」(02H)、「`FOR APPEND`」(08H)です。モードが明示的に指定されていない場合は、ランダムモード(04H)が想定されます。「`AS`」文字がチェックされ、バッファ番号が評価されます（521CH）。これが0の場合、「`Bad file number`」エラーが生成されます（[6E7DH](#6e7dh)）。次に、FCBが検索され（[6A6DH](#6a6dh)）、バッファのモードバイトが0以外の場合、「`File already open`」エラーが生成されます（[6E6EH](#6e6eh)）。デバイス コードは FCB のバイト 4 に配置され、オープン関数がディスパッチされ ([6F8FH](#6f8fh))、インタープリタの出力が画面にリセットされます ([4AFFH](#4affh))。

<a name="6b24h"></a>

    Address... 6B24H

このルーチンは、ファイルI/Oハンドラによって、レジスタAで指定された番号のI/Oバッファを閉じるために使用されます。FCBは([6A6DH](#6a6dh))で特定され、バッファが使用中の場合は、クローズ関数がディスパッチされ([6F8FH](#6f8fh))、バッファはゼロで埋められます([6CEAH](#6ceah))。その後、[PTRFIL](#ptrfil)とFCBモードバイトがゼロに設定され、インタープリタの画面出力がリセットされます。

<a name="6b5bh"></a>

    Address... 6B5BH

これは「`LOAD`」、「`MERGE`」、および「`RUN filespec`」ステートメントハンドラです。ファイルスペックが解析され（[6A0EH](#6a0eh)）、その後、「`LOAD`」および「`RUN`」の場合のみ、プログラムテキストが検査され、自動実行オプション「`R`」が指定されているかどうかが判断されます。I/Oバッファ0が入力用に開かれ（6AFAH）、自動実行が必要な場合は[FILNAM](#filnam)の先頭バイトがFFHに設定されます。「`LOAD`」および「`RUN`」の場合のみ、プログラムテキストは「`NEW`」ステートメントハンドラ（6287H）によってクリアされます。これによりインタープリタの画面出力がリセットされるため、バッファFCBが再度検索され、[PTRFIL](#ptrfil)（6AAAH）に格納されます。その後、制御はインタープリタメインループ ([4134H](#4134h)) に直接移り、キーボードから入力されたかのようにプログラムテキストが読み込まれます。読み込まれたデータに対しては、いかなるエラーチェックも行われないことに注意してください。

<a name="6ba3h"></a>

    Address... 6BA3H

これは「`SAVE`」文ハンドラです。ファイルスペックが解析され（[6A0EH](#6a0eh)）、プログラムテキストがASCIIサフィックス「`A`」の有無を判定します。これはDisk BASICでのみ有効で、標準のMSXマシンでは影響しません。I/Oバッファ0が出力用に開かれ（6AFAH）、制御は「`LIST`」文ハンドラ（[522EH](#522eh)）に移り、プログラムテキストが出力されます。テキストにはエラーチェック情報は一切含まれないことに注意してください。

<a name="6bdah"></a>

    Address... 6BDAH

このルーチンは、ファイルI/Oハンドラによって使用され、現在アクティブなI/Oバッファのデバイスコードを返します。FCBアドレスは[PTRFIL](#ptrfil)から取得され、次にFCBのバイト4からデバイスコードが取得され、レジスタAに格納されます。

<a name="6be7h"></a>

    Address... 6BE7H

このルーチンは、ファイルI/Oハンドラによって、複数のI/Oバッファに対する操作を実行するために使用されます。関連するルーチンのアドレスはレジスタペアBCに、バッファ数はレジスタAに提供されます。例えば、レジ​​スタペアBCに6B24H、レジスタAに03Hが格納されている場合、バッファ3、2、1、0が閉じられます。このルーチンは、FLAG NZとともに実行された場合、機能が若干異なります。この場合、I/Oバッファ番号はプログラムテキストから順番に取得され、操作実行前に評価されます（521CH）。典型的なケースは「#1,#2」です。

<a name="6c14h"></a>

    Address... 6C14H

これは「`CLOSE`」文のハンドラです。レジスタペアBCは6B24Hに設定され、レジスタAには[MAXFIL](#maxfil)の内容と、必要な数のバッファが閉じられた状態([6BE7H](#6be7h))がロードされます。

<a name="6c1ch"></a>

    Address... 6C1CH

このルーチンは、ファイルI/OハンドラによってすべてのI/Oバッファを閉じるために使用されます。レジスタペアBCは6B24Hに設定され、レジスタAには[MAXFIL](#maxfil)の内容がロードされ、すべてのバッファが閉じられます([6BE7H](#6be7h))。

<a name="6c2ah"></a>

    Address... 6C2AH

これは「`LFILES`」ステートメント ハンドラです。[PRTFLG](#prtflg) はプリンタに出力するためにゼロ以外に設定され、制御は「`FILES`」ステートメント ハンドラに移ります。

<a name="6c2fh"></a>

    Address... 6C2FH

これは「`FILES`」ステートメント ハンドラーであり、標準の MSX マシンでは「`Illegal function call`」エラー (475AH) が生成されます。

<a name="6c35h"></a>

    Address... 6C35H

プログラムテキストに「`SPRITE`」トークン以外のものが含まれている場合、制御は一般的な「`PUT`」および「`GET`」ハンドラ（[7758H](#7758h)）からここに移ります。標準MSXマシンでは「`Sequential I/O only`」エラー（[6E86H](#6e86h)）が生成されます。

<a name="6c48h"></a>

    Address... 6C48H

このルーチンは、ファイル I/O ハンドラーによって、レジスタ A に提供された文字を順番に出力するために使用されます。文字はレジスタ C に配置され、順番に出力関数がディスパッチされます ([6F8FH](#6f8fh))。

<a name="6c71h"></a>

    Address... 6C71H

このルーチンは、ファイルI/Oハンドラによって1文字ずつ順次入力するために使用されます。順次入力関数がディスパッチされ([6F8FH](#6f8fh))、レジスタAに返される文字はEOF(ファイル終了)状態を示します。フラグCはEOF状態を示します。

<a name="6c87h"></a>

    Address... 6C87H

このルーチンは、Factor Evaluatorによって「`INPUT$`」関数を適用するために使用されます。プログラムテキストに「$」および「(」文字が含まれているかどうかがチェックされ、長さオペランドが評価されます（521CH）。I/Oバッファ番号が存在する場合は評価され、FCBが検索され（[6A9EH](#6a9eh)）、モードバイトが調べられます。バッファが入力モードまたはランダムモードでない場合は、「`Input past end`」エラーが生成されます（[6E83H](#6e83h)）。十分なスペースが利用可能であることを確認した後（[6627H](#6627h)）、必要な数の文字が順番に入力されるか（[6C71H](#6c71h)）、標準ルーチン[CHGET](#chget)を介して収集され、文字列記憶領域にコピーされます。最後に、結果ディスクリプタが作成されます（[6654H](#6654h)）。

<a name="6ceah"></a>

    Address... 6CEAH

このルーチンは、ファイル I/O ハンドラーによって使用され、[PTRFIL](#ptrfil) に含まれる FCB アドレスを持つバッファーを 256 個のゼロで埋めます。

<a name="6cfbh"></a>

    Address... 6CFBH

このルーチンは、ファイルI/Oハンドラによって使用され、レジスタペアHLに、[PTRFIL](#ptrfil)に格納されているFCBアドレスを持つバッファの先頭アドレスを返します。これはFCBアドレスに9を加算するだけです。

<a name="6d03h"></a>

    Address... 6D03H

このルーチンは、Factor Evaluatorによって使用され、[DAC](#dac) に格納されている番号のI/Oバッファに「`LOC`」関数を適用します。FCBが位置指定され(6A6AH)、LOC関数がディスパッチされます([6F8FH](#6f8fh))。標準MSXマシンでは、「`不正な関数呼び出し`」エラーが発生します(475AH)。

<a name="6d14h"></a>

    Address... 6D14H

このルーチンは、Factor Evaluatorによって使用され、[DAC](#dac) に格納されている番号のI/Oバッファに「`LOF`」関数を適用します。FCBは(6A6AH)で検出され、LOF関数がディスパッチされます([6F8FH](#6f8fh))。標準MSXマシンでは、「`不正な関数呼び出し`」エラー(475AH)が生成されます。

<a name="6d25h"></a>

    Address... 6D25H

このルーチンは、Factor Evaluatorによって使用され、[DAC](#dac) に格納されている番号のI/Oバッファに「`EOF`」関数を適用します。FCBは(6A6AH)で検出され、EOF関数がディスパッチされます([6F8FH](#6f8fh))。

<a name="6d39h"></a>

    Address... 6D39H

このルーチンは、Factor Evaluatorによって[DAC](#dac)に格納されている番号のI/Oバッファに「`FPOS`」関数を適用するために使用されます。FCBは(6A6AH)で検出され、「`FPOS`」関数がディスパッチされます([6F8FH](#6f8fh))。標準MSXマシンでは、「`Illegal function call`」エラー(475AH)が生成されます。

<a name="6d48h"></a>

    Address... 6D48H

インタープリタのメインループが直接文（行番号のない文）に遭遇すると、制御はこのルーチンに移ります。[ISFLIO](#isflio) 標準ルーチンは、まず「`LOAD`」文がアクティブかどうかを判定するために使用されます。入力がキーボードからの場合、制御はRunloop実行ポイント（[4640H](#4640h)）に移り、文を実行します。入力がカセットからの場合、バッファ0が閉じられ（[6B24H](#6b24h)）、"`Direct statement in file`" エラーが生成されます（[6E71H](#6e71h)）。これは、標準MSXマシンでは、カセットエラー、または行番号のないテキストファイルのロードを試みた場合に発生する可能性があります。

<a name="6d57h"></a>

    Address... 6D57H

このルーチンは、「`INPUT`」、「`LINE INPUT`」、および「`PRINT`」ステートメントハンドラによって、プログラムテキスト内に「#」文字が存在するかどうかをチェックするために使用されます。「#」文字が見つかった場合、I/Oバッファ番号が評価され（[521BH](#521bh)）、FCBが特定され、そのアドレスが[PTRFIL](#ptrfil)（6AAAH）に格納されます。次に、FCBのモードバイトが、ステートメントハンドラによってレジスタCに提供されたモード番号と比較されます。一致しない場合は、「`Bad file number`」エラーが生成されます（[6E7DH](#6e7dh)）。「`PRINT`」の場合、許容されるモードは出力、ランダム、および追加です。「`INPUT`」および「`LINE INPUT`」の場合、許容されるモードは入力とランダムです。標準のMSXマシンでは、これらのモードすべてが下位レベルでサポートされているわけではないことに注意してください。不正なモードの場合、後の段階で何らかのエラーが生成されます。

<a name="6d83h"></a>

    Address... 6D83H

このルーチンは、「`INPUT`」文ハンドラによってI/Oバッファから文字列を入力するために使用されます。まず、「`READ/INPUT`」文ハンドラ（4BF1H）にリターンが設定されます。入力文字列を区切る文字（数値変数の場合はカンマとスペース、文字列変数の場合はカンマのみ）はレジスタDとEに格納され、制御は「`LINE INPUT`」ルーチン（6DA3H）に移ります。

<a name="6d8fh"></a>

    Address... 6D8FH

これは、入力がI/Oバッファから行われる場合の「`LINE INPUT`」文ハンドラです。バッファ番号が評価され、FCBが検索され、モードがチェックされます（6D55H）。次に、代入先の変数が検索され（[5EA4H](#5ea4h)）、その型が文字列型であることを確認します（[3058H](#3058h)）。「`LET`」文ハンドラ（487BH）への戻りが設定され、代入が実行され、入力文字列が収集されます。

文字は順番に入力され([6C71H](#6c71h))、[BUF](#buf)に格納されます。これは、正しい区切り文字が見つかるか、EOFに達するか、[BUF](#buf)が一杯になるまで続きます(6E41H)。終了条件に達し、かつ代入先が数値変数である場合、文字列は[DAC](#dac)([3299H](#3299h))で数値形式に変換されます。代入先が文字列変数である場合、文字列が解析され、結果ディスクリプタが作成されます(6638H)。

"`LINE INPUT`" の場合、CR コードに達するまですべての文字が受け入れられます。ただし、この CR コードの前に LF コードがある場合は、区切り文字として機能せず、文字列の一部としてのみ受け入れられます。数値変数への "`INPUT`" の場合、先頭のスペースは削除され、CR コード、スペース、またはカンマに達するまで文字が受け入れられます。"`LINE INPUT`" の場合、LF コードが先行する CR コードは区切り文字として機能しません。ただし、この場合、CR コードは [BUF](#buf) に配置されず、無視されます。文字列変数への "`INPUT`" の場合、先頭のスペースは削除され、CR またはカンマに達するまで文字が受け入れられます。"`LINE INPUT`" の場合、LF コードが先行する CR コードは区切り文字として機能しません。ただし、この場合、どちらのコードも [BUF](#buf) に配置されず、無視されます。スペースの後に読み込まれた最初の文字が二重引用符文字である場合、代替モードに移行します。この場合、すべての文字が受け入れられ、次の二重引用符区切り文字が読み込まれるまで [BUF](#buf) に格納されます。

入力文字列が受け入れられると、終了区切り文字が検査され、末尾の文字に関して特別なアクションが必要かどうかが確認されます。入力文字列が二重引用符またはスペースで区切られている場合、後続のスペースは読み込まれ、スペース以外の文字が見つかるまで無視されます。この文字がコンマまたは CR コードの場合、受け入れられますが無視されます。それ以外の場合は、文字を I/O バッファに返すために、プットバック関数 ([6F8FH](#6f8fh)) がディスパッチされます。入力文字列が CR コードで区切られている場合は、次の文字が読み込まれてチェックされます。これが LF コードの場合、受け入れられますが無視されます。LF コードでない場合は、文字を I/O バッファに返すために、プットバック関数 ([6F8FH](#6f8fh)) がディスパッチされます。

<a name="6e6bh"></a>
<a name="6e6eh"></a>
<a name="6e71h"></a>
<a name="6e74h"></a>
<a name="6e77h"></a>
<a name="6e7ah"></a>
<a name="6e7dh"></a>
<a name="6e80h"></a>
<a name="6e83h"></a>
<a name="6e86h"></a>

    Address... 6E6BH

これは10個のファイルI/O関連エラージェネレータのグループです。レジスタEには関連するエラーコードがロードされ、制御はエラーハンドラ([406FH](#406fh))に移ります。

|ADDRESS|ERROR
|-------|------------------------
|6E6BH  |Bad file name
|6E6EH  |File already open
|6E71H  |Direct statement in file
|6E74H  |File not found
|6E77H  |File not open
|6E7AH  |Field overflow
|6E7DH  |Bad file number
|6E80H  |Internal error
|6E83H  |Input past end
|6E86H  |Sequential I/O only

</a>

<a name="6e92h"></a>

    Address... 6E92H

これは「`BSAVE`」ステートメントハンドラです。ファイルスペックが解析され([6A0EH](#6a0eh))、開始アドレスが評価されます([6F0BH](#6f0bh))。次に、終了アドレスが評価され([6F0BH](#6f0bh))、[SAVEND](#savend)に格納されます。続いて、オプションのエントリアドレス([6F0BH](#6f0bh))が[SAVENT](#savent)に格納されます。エントリアドレスが存在しない場合は、代わりに開始アドレスが使用されます。デバイスコードがCASであるかどうかがチェックされ、CASでない場合は「`Bad file name`」エラーが生成され([6E6BH](#6e6bh))、データがカセットに書き込まれます([6FD7H](#6fd7h))。バッファリングは行われず、データは直接カセットに書き込まれ、エラーチェック情報はデータに付随しないことに注意してください。

<a name="6ec6h"></a>

    Address... 6EC6H

これは「`BLOAD`」文ハンドラです。ファイル仕様が解析され([6A0EH](#6a0eh))、プログラムテキストに自動実行オプション「`R`」が指定されている場合は、[RUNBNF](#runbnf)が非ゼロに設定されます。次に、オプションのロードオフセット（デフォルト値はゼロ）が評価され([6F0BH](#6f0bh))、デバイスコードがCASであるかどうかが確認されます。CASでない場合は、「`Bad file name`」エラーが生成されます([6E6BH](#6e6bh))。その後、データはカセットから直接読み込まれます([7014H](#7014h))。「`BSAVE`」と同様に、バッファリングやエラーチェックは行われません。

<a name="6ef4h"></a>

    Address... 6EF4H

"`BLOAD`" ステートメントハンドラがメモリへのデータのロードを完了すると、制御はこのルーチンに移ります。[RUNBNF](#runbnf) がゼロの場合、バッファ 0 が閉じられ ([6B24H](#6b24h))、制御は Runloop に戻ります。それ以外の場合、バッファ 0 が閉じられ ([6B24H](#6b24h))、戻りアドレス 6CF3H が設定され (このルーチンはプログラムテキストポインタをレジスタペア HL にポップバックし、Runloop に戻ります)、制御は [SAVENT](#savent) に含まれるアドレスに移ります。

<a name="6f0bh"></a>

    Address... 6F0BH

このルーチンは、「`BLOAD`」および「`BSAVE`」ハンドラによってアドレスオペランドを評価するために使用され、結果はレジスタペアDEに返されます。オペランドは評価され（4C64H）、その後整数（[5439H](#5439h)）に変換されます。

<a name="6f15h"></a>

    Address... 6F15H

このルーチンは、ファイルスペックアナライザによって「`CAS:`」のようなデバイス名を解析するために使用されます。エントリ時にレジスタペアHLはファイルスペック文字列の先頭を指し、レジスタEにはその長さが格納されます。デバイス名が存在しない場合は、デフォルトのデバイスコード（CAS=FFH）がレジスタAにフラグZとともに返されます。有効なデバイス名が存在する場合は、そのコードがレジスタAにフラグNZとともに返されます。

ファイルスペックは「:」文字が見つかるまで検査され、その後、デバイステーブル6F76Hにある有効なデバイス名とそれぞれ比較されます。一致するものが見つかった場合、デバイスコードがテーブルから取得され、レジスタAに返されます。一致するものが見つからない場合、制御は外部ROM検索ルーチン([55F8H](#55f8h))に移ります。比較のため、小文字は大文字に変換されることに注意してください。したがって、例えばcrtとCRTは同じデバイスです。

<a name="6f76h"></a>

    Address... 6F76H

このテーブルはデバイス名パーサーによって使用され、標準の MSX マシンで使用可能な 4 つのデバイス名とコードが含まれています。

    CAS ... FFH LPT ... FEH CRT ... FDH GRP ... FCH

</a>

<a name="6f87h"></a>

    Address... 6F87H

このテーブルは関数ディスパッチャ([6F8FH](#6f8fh))によって使用され、4つの標準MSXデバイスのそれぞれに対する関数デコードテーブルのアドレスが含まれています。

    CAS ... 71C7H LPT ... 72A6H CRT ... 71A2H GRP ... 7182H

</a>

<a name="6f8fh"></a>

    Address... 6F8FH

これはファイルI/O関数ディスパッチャです。インタープリタのバッファ構造と連携することで、デバイスに依存しない一貫したデータ入出力方法を提供します。必要な機能コードはレジスタAに、バッファFCBのアドレスはレジスタペアHLに設定されます。

FCBのバイト4からデバイスコードが取得され、それが4つの標準デバイスのいずれかであるかどうかが検査されます。そうでない場合は、制御は外部ROM関数ディスパッチャ([564AH](#564ah))に移ります。そうでない場合は、デバイスの関数デコードテーブルのアドレスが6F87Hのテーブルから取得され、そこから必要な関数のアドレスが取得され、制御は関連する関数ハンドラに移されます。

<a name="6fb7h"></a>

    Address... 6FB7H

これは「`CSAVE`」ステートメントハンドラです。ファイル名（7098H）が評価され、続いてオプションのボーレートオペランド（[7A2DH](#7a2dh)）が評価されます。その後、識別ブロックがファイルタイプバイトD3Hでカセット（[7125H](#7125h)）に書き込まれます。プログラムテキストエリアの内容は、単一のデータブロック（[713EH](#713eh)）としてカセットに直接書き込まれます。データにはエラーチェック情報は含まれないことに注意してください。

<a name="6fd7h"></a>

    Address... 6FD7H

制御は「`BSAVE`」ステートメントハンドラからこのルーチンに移り、メモリブロックをカセットに書き込みます。まず、識別ブロックがファイルタイプバイトD0Hでカセット（[7125H](#7125h)）に書き込まれます。次にモーターがオンになり、短いヘッダーがカセット（[72F8H](#72f8h)）に書き込まれます。開始アドレスはZ80スタックからポップされ、LSBを先頭にMSBを2番目にカセットに書き込まれます（[7003H](#7003h)）。停止アドレスは[SAVEND](#savend)から取得され、LSBを先頭にMSBを2番目にカセットに書き込まれます（[7003H](#7003h)）。エントリアドレスは[SAVENT](#savent)から取得され、LSBを先頭にMSBを2番目にカセットに書き込まれます（[7003H](#7003h)）。必要なメモリ領域がカセットに1バイトずつ書き込まれ（[72DEH](#72deh)）、標準ルーチン[TAPOOF](#tapoof)によってカセットモーターが停止します。データにはエラーチェック情報は含まれませんのでご注意ください。

<a name="7003h"></a>

    Address... 7003H

このルーチンは、最初にレジスタL([72DEH](#72deh))、次にレジスタH([72DEH](#72deh))を使用して、レジスタペアHLの内容をカセットに書き込みます。

<a name="700bh"></a>

    Address... 700BH

このルーチンはカセットから 2 バイトを読み取り、最初のバイトをレジスタ L ([72D4H](#72d4h)) に格納し、2 番目のバイトをレジスタ H ([72D4H](#72d4h)) に格納します。

<a name="7014h"></a>

    Address... 7014H

カセットからメモリにデータをロードするために、制御は「`BLOAD`」ステートメントハンドラからこのルーチンに移ります。カセットは、ファイルタイプがD0Hで正しいファイル名を持つ識別ブロックが見つかるまで読み取られます（[70B8H](#70b8h)）。次に、データブロックヘッダーがカセット上に配置されます（[72E9H](#72e9h)）。オフセット値はZ80スタックからポップされ、カセットの開始アドレス（[700BH](#700bh)）に加算されます。停止アドレスはカセットから読み取られ（[700BH](#700bh)）、これにもオフセットが加算されます。エントリアドレスはカセットから読み取られ（[700BH](#700bh)）、自動実行が必要な場合に備えて[SAVENT](#savent)に格納されます。その後、カセット([72D4H](#72d4h))から連続するデータバイトが読み出され、メモリ内の先頭アドレスに配置され、停止アドレスに達するまでメモリに格納されます。最後に、[TAPIOF](#tapiof)標準ルーチンによってモーターが停止し、制御は「`BLOAD`」終端ポイント([6EF4H](#6ef4h))に移ります。

<a name="703fh"></a>

    Address... 703FH

これは「`CLOAD`」および「`CLOAD?`」文のハンドラです。まず、プログラムテキストの末尾に「`PRINT`」トークン（91H）があるかどうかがチェックされ、「`?`」文字がトークン化されます。次に、ファイル名が評価され（[708CH](#708ch)）、カセットが読み取られ、ファイルタイプがD3Hで正しいファイル名を持つ識別ブロックが見つかるまで読み取られます（[70B8H](#70b8h)）。「`CLOAD`」の場合、現在のプログラムテキストを消去するために「`NEW`」操作が実行され（6287H）。「`CLOAD?`」の場合、プログラムテキスト領域内のすべてのポインタが、カセットデータと一致するように行番号（54EAH）に変換されます。

データブロックヘッダーはカセット上にあり、カセットから読み取られた連続データバイトはメモリに格納されるか、現在のメモリ内容と比較されます ([715DH](#715dh))。データブロックの読み取りが完了すると、「`OK`」というメッセージが表示され ([6678H](#6678h))、制御はインタープリタメインループの最後 (4237H) に直接移り、変数ストレージポインタがリセットされます。「`CLOAD?`」の場合、カセットバイトがメモリ内のプログラムテキストバイトと一致しない場合、データブロックの読み取りは終了します。このエラーが発生したアドレスがプログラムテキスト領域の末尾より上であれば、ハンドラは前と同様に「`OK`」メッセージで終了します。それ以外の場合は、「`Verify error`」が生成されます。

<a name="708ch"></a>

    Address... 708CH

このルーチンは、「`CLOAD`」および「`CSAVE`」ステートメントハンドラによって、プログラムテキスト内のファイル名を評価するために使用されます。2つのハンドラは異なるエントリポイントを使用するため、「`CLOAD`」ではヌルファイル名が許可されますが、「`CSAVE`」では許可されません。ファイル名文字列は評価され([4C64H](#4c64h))、そのストレージが解放され(680FH)、最初の6文字が[FILNAM](#filnam)にコピーされます。ファイル名が6文字を超える場合、超過分は無視されます。ファイル名が6文字未満の場合は、[FILNAM](#filnam)にスペースが埋め込まれます。

<a name="70b8h"></a>

    Address... 70B8H

このルーチンは、「`CLOAD`」および「`BLOAD`」ステートメントハンドラ、およびディスパッチャオープン関数（デバイスがCASでモードが入力の場合）で使用され、カセット上の識別ブロックを検索します。エントリ時にファイル名は[FILNAM](#filnam)に格納され、ファイルタイプはレジスタCに格納されます。トークン化されたBASICファイル（`CLOAD`）の場合はD3H、バイナリファイル（`BLOAD`）の場合はD0H、ASCIIファイル（`LOAD`またはデータ）の場合はEAHに格納されます。

カセット モーターがオンになり、ヘッダーが見つかるまでカセットが読み取られます ([72E9H](#72e9h))。各識別ブロックの前には 10 個のファイル タイプ文字が付けられているため、カセットから連続する文字が読み取られ ([72D4H](#72d4h))、必要なファイル タイプと比較されます。ファイル タイプ文字が一致しない場合は、制御がルーチンの先頭に戻り、次のヘッダーが検索されます。それ以外の場合は、次の 6 文字が読み込まれ ([72D4H](#72d4h))、[FILNAM](#filnam) に格納されます。[FILNAM](#filnam) がスペースで一杯の場合は、ファイル名の一致は試行されず、識別ブロックが見つかります。それ以外の場合は、[FILNAM](#filnam) と [FILNM2](#filnm2) の内容が比較され、これが必要なファイルかどうかが判断されます。一致が見つからず、インタープリタがダイレクトモードの場合、「`Skip:`」というメッセージ([710DH](#710dh))に続いてファイル名が表示されます。その後、制御はルーチンの先頭に戻り、次のヘッダーを試行します。一致が見つからず、インタープリタがダイレクトモードの場合、「`Found:`」というメッセージ([710DH](#710dh))に続いてファイル名が表示され、ルーチンは終了します。

<a name="70ffh"></a>

    Address... 70FFH

これは、ゼロ バイトで終了するプレーン テキスト メッセージ「`Found:`」です。

<a name="7106h"></a>

    Address... 7106H

これは、ゼロ バイトで終了するプレーン テキスト メッセージ「`Skip :`」です。

<a name="710dh"></a>

    Address... 710DH

[CURLIN](#curlin) によってインタープリタがプログラム モードであることが示されない限り、このルーチンは最初にレジスタ ペア HL でアドレスが指定されたメッセージ ([6678H](#6678h)) を表示し、その後に [FILNM2](#filnm2) に含まれる 6 文字を表示します。

<a name="7125h"></a>

    Address... 7125H

このルーチンは、「`CSAVE`」および「`BSAVE`」ステートメントハンドラ、およびディスパッチャオープン関数（デバイスがCASでモードが出力の場合）で使用され、カセットに識別ブロックを書き込みます。エントリ時にファイル名は[FILNAM](#filnam)に、ファイルタイプはレジスタAに格納されます。トークン化されたBASIC（`CSAVE`）ファイルの場合はD3H、バイナリ（`BSAVE`）ファイルの場合はD0H、ASCII（`SAVE`またはデータ）ファイルの場合はEAHに格納されます。カセットモーターがオンになり、長いヘッダーがカセット（[72F8H](#72f8h)）に書き込まれます。その後、ファイルタイプバイトがカセット（[72DEH](#72deh)）に10回書き込まれ、その後に[FILNAM](#filnam)の最初の6文字（[72DEH](#72deh)）が書き込まれます。カセット モーターは [TAPOOF](#tapoof) 標準ルーチンによってオフになり、ルーチンは終了します。

<a name="713eh"></a>

    Address... 713EH

このルーチンは、「`CSAVE`」ステートメントハンドラによって使用され、プログラムテキスト領域を単一のデータブロックとしてカセットに書き込みます。プログラムテキスト内のすべてのポインタは、テキストアドレスを独立させるため、行番号（54EAH）に再変換されます。カセットモーターがオンになり、短いヘッダー（[72F8H](#72f8h)）がカセットに書き込まれます。次に、プログラムテキスト領域全体が1バイトずつカセットに書き込まれ（[72DEH](#72deh)）、最後に7つのゼロバイト（[72DEH](#72deh)）が終端文字として付加されます。その後、[TAPOOF](#tapoof)標準ルーチンによってカセットモーターがオフになり、ルーチンが終了します。

<a name="715dh"></a>

    Address... 715DH

このルーチンは、「`CLOAD`」および「`CLOAD?`」ステートメントハンドラによって使用され、単一のデータブロックをプログラムテキストエリアに読み込むか、現在の内容と比較します。エントリ時にレジスタAには、2つのステートメントを区別するためのフラグが格納されます。「`CLOAD`」の場合は00H、「`CLOAD?`」の場合はFFHです。カセットモーターがオンになり、最初のヘッダー（[72E9H](#72e9h)）が検索されます。カセットから連続する文字が読み込まれ（[72D4H](#72d4h)）、プログラムテキストエリアに格納されるか、現在の内容と比較されます。現在のステートメントが「`CLOAD?`」の場合、カセットの文字がメモリの文字と一致しなければ、ルーチンはFLAG NZで終了します。一致しない場合は、10個の連続するゼロが見つかるまでデータが読み込まれます。このゼロのシーケンスは、最後のプログラム行の行末文字、エンドリンク、および「`CSAVE`」によって追加された7個の終端ゼロで構成されます。このシーケンス中に「`CLOAD?`」によって使用される場合、メモリ比較がまだ進行中であるため、ルーチンは終了する可能性があります。これが、「`CLOAD?`」ハンドラの終了条件のコーディングがかなり特異な理由です。

<a name="7182h"></a>

    Address... 7182H

このテーブルは、GRPデバイスのファンクションコードをデコードする際にディスパッチャによって使用されます。このテーブルには、各ファンクションコードのハンドラのアドレスが含まれており、そのほとんどは実際にはエラージェネレータです。

|TO     |FUNCTION
|-------|---------------------
|71B6H  | 0, open
|71C2H  | 2, close
|6E86H  | 4, random
|7196H  | 6, sequential output
|475AH  | 8, sequential input
|475AH  |10, loc
|475AH  |12, lof
|475AH  |14, eof
|475AH  |16, fpos
|475AH  |18, putback

</a>

<a name="7196h"></a>

    Address... 7196H

これはGRPデバイスのディスパッチャシーケンシャル出力ルーチンです。まず[SCRMOD](#scrmod)がチェックされ、画面がテキストモードの場合、"`Illegal function call`"エラー(475AH)が生成されます。出力される文字はレジスタCから取得され、制御は[GRPPRT](#grpprt)標準ルーチンに移ります。

<a name="71a2h"></a>

    Address... 71A2H

このテーブルは、CRTデバイスのファンクションコードをデコードする際にデバイスディスパッチャによって使用されます。このテーブルには、各ファンクションコードのハンドラのアドレスが含まれており、そのほとんどは実際にはエラージェネレータです。

|TO     |FUNCTION
|-------|---------------------
|71B6H  | 0, open
|71C2H  | 2, close
|6E86H  | 4, random
|71C3H  | 6, sequential output
|475AH  | 8, sequential input
|475AH  |10, loc
|475AH  |12, lof
|475AH  |14, eof
|475AH  |16, fpos
|475AH  |18, putback

</a>

<a name="71b6h"></a>

    Address... 71B6H

これはCRT、LPT、およびGRPデバイスのディスパッチャオープンルーチンです。レジスタEの必要なモードがチェックされ、入力または追加の場合は「`Bad file name`」エラー([6E6BH](#6e6bh))が生成されます。その後、FCBのアドレスがFCBのバイト0のモードである[PTRFIL](#ptrfil)に格納され、ルーチンは終了します。このルーチンの末尾(71C2H)にあるZ80 RET命令は、CRT、LPT、およびGRPデバイスのディスパッチャクローズルーチンであることに注意してください。

<a name="71c3h"></a>

    Address... 71C3H

これはCRTデバイスのディスパッチャシーケンシャル出力ルーチンです。出力する文字はレジスタCから取得され、制御は[CHPUT](#chput)標準ルーチンに移ります。

<a name="71c7h"></a>

    Address... 71C7H

このテーブルは、ディスパッチャがCASデバイスのファンクションコードをデコードする際に使用されます。このテーブルには、各ファンクションコードのハンドラのアドレスが含まれており、そのうちいくつかはエラージェネレータです。

|TO     |FUNCTION
|-------|---------------------
|71DBH  | 0, open
|7205H  | 2, close
|6E86H  | 4, random
|722AH  | 6, sequential output
|723FH  | 8, sequential input
|475AH  |10, loc
|475AH  |12, lof
|726DH  |14, eof
|475AH  |16, fpos
|727CH  |18, putback

</a>

<a name="71dbh"></a>

    Address... 71DBH

これはCASデバイスのディスパッチャオープンルーチンです。FCBのバイト6に保持されている現在のI/Oバッファ位置と、プットバック文字を保持する[CASPRV](#casprv)は両方ともゼロに設定されます。レジスタEに指定された必要なモードが検査され、追加モードまたはランダムモードの場合は「`Bad file name`」エラー([6E6BH](#6e6bh))が生成されます。出力モードの場合は、識別ブロックがカセット([7125H](#7125h))に書き込まれ、入力モードの場合は、正しい識別ブロックがカセット([70B8H](#70b8h))に配置されます。FCBアドレスはFCBのバイト0のモードである[PTRFIL](#ptrfil)に格納され、ルーチンは終了します。

<a name="7205h"></a>

    Address... 7205H

これはCASデバイスのディスパッチャクローズルーチンです。FCBのバイト0を調べ、モードが入力の場合、[CASPRV](#casprv)をゼロクリアしてルーチンを終了します。それ以外の場合、I/Oバッファの残りの部分にファイル終了文字(1AH)が書き込まれ、I/Oバッファの内容がカセット(722FH)に書き込まれます。その後、[CASPRV](#casprv)をゼロクリアしてルーチンを終了します。

<a name="722ah"></a>

    Address... 722AH

これはCASデバイスのディスパッチャシーケンシャル出力ルーチンです。出力する文字はレジスタCから取得され、I/Oバッファ内の次の空き位置([728BH](#728bh))に配置されます。FCBのバイト6(I/Oバッファ位置)がインクリメントされます。I/Oバッファ位置が0に戻った場合、I/Oバッファには256文字あり、カセットに書き込む必要があることを意味します。カセットモーターがオンになり、短いヘッダー([72F8H](#72f8h))がカセットに書き込まれ、続いてI/Oバッファの内容([72DEH](#72deh))が書き込まれます。その後、[TAPOOF](#tapoof)標準ルーチンによってモーターがオフになります。

<a name="723fh"></a>

    Address... 723FH

これはCASデバイスのディスパッチャシーケンシャル入力ルーチンです。[CASPRV](#casprv)は最初にチェックされ([72BEH](#72beh))、プットバックされた文字が含まれているかどうかが判断されます。プットバックされた場合、その内容はゼロ以外になります。文字が含まれている場合、ルーチンはレジスタAの文字で終了します。そうでない場合は、I/Oバッファ位置がチェックされ([729BH](#729bh))、文字が含まれているかどうかが判断されます。I/Oバッファが空の場合は、カセットモーターがオンになり、ヘッダーが配置されます([72E9H](#72e9h))。次に、256文字が読み込まれ([72D4H](#72d4h))、カセットモーターが[TAPION](#tapion)標準ルーチンによってオフになり、I/Oバッファ位置がゼロにリセットされます。次に、現在のI/Oバッファ位置から文字が取得され、位置がインクリメントされます。最後に、文字がファイル終了文字 (1AH) であるかどうかがチェックされます。そうでない場合、ルーチンはレジスタAに文字が格納され、FLAG NC がセットされて終了します。そうでない場合、ファイル終了文字は [CASPRV](#casprv) に格納されます。これにより、後続の入力要求は常にファイル終了状態を返し、ルーチンは FLAG C で終了します。

<a name="726dh"></a>

    Address... 726DH

これはCASデバイスのディスパッチャEOFルーチンです。次の文字([723FH](#723fh))が入力され、[CASPRV](#casprv)に格納されます。次に、ファイル終了コード(1AH)かどうかが判定され、その結果が整数として[DAC](#dac)に格納されます。偽の場合は0、真の場合はFFFFHです。

<a name="727ch"></a>

    Address... 727CH

これはCASデバイスのディスパッチャプットバックルーチンです。文字は[CASPRV](#casprv)に格納され、次の入力要求時に取得されます。

<a name="7281h"></a>

    Address... 7281H

このルーチンは、ディスパッチャのクローズ関数によって使用され、I/O バッファに文字があるかどうかを確認し、FCB 内の I/O バッファ位置バイトをゼロにします。

<a name="728bh"></a>

    Address... 728BH

このルーチンは、ディスパッチャの順次出力機能によって使用され、レジスタ A の文字を現在の I/O バッファ位置の I/O バッファに配置し、その後増分します。

<a name="729bh"></a>

    Address... 729BH

このルーチンは、ディスパッチャの順次入力機能によって使用され、現在の I/O バッファ位置の文字を収集し、その後増分します。

<a name="72a6h"></a>

    Address... 72A6H

このテーブルは、ディスパッチャがLPTデバイスのファンクションコードをデコードする際に使用されます。このテーブルには、各ファンクションコードのハンドラのアドレスが含まれており、そのほとんどはエラージェネレータです。

|TO     |FUNCTION
|-------|---------------------
|71B6H  | 0, open
|71C2H  | 2, close
|6E86H  | 4, random
|72BAH  | 6, sequential output
|475AH  | 8, sequential input
|475AH  |10, loc
|475AH  |12, lof
|475AH  |14, eof
|475AH  |16, fpos
|475AH  |18, putback

</a>

<a name="72bah"></a>

    Address... 72BAH

これはLPTデバイスのディスパッチャシーケンシャル出力ルーチンです。出力する文字はレジスタCから取得され、制御は[OUTDLP](#outdlp)標準ルーチンに移ります。

<a name="72beh"></a>

    Address... 72BEH

このルーチンは、ディスパッチャのシーケンシャル入力関数によって使用され、[CASPRV](#casprv) にプットバック文字が存在するかどうかを確認し、存在しない場合はフラグ Z を返します。存在する場合は、[CASPRV](#casprv) をゼロにし、その文字がファイル終端文字 (1AH) であるかどうかをテストします。存在しない場合は、レジスタ A の文字とフラグ NZ,NC を返します。存在する場合は、ファイル終端文字を [CASPRV](#casprv) に戻し、ルーチンはフラグ Z,C を返します。

<a name="72cdh"></a>

    Address... 72CDH

このルーチンは、さまざまなディスパッチャ関数によって、レジスタ E のモードが追加モードであるかどうかを確認するために使用されます。追加モードである場合は、「`Bad file name`」エラーが生成されます ([6E6BH](#6e6bh))。

<a name="72d4h"></a>

    Address... 72D4H

このルーチンは、様々なディスパッチャ関数によってカセットから文字を読み取るために使用されます。文字は[TAPIN](#tapin)標準ルーチンを介して読み取られ、FLAG Cが返された場合は「`デバイスI/Oエラー`」([73B2H](#73b2h))が生成されます。

<a name="72deh"></a>

    Address... 72DEH

このルーチンは、様々なディスパッチャ関数によってカセットに文字を書き込むために使用されます。文字は[TAPOUT](#tapout)標準ルーチンを介して書き込まれ、FLAG Cが返された場合は「`デバイスI/Oエラー`」([73B2H](#73b2h))が生成されます。

<a name="72e9h"></a>

    Address... 72E9H

このルーチンは、様々なディスパッチャ関数によって、カセットモーターを入力用にオンにするために使用されます。モーターは[TAPION](#tapion)標準ルーチンを介してオンになり、FLAG Cが返された場合は「`デバイスI/Oエラー`」([73B2H](#73b2h))が生成されます。

<a name="72f8h"></a>

    Address... 72F8H

このルーチンは、さまざまなディスパッチャ関数によってカセット モーターをオンにして出力するために使用され、制御は [TAPOON](#tapoon) 標準ルーチンに転送されるだけです。

<a name="7304h"></a>

    Address... 7304H

このルーチンは、インタープリタのメインループの「`OK`」ポイント、「`END`」ステートメントハンドラ、およびプリンタをシャットダウンするための実行クリアルーチンによって使用されます。[PRTFLG](#prtflg) が最初にゼロにクリアされ、次に [LPTPOS](#lptpos) がテストされ、出力された文字がプリンタの行バッファに残っているかどうかが確認されます。残っている場合は、CR,LF シーケンスが発行され、プリンタがフラッシュされ、[LPTPOS](#lptpos) がゼロにクリアされます。

<a name="7323h"></a>

    Address... 7323H

このルーチンは、[OUTDO](#outdo) 標準ルーチンを介して、現在の出力デバイスに CR,LF シーケンスを発行します。その後、プリンタまたは画面がアクティブかどうかに応じて、[LPTPOS](#lptpos) または [TTYPOS](#ttypos) がゼロに設定されます。

<a name="7347h"></a>

    Address... 7347H

このルーチンは、Factor Evaluatorが「`INKEY$`」関数を適用するために使用します。キーボードバッファの状態は、[CHSNS](#chsns) 標準ルーチンによって検査されます。バッファが空の場合、ダミーのヌル文字列ディスクリプタのアドレスが [DAC](#dac) に返されます。それ以外の場合は、[CHGET](#chget) 標準ルーチンによってキーボードバッファから次の文字が読み取られます。十分なスペースがあることを確認した後 (6625H)、文字が文字列記憶領域にコピーされ、結果ディスクリプタが作成されます (6821H)。

<a name="7367h"></a>

    Address... 7367H

このルーチンは、「`LIST`」文ハンドラによって使用され、[OUTDO](#outdo)標準ルーチンを介して現在の出力デバイスに文字を出力します。出力された文字がLFコードの場合、CRコードも出力されます。

<a name="7374h"></a>

    Address... 7374H

このルーチンは、キーボードではなくI/Oバッファからの入力、つまり「`LOAD`」文がアクティブな場合に、インタープリタのメインループによってテキスト行を収集するために使用されます。文字は順に入力され（[6C71H](#6c71h)）、[BUF](#buf)に格納されます。[BUF](#buf)が一杯になるか、CRが検出されるか、ファイルの終わりに達するまで格納されます。LFコードはフィルタリングされますが、それ以外の文字はすべて受け入れられます。[BUF](#buf)が一杯になるかCRが検出された場合、ルーチンは単にその行をメインループに返します。[BUF](#buf)に文字がある状態でファイルの終わりに達した場合、その行はメインループに返されます。[BUF](#buf)に文字がない状態でファイルの終わりに達した場合、I/Oバッファ0が閉じられ（6D7BH）、自動実行が必要かどうかを判断するために[FILNAM](#filnam)がチェックされます。そうでない場合、制御はインタープリタの「`OK`」ポイント(411EH)に戻ります。そうでない場合、システムはクリアされ([629AH](#629ah))、制御はRunloop([4601H](#4601h))に移り、プログラムを実行します。

<a name="73b2h"></a>

    Address... 73B2H

これは「`デバイス I/O エラー`」ジェネレータです。

<a name="73b7h"></a><a name="モーター"></a>

    Address... 73B7H

これは「`MOTOR`」文ハンドラです。オペランドが存在しない場合は、レジスタAにFFHが格納された状態で[STMOTR](#stmotr)標準ルーチンに制御が移ります。「`OFF`」トークン（EBH）が続く場合は、レジスタAに00Hが格納された状態で制御が移ります。「`ON`」トークン（95H）が続く場合は、レジスタAに01Hが格納された状態で制御が移ります。

<a name="73cah"></a><a name="sound">​​</a>

    Address... 73CAH

これは「`SOUND`」ステートメントハンドラです。レジスタ番号オペランド（14未満でなければなりません）が評価され（521CH）、レジスタAに格納されます。データオペランドが評価され（521CH）、ビット7がセットされ、ビット6がリセットされます。これは、PSG補助I/Oポートモードが変更されないようにするためです。データオペランドはレジスタEに格納され、制御は[WRTPSG](#wrtpsg)標準ルーチンに移ります。

<a name="73e4h"></a>

    Address... 73E4H

これは、ヌル文字列オペランドを 1 文字の空白文字列に置き換えるために "`PLAY`" ステートメント ハンドラーによって使用される単一の ASCII スペースです。

<a name="73e5h"></a><a name="プレイ"></a>

    Address... 73E5H

これは「`PLAY`」ステートメントハンドラです。752EHにある「`PLAY`」コマンドテーブルのアドレスは、マクロ言語パーサーの[MCLTAB](#mcltab)に格納され、[PRSCNT](#prscnt)はゼロに設定されます。最初の文字列オペランド（必須）が評価され（[4C64H](#4c64h)）、そのストレージが解放され（[67D0H](#67d0h)）、その長さとアドレスが[VCBA](#vcba)のバイト2、3、4に配置されます。チャンネルのスタックポインタは[VCBA](#vcba)+33に初期化され、[VCBA](#vcba)のバイト5と6に配置されます。ステートメントにさらにテキストが存在する場合、このプロセスはボイスBとCに対して、最大3つのオペランドが評価されるまで繰り返されます。評価されたオペランドが最大3つを超えると、「`構文エラー`」が生成されます（[4055H](#4055h)）。存在する文字列オペランドが3つ未満の場合、未使用の各ボイスのキュー（[7507H](#7507h)）にキュー終了マーク（FFH）が配置されます。次にレジスタ A がゼロに設定され、音声 A が選択され、制御は再生メインループにドロップされます。

<a name="744dh"></a>

    Address... 744DH

これは再生のメインループです。現在のキューの空きバイト数をチェックし([7521H](#7521h))、残りが8バイト未満の場合、キューが空になるまで待たずに次のボイスを選択します(74D6H)。次に、オペランド文字列の残りの長さを現在のボイスバッファから取得し、解析するバイトが0バイト残っている場合、ループは再び次のボイスにスキップします(74D6H)。それ以外の場合、現在の文字列の長さとアドレスをボイスバッファから取得し、マクロ言語パーサーの[MCLLEN](#mcllen)と[MCLPTR](#mclptr)に格納します。古いスタックの内容はボイスバッファからZ80スタック(6253H)にコピーされ、[MCLFLG](#mclflg)が0以外の値に設定され、制御がマクロ言語パーサー([56A2H](#56a2h))に移ります。

マクロ言語パーサーは通常、「`PLAY`」ステートメントのコマンドハンドラーを使用して、文字列がなくなるまで文字列をスキャンします。ただし、音符生成中に音楽キューが一杯になった場合は、異常終了が発生し、再生メインループ（748EH）に強制的に戻されます。これにより、キューが空になるのを待たずに次のボイスを処理できます。制御が正常に戻ると、現在のキュー（[7507H](#7507h)）にキュー終了マークが配置され、[PRSCNT](#prscnt)がインクリメントされて、完了した文字列の数が表示されます。制御が異常終了した場合、Z80スタックに残っているものはすべて現在のボイスバッファ（6253H）にコピーされます。「`X`」コマンドが関係するマクロ言語パーサーの再帰的な性質のため、終了時に元の文字列が中断されたポイントを示す4バイトの文字列ディスクリプタがZ80スタックに複数残されることがあります。スタックの内容をボイスバッファに保存しておくと、ループが再びそのボイスに戻った際に復元できます。各ボイスバッファには16バイトしか存在しないため、スタックに大量のデータが残っていると「`Illegal function call`」エラー（475AH）が発生します。これは、キューが一杯になり、複数のネストされた「X」コマンドが存在する場合に発生します。例えば、以下のようになります。

```
10 A$="XB$;"
20 B$="XC$;"
30 C$="XD$;"
40 D$=STRING$(150,"A")
50 PLAY A$
```

このセクションには、エラーが生成される前に 16 バイトではなく 15 バイトのスタック データのみが許可されるという、ちょっとしたバグがあるようです。

マクロ言語パーサーから制御が戻ると、レジスタ A がインクリメントされて、次に処理するボイスが選択されます。3 つのボイスすべてが処理されると [INTFLG](#intflg) がチェックされ、割り込みハンドラーによって CTRL-STOP が検出された場合、制御は [GICINI](#gicini) 標準ルーチンに移行し、すべての音楽を停止して終了します。 [PRSCNT](#prscnt) のビット 7 が、これがメインループの最初のパスであることを示していると仮定すると、キューが一杯のため一時的に中断されているボイスはなく、[PLYCNT](#plycnt) がインクリメントされ、[STRTMS](#strtms) 標準ルーチンによって割り込みのデキューが開始されます。 次に [PRSCNT](#prscnt) がチェックされ、マクロ言語パーサーによって完了したストリングの数が決まります。3 つのオペランド ストリングがすべて完了している場合、ハンドラーは終了し、それ以外の場合は、制御は再生メインループの開始に戻り、各ボイスを再度試します。

<a name="7507h"></a>

    Address... 7507H

このルーチンは、「`PLAY`」文ハンドラによって使用され、[PUTQ](#putq) 標準ルーチンを介して現在のキューにキュー終了マーク（FFH）を設定します。キューが一杯の場合は、空きができるまで待機します。

<a name="7521h"></a>

    Address... 7521H

このルーチンは、「`PLAY`」文ハンドラによって使用され、[LFTQ](#lftq) 標準ルーチンを介して現在のキューに残っているスペースの量を確認します。残りが8バイト未満の場合（音楽データパケットの最大長は7バイトです）、FLAG C が返されます。

<a name="752eh"></a>

    Address... 752EH

この表には、「`PLAY`」ステートメントコマンドの有効なコマンド文字と対応するアドレスが記載されています。パラメータを取り、その結果表のビット7がセットされるコマンドには、アスタリスクが付けられています。

|CMD    |TO
|-------|-----
|A      |[763EH](#763eh)
|B      |[763EH](#763eh)
|C      |[763EH](#763eh)
|D      |[763EH](#763eh)
|E      |[763EH](#763eh)
|F      |[763EH](#763eh)
|G      |[763EH](#763eh)
|M\*    |[759EH](#759eh)
|V\*    |[7586H](#7586h)
|S\*    |[75BEH](#75beh)
|N\*    |[7621H](#7621h)
|O\*    |[75EFH](#75efh)
|R\*    |[75FCH](#75fch)
|T\*    |[75E2H](#75e2h)
|L\*    |[75C8H](#75c8h)
|X      |[5782H](#5782h)

</a>

<a name="755fh"></a>

    Address... 755FH

このテーブルは、「`PLAY`」ステートメントの「`A`」から「`G`」までのコマンドハンドラによって使用され、0から14までのノートナンバーを756EHのトーンディバイダテーブルへのオフセット値に変換します。ノートナンバーではなく、ノート自体が各オフセット値とともに以下に表示されます。

```
16 ... A-
18 ... A
20 ... A+ or B-
22 ... B or C-
00 ... B+
00 ... C
02 ... C+ or D-
04 ... D
06 ... D+ or E-
08 ... E or F-
10 ... E+
10 ... F
12 ... F+ or G-
14 ... G
16 ... G+
```

</a>

<a name="756eh"></a>

    Address... 756EH

この表には、オクターブ 1 の音を生成するために必要な 12 個の PSG 分周定数が含まれています。各定数に対応する音符と周波数が表示されます。

```
3421 ... C  32.698 Hz
3228 ... C+ 34.653 Hz
3047 ... D  36.712 Hz
2876 ... D+ 38.895 HZ
2715 ... E  41.201 Hz
2562 ... F  43.662 Hz
2419 ... F+ 46.243 Hz
2283 ... G  48.997 Hz
2155 ... G+ 51.908 Hz
2034 ... A  54.995 Hz
1920 ... A+ 58.261 Hz
1812 ... B  61.773 Hz
```

</a>

<a name="7586h"></a>

    Address... 7586H

これは「`PLAY`」文の「`V`」コマンドハンドラです。パラメータ（デフォルト値は8）は、現在のボイスバッファのバイト18に配置されますが、既存の内容のビット6は変更されません。音楽データは生成されません。

<a name="759eh"></a>

    Address... 759EH

これは「`PLAY`」ステートメントの「`M`」コマンドハンドラです。パラメータ（デフォルト値は255）は、現在の音声バッファのバイト19と20に含まれる既存の変調周期と比較されます。両者が一致する場合、ルーチンは何もせずに終了します。一致しない場合は、新しい変調周期が音声バッファに格納され、音声バッファのバイト18のビット6がセットされます。これは、新しい値を次に生成される音楽データパケットに組み込む必要があることを示します。音楽データは生成されません。

<a name="75beh"></a>

    Address... 75BEH

これは「`PLAY`」ステートメントの「`S`」コマンドハンドラです。パラメータは現在のボイスバッファのバイト18に配置され、同じバイトのビット4がセットされて、新しい値が次に生成される音楽データパケットに組み込まれることを示します。音楽データは生成されません。PSGの特性上、シェイプパラメータとボリュームパラメータは相互に排他的であるため、ボイスバッファの同じバイトが両方に使用されます。

<a name="75c8h"></a>

    Address... 75C8H

これは「`PLAY`」文の「`L`」コマンドハンドラです。このパラメータはデフォルト値4で、現在のボイスバッファの16バイト目に配置され、後続の音符の長さの計算に使用されます。音楽データは生成されません。

<a name="75e2h"></a>

    Address... 75E2H

これは「`PLAY`」ステートメントの「`T`」コマンドハンドラです。このパラメータはデフォルト値120で、現在のボイスバッファの17バイト目に配置され、後続の音符の長さの計算に使用されます。これにより、音楽データが生成されます。

<a name="75efh"></a>

    Address... 75EFH

これは「`PLAY`」文の「`O`」コマンドハンドラです。このパラメータはデフォルト値4で、現在のボイスバッファの15バイト目に配置され、後続の音符周波数の計算に使用されます。音楽データは生成されません。

<a name="75fch"></a>

    Address... 75FCH

これは「`PLAY`」文の「`R`」コマンドハンドラです。長さパラメータ（デフォルト値は4）はレジスタペアDEに保持され、トーン分周値0はレジスタペアHLに格納されます。既存の音量値は現在のボイスバッファのバイト18から取得され、一時的に0に置き換えられ、制御はノートジェネレータ（769CH）に渡されます。

<a name="7621h"></a>

    Address... 7621H

これは「`PLAY`」ステートメントの「`N`」コマンドハンドラです。必須パラメータが最初に検査され、0の場合は休符が生成されます（760BH）。96より大きい場合は、「`Illegal function call`」エラーが生成されます（475AH）。それ以外の場合は、ノート番号から12を繰り返し減算し、アンダーフローが発生するまで処理します。その結果、レジスタEに1から9までのオクターブ番号、レジスタCに0から11までのノート番号が取得されます。その後、制御はノートジェネレータ（7673H）に移ります。

<a name="763eh"></a>

    Address... 763EH

これは「`PLAY`」文の「`A`」から「`G`」へのコマンドハンドラです。まず、音符文字が0から14までの音符番号に変換されます。この拡張範囲は、記譜法に暗黙的な冗長性があるために必要です。次に、755FHのテーブルを使用して、トーンディバイダテーブルへのオフセットと、レジスタペアDEに格納された音符のディバイダ定数を取得します。オクターブ値は現在のボイスバッファのバイト15から取得され、正しいオクターブに達するまでディバイダ定数が半分にされます。次に、文字列オペランドを直接調べて([56EEH](#56eeh))、末尾に音符長パラメータが存在するかどうかを判断します。存在する場合は、変換(572FH)され、レジスタCに格納されます。パラメータが存在しない場合は、現在のボイスバッファのバイト16からデフォルトの音符長が取得されます。音符の長さは、次のように計算されます。

    持続時間（割り込みTicks） = 12,000 /（長さ*テンポ）

通常の長さ (4) とテンポ (120) を使用すると、20ミリ秒の割り込みティック25回分、つまり0.5秒の音符の長さが得られます。次に、文字列オペランド ([56EEH](#56eeh)) を調べ、末尾の「.」文字ごとに長さを1.5倍します。最後に、結果の長さをチェックし、5割り込みティック未満の場合は5に置き換えます。したがって、UKマシンで生成できる最短の音符は、テンポや音符の長さに関わらず0.10秒です。

3、5、または 7 バイトの長さになる音楽データ パケットは、キューに配置される前に、現在の音声バッファのバイト 8 ～ 14 に組み立てられます。継続時間は、音声バッファのバイト 8 と 9 に配置されます。音量とフラグ バイトはバイト 18 から取得され、音声バッファのバイト 10 に配置され、割り込み デキュー ルーチンに音量変更を示すためにビット 7 が設定されます。音量バイトのビット 6 が設定されている場合、変調周期はバイト 19 と 20 から取得され、データ パケットのバイト 11 と 12 に追加されます。トーン分割値がゼロでない場合、データ パケットのバイト 11 と 12 (変調周期なし) またはバイト 13 と 14 (変調周期あり) に追加されます。最後に、バイト カウントが音声バッファのバイト 8 の上位 3 ビットにミックスされ、音楽データ パケットの準備が完了します。

トーンディバイダ値がゼロ（休符）の場合、[SAVVOL](#savvol)の内容が静的バッファの18バイト目に復元されます。その後、音楽データパケットは[PUTQ](#putq)標準ルーチンによって現在のキューに配置され、残りの空きバイト数（[7521H](#7521h)）がチェックされます。残り8バイト未満の場合、制御は直接「`PLAY`」ステートメントハンドラ（748EH）に渡されます。それ以外の場合は、制御は通常通りマクロ言語パーサに戻ります。

<a name="7754h"></a>

    Address... 7754H

これは、音符の長さの計算に使用される単精度定数 12,000 です。

<a name="7758h"></a><a name="put"></a>

    Address... 7758H

これは「`PUT`」ステートメントハンドラです。レジスタBは80Hに設定され、制御は「`GET`」ステートメントハンドラに移ります。

<a name="775bh"></a><a name="get"></a>

    Address... 775BH

これは「`GET`」文ハンドラです。レジスタBは「`GET`」と「`PUT`」、そして次に検査されるプログラムトークンを区別するためにゼロに設定されます。その後、制御は「`PUT SPRITE`」文ハンドラ（[7AAFH](#7aafh)）またはDisk BASICの「`GET/PUT`」文ハンドラ（[6C35H](#6c35h)）に移ります。

<a name="7766h"></a><a name="locate"></a>

    Address... 7766H

これは「`LOCATE`」文ハンドラです。列座標が存在する場合は評価（521CH）され、レジスタDに格納されます。存在しない場合は、現在の列が[CSRX](#csrx)から取得されます。行座標が存在する場合は評価（521CH）され、レジスタEに格納されます。存在しない場合は、現在の行が[CSRY](#csry)から取得されます。カーソル切り替えオペランドが存在する場合は評価（521CH）され、レジスタAに、ゼロオペランド（OFF）の場合は78H、非ゼロオペランド（ON）の場合は79Hがロードされます。その後、[OUTDO](#outdo)標準ルーチンを介してESC、78H/79H、"`5`"を出力することで、カーソルが切り替えられます。行座標と列座標はレジスタペアHLに格納され、カーソル位置は[POSIT](#posit)標準ルーチンを介して設定されます。

<a name="77a5h"></a>

    Address... 77A5H

これは「`STOP ON/OFF/STOP`」ステートメントハンドラです。デバイスの[TRPTBL](#trptbl)ステータスバイトのアドレスがレジスタペアHLに格納され、制御は「`ON/OFF/STOP`」ルーチン（77CFH）に移ります。

<a name="77abh"></a>

    Address... 77ABH

これは「`SPRITE ON/OFF/STOP`」ステートメントハンドラです。デバイスの[TRPTBL](#trptbl)ステータスバイトのアドレスがレジスタペアHLに格納され、制御は「`ON/OFF/STOP`」ルーチン（77CFH）に移ります。

<a name="77b1h"></a>

    Address... 77B1H

これは「`INTERVAL ON/OFF/STOP`」文のハンドラです。特定の「`INTERVAL`」トークンがないため（「`INT`」トークンが見つかると制御がここに移ります）、まずプログラムテキスト内で「`E`」と「`R`」の文字がチェックされ、次に「`VAL`」トークン（94H）がチェックされます。デバイスの[TRPTBL](#trptbl)ステータスバイトのアドレスがレジスタペアHLに格納され、制御が「`ON/OFF/STOP`」ルーチン（77CFH）に移ります。

<a name="77bfh"></a>

    Address... 77BFH

これは「`STRIG ON/OFF/STOP`」ステートメントハンドラです。トリガー番号（0～4）が評価され（[7C08H](#7c08h)）、デバイスの[TRPTBL](#trptbl)ステータスバイトのアドレスがレジスタペアHLに格納されます。「`ON/OFF/STOP`」トークンが検査され、[TRPTBL](#trptbl)ステータスバイトがそれに応じて変更されます（77FEH）。その後、制御はRunloop（4612H）に直接移り、次のステートメントの終了まで保留中の割り込みのテストを回避します。

<a name="77d4h"></a>

    Address... 77D4H

これは「`KEY(n) ON/OFF/STOP`」ステートメントハンドラです。1から10までのキー番号が評価され（521CH）、デバイスの[TRPTBL](#trptbl)ステータスバイトのアドレスがレジスタペアHLに格納されます。「`ON/OFF/STOP`」トークンが検査され、[TRPTBL](#trptbl)ステータスバイトがそれに応じて変更されます（77FEH）。[TRPTBL](#trptbl)ステータスバイトのビット0（ONビット）は、[FNKFLG](#fnkflg)の対応するエントリにコピーされ、割り込みキースキャン中に使用され、制御はRunloop（4612H）に直接転送されます。

<a name="77feh"></a>

    Address... 77FEH

このルーチンは、割り込みスイッチングトークンのいずれかの存在を確認し、適切なルーチンに制御を移します。「`ON`」（[631BH](#631bh)）、「`OFF`」（632BH）、「`STOP`」（[6331H](#6331h)）のいずれかです。トークンが存在しない場合は、「`構文エラー`」（4055H）が生成されます。

<a name="7810h"></a>

    Address... 7810H

このルーチンは、「`ON DEVICE GOSUB`」文ハンドラ ([490DH](#490dh)) によって使用され、プログラムテキスト内のデバイストークンをチェックします。デバイストークンが全く存在しない場合（フラグCが返されます）を除き、デバイスの[TRPTBL](#trptbl)エントリ番号がレジスタBに、最大許容行番号オペランドカウントがレジスタCに返されます。

|DEVICE     |TRPTBL#    |LINE NUMBERS
|-----------|-----------|------------
|KEY        |00         |10
|STOP       |10         |01
|SPRITE     |11         |01
|STRIG      |12         |05
|INTERVAL   |17         |01

さらに、「`INTERVAL`」の場合のみ、間隔オペランドが評価され ([542FH](#542fh))、[INTVAL](#intval) と [INTCNT](#intcnt) に配置されます。

<a name="785ch"></a>

    Address... 785CH

このルーチンは、「`ON DEVICE GOSUB`」ステートメントハンドラ([490DH](#490dh))によって使用され、プログラム行のアドレスを[TRPTBL](#trptbl)に格納します。レジスタBに指定された[TRPTBL](#trptbl)エントリ番号は3倍され、テーブルベースに加算されて該当するエントリを指します。次に、レジスタペアDEに指定されたアドレスが、LSBを先頭に、MSBを2番目に格納されます。

<a name="786ch"></a><a name="キー"></a>

    Address... 786CH

これは「`KEY`」文ハンドラです。後続の文字が「`LIST`」トークン（93H）以外の場合、制御は「`KEY n`」文ハンドラ（[78AEH](#78aeh)）に移ります。その後、10個のファンクションキー文字列がそれぞれ[FNKSTR](#fnkstr)から取得され、[OUTDO](#outdo)標準ルーチンによって表示され、各文字列の後にCR,LF（7328H）が付加されます。DEL文字（7FH）または20H未満の制御文字はスペースに置き換えられます。

<a name="78aeh"></a>

    Address... 78AEH

これは、「`KEY n`」、「`KEY(n) ON/OFF/STOP`」、「`KEY ON`」、および「`KEY OFF`」ステートメント ハンドラーです。次のプログラムテキスト文字が「(」の場合、制御は「`KEY(n) ON/OFF/STOP`」ステートメントハンドラ([77D4H](#77d4h))に移ります。「`ON`」トークン(95H)の場合、制御は[DSPFNK](#dspfnk)標準ルーチンに移り、「`OFF`」トークン(EBH)の場合、[ERAFNK](#erafnk)標準ルーチンに移ります。それ以外の場合、ファンクションキー番号が評価され(521CH)、キーの[FNKSTR](#fnkstr)アドレスがレジスタペアDEに格納されます。文字列オペランドが評価され([4C64H](#4c64h))、そのストレージが解放されます([67D0H](#67d0h))。最大15文字が文字列から[FNKSTR](#fnkstr)にコピーされ、未使用の位置はゼロバイトで埋められます。オペランド文字列にゼロバイトが見つかった場合、 「`不正な関数呼び出し`」エラーが発生します（475AH）。その後、制御は[FNKSB](#fnksb)標準ルーチンに移行し、ファンクションキーの表示が有効になっている場合は更新されます。

<a name="7900h"></a>

    Address... 7900H

このルーチンは、Factor Evaluatorによって「`TIME`」関数を適用するために使用されます。[JIFFY](#jiffy) の内容は、単精度数値 (3236H) として [DAC](#dac) に格納されます。

<a name="790ah"></a>

    Address... 790AH

このルーチンは、Factor Evaluatorが「`CSRLIN`」関数を適用するために使用します。[CSRY](#csry) の内容が減算され、整数 (2E9AH) として [DAC](#dac) に格納されます。

<a name="7911h"></a><a name="時間"></a>

    Address... 7911H

これは「`TIME`」文のハンドラです。オペランドは評価され（542FH）、[JIFFY](#jiffy)に格納されます。

<a name="791bh"></a>

    Address... 791BH

このルーチンは、Factor Evaluatorによって「`PLAY`」関数を適用するために使用されます。数値チャンネル選択オペランド([7C08H](#7c08h))が評価されます。これが0の場合、[MUSICF](#musicf)の内容が、0またはFFFFHの整数として[DAC](#dac)に格納されます。それ以外の場合は、チャンネル番号を使用して[MUSICF](#musicf)の適切なビットが選択され、その後、前と同様に整数に変換されます。

<a name="7940h"></a>

    Address... 7940H

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`STICK`」関数を適用するために使用されます。スティック番号(521FH)がチェックされ、レジスタAの[GTSTCK](#gtstck)標準ルーチンに渡されます。結果は整数(4FCFH)として[DAC](#dac)に格納されます。

<a name="794ch"></a>

    Address... 794CH

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`STRIG`」関数を適用するために使用されます。トリガー番号（521FH）がチェックされ、レジスタAの[GTTRIG](#gttrig)標準ルーチンに渡されます。結果は0またはFFFFHの整数として[DAC](#dac)に格納されます。

<a name="795ah"></a>

    Address... 795AH

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`PDL`」関数を適用するために使用されます。パドル番号（521FH）がチェックされ、レジスタAの[GTPDL](#gtpdl)標準ルーチンに渡されます。結果は整数（4FCFH）として[DAC](#dac)に格納されます。

<a name="7969h"></a>

    Address... 7969H

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`PAD`」関数を適用するために使用されます。パッド番号がチェックされ(521F)、レジスタAの[GTPAD](#gtpad)標準ルーチンに渡されます。パッド1、2、5、または6の場合、結果は整数として[DAC](#dac)に格納されます。パッド0、3、4、または7の場合、結果は0またはFFFFHの整数として[DAC](#dac)に格納されます。

<a name="7980h"></a><a name="color"></a>

    Address... 7980H

これは「`COLOR`」文ハンドラです。前景色オペランドが存在する場合、評価(521CH)されレジスタEに格納されます。そうでない場合は、現在の前景色が[FORCLR](#forclr)から取得されます。背景色オペランドが存在する場合、評価(521CH)されレジスタDに格納されます。そうでない場合は、現在の背景色が[BAKCLR](#bakclr)から取得されます。境界色オペランドが存在する場合、評価(521CH)され[BDRCLR](#bdrclr)に格納されます。前景色は[FORCLR](#forclr)と[ATRBYT](#atrbyt)に、背景色は[BAKCLR](#bakclr)に格納され、制御は[CHGCLR](#chgclr)標準ルーチンに移り、VDPが変更されます。

<a name="79cch"></a><a name="screen"></a>

    Address... 79CCH

これは「`SCREEN`」文ハンドラです。モードオペランドが存在する場合、評価（521CH）され、レジスタAの[CHGMOD](#chgmod)標準ルーチンに渡されます。スプライトサイズオペランドが存在する場合、評価（521CH）され、VDP [モードレジスタ1](#mode_register_1)のワークスペース領域コピーである[RG1SAV](#rg1sav)のビット0と1に格納されます。その後、VDPスプライトパラメータは[CLRSPR](#clrspr)標準ルーチンによってクリアされます。キークリックオペランドが存在する場合、評価（521CH）され、[CLIKSW](#cliksw)に格納されます。クリックを無効にする場合は0、有効にする場合は0以外の値です。ボーレートオペランドが存在する場合、評価され、ボーレートが設定されます（[7A2DH](#7a2dh)）。プリンタ モード オペランドが存在する場合は評価され (521CH)、[NTMSXP](#ntmsxp) に配置されます。MSX プリンタの場合は 0、汎用プリンタの場合は 0 以外になります。

<a name="7a2dh"></a>

    Address... 7A2DH

このルーチンはカセットのボーレートを設定するために使用されます。オペランド（521CH）が評価され、5バイトが[CS1200](#cs1200)または[CS2400](#cs2400)から[LOW](#low)に適宜コピーされます。

<a name="7a48h"></a><a name="スプライト"></a>

    Address... 7A48H

これは「`SPRITE`」文ハンドラです。次の文字が「$」以外の場合、制御は「`SPRITE ON/OFF/STOP`」文ハンドラ（[77ABH](#77abh)）に移ります。次に[SCRMOD](#scrmod)がチェックされ、画面が[40x24テキストモード](#40x24_text_mode)の場合、「`Illegal function call`」エラー（475AH）が生成されます。スプライトパターン番号が評価され、VRAMスプライトパターンテーブル内の位置が取得されます（7AA0H）。次に文字列オペランドが評価され（[4C5FH](#4c5fh)）、そのストレージが解放されます（[67D0H](#67d0h)）。 [GSPSIZ](#gspsiz) 標準ルーチンで取得したスプライトサイズを文字列の長さと比較し、文字列がスプライトより短い場合は、[FILVRM](#filvrm) 標準ルーチンを使用してスプライトパターンテーブルのエントリをまずゼロで埋めます。次に、[LDIRVM](#ldirvm) 標準ルーチンを使用して、文字列本体からスプライトパターンテーブルに文字をコピーします。このコピーは、文字列がなくなるかスプライトが一杯になるまで行われます。文字列がスプライトサイズより長い場合は、余分な文字は無視されます。

    Address... 7A84H

このルーチンは、Factor Evaluatorによって「`SPRITE$`」関数を適用するために使用されます。スプライトパターン番号が評価され、VRAMスプライトパターンテーブル内の位置が取得されます([7A9FH](#7a9fh))。[GSPSIZ](#gspsiz)標準ルーチンによって取得されたスプライトサイズは、レジスタペアBCに格納され、コピーされるバイト数を制御します。文字列記憶領域([6627H](#6627h))に十分な空き容量があることを確認した後、スプライトパターンは[LDIRMV](#ldirmv)標準ルーチンによってVRAMからコピーされ、結果ディスクリプタが作成されます([6654H](#6654h))。この関数では画面モードのチェックが行われないため、興味深い副作用が発生する可能性があることに注意してください。以下を参照してください。

<a name="7a9fh"></a>

    Address... 7A9FH

このルーチンは、「`SPRITE$`」文と関数によって使用され、VRAMスプライトパターンテーブル内のスプライトパターンを検索します。パターン番号オペランドは評価され([7C08H](#7c08h))、レジスタAに格納された[CALPAT](#calpat)標準ルーチンに渡されます。パターンアドレスはレジスタペアDEに格納され、ルーチンは終了します。

異なるスプライトサイズにおけるパターン番号の大きさはチェックされないことに注意してください。16x16スプライトモードでは、最大パターン番号は63であるべきところ、最大255までのパターン番号が受け入れられます。その結果、3FFFHを超えるVRAMアドレスが生成され、低位VRAM領域にラップアラウンドします。「`SPRITE$`」ステートメントを使用すると、文字生成テーブルが破損します。例えば、次のようになります。

```
10 SCREEN 3,2
20 SPRITE$(0)=STRING$(32,255)
30 PUT SPRITE 0,(0,0), ,0
40 SPRITE$(65)=STRING$(32,255)
50 GOTO 50
```

上記のコードは、画面の左上に実際のスプライトを配置し、40行目の不正な文を使用してそのすぐ右のVRAMを破壊しています。「`SPRITE$`」関数も同様に操作可能であり、画面モードのチェックがないため、[40x24テキストモード](#40x24_text_mode)では名前テーブルの最大32バイトを読み取ることができます。例えば、以下のようになります。

```
10 SCREEN 0,2
20 PRINT"something"
30 A$=SPRITE$(64)
40 PRINT A$
```

</a>

<a name="7aafh"></a><a name="put_sprite"></a>

    Address... 7AAFH

これは「`GET/PUT SPRITE`」文ハンドラです。制御は一般的な「`GET/PUT`」文ハンドラ([775BH](#775bh))からここに移されます。まずレジスタBがチェックされ、文が「`PUT`」であるかどうかが確認されます。そうでない場合は「`Illegal function call`」エラー(475AH)が生成されます。次に[SCRMOD](#scrmod)がチェックされ、画面が[40x24テキストモード](#40x24_text_mode)の場合は「`Illegal function call`」エラー(475AH)が生成されます。スプライト番号オペランド(0から31まで)が評価(521CH)され、[CALATR](#calatr)標準ルーチンに渡され、スプライト属性テーブル内の4バイト属性ブロックが検索されます。座標オペランドが存在する場合はそれが評価され、X座標がレジスタペアBCに配置され、Y座標がレジスタペアDEに配置されます([579CH](#579ch))。

Y座標のLSBは、[WRTVRM](#wrtvrm)標準ルーチンを介してVRAMの属性ブロックのバイト0に書き込まれます。次に、X座標のビット7が負であるかどうか、つまり画面の左側から外れているかどうかが調べられます。負の場合、X座標に32が加算され、レジスタBが80Hに設定され、属性ブロックの早期クロックビットが設定されます。たとえば、X座標-1（FFFFH）は早期クロックによって+31に変更されます。X座標のLSBは、[WRTVRM](#wrtvrm)標準ルーチンを介して属性ブロックのバイト1に書き込まれます。属性ブロックのバイト3は[RDVRM](#rdvrm)標準ルーチンを介して読み込まれ、新しい早期クロックビットがミックスされて、[WRTVRM](#wrtvrm)標準ルーチンを介してVRAMに書き戻されます。

カラーオペランドが存在する場合、それが評価され (521CH)、属性ブロックのバイト3が[RDVRM](#rdvrm)標準ルーチンを介して読み込まれ、新しいカラーコードが最下位4ビットにミックスされ、[WRTVRM](#wrtvrm)標準ルーチンを介してVRAMに書き戻されます。パターン番号オペランドが存在する場合、それが評価され (521CH)、[GSPSIZ](#gspsiz)標準ルーチンによって提供される現在のスプライトサイズと比較して大きさがチェックされます。最大許容パターン番号は、8x8スプライトの場合は255、16x16スプライトの場合は63です。パターン番号は[WRTVRM](#wrtvrm)標準ルーチンを介して属性ブロックのバイト2に書き込まれ、ハンドラが終了します。

<a name="7b37h"></a>

    Address... 7B37H

これは「`VDP`」文ハンドラです。レジスタ番号オペランド（0から7まで）が評価され（[7C08H](#7c08h)）、続いてデータオペランド（521CH）が評価されます。レジスタ番号はレジスタCに、データ値はレジスタBに格納され、制御は[WRTVDP](#wrtvdp)標準ルーチンに渡されます。

<a name="7b47h"></a>

    Address... 7B47H

このルーチンは、Factor Evaluatorによって「`VDP`」関数を適用するために使用されます。レジスタ番号オペランド（0～8）が評価され（[7C08H](#7c08h)）、ワークスペース領域内の対応するレジスタイメージを特定するために[RG0SAV](#rg0sav)に加算されます。その後、VDPレジスタイメージが読み出され、[DAC](#dac)に整数（4FCFH）として格納されます。

<a name="7b5ah"></a><a name="base"></a>

    Address... 7B5AH

これは「`BASE`」文ハンドラです。VDPテーブル番号オペランド（0から19まで）が評価され（[7C08H](#7c08h)）、続いてベースアドレスオペランド（[4C64H](#4c64h)）が評価されます。ベースアドレスが4000H未満（[7BFEH](#7bfeh)）であることを確認した後、VDPテーブル番号を使用して、7BA3Hにあるマスクテーブル内の対応するエントリを検索します。ベースアドレスとマスクのAND演算が行われ、不正なビットが設定されている場合は「`不正な関数呼び出し`」エラー（475AH）が生成されます。次に、VDPテーブル番号が[TXTNAM](#txtnam)に加算され、ワー​​クスペース領域内の現在のベースアドレスと、そこに配置される新しいベースアドレスが検索されます。VDPテーブル番号を5で割ることで、テーブルが4つの画面モードのどれに属するかが判定されます。これが現在の画面モードと同じ場合は、新しいベースアドレスもVDP([7B99H](#7b99h))に書き込まれます。

<a name="7b99h"></a>

    Address... 7B99H

このルーチンは、「`BASE`」文ハンドラによってVDPベースアドレスを更新するために使用されます。レジスタAの現在の画面モードが調べられ、制御は[SETTXT](#settxt)、[SETT32](#sett32)、[SETGRP](#setgrp)、または[SETMLT](#setmlt)標準ルーチンに適宜移ります。これは完全なVDP初期化ではなく、画面ルーチンによって実際に使用される4つの現在のテーブルアドレス（[NAMBAS](#nambas)、[CGPBAS](#cgpbas)、[PATBAS](#patbas)、[ATRBAS](#atrbas)）は更新されないことに注意してください。これは、インタープリタが古いVRAMネームテーブルへの出力を継続する以下のコードで確認できます。

```
10 SCREEN 0
20 BASE(0)=&H400
30 PRINT"something"
40 FOR N=1 TO 2000:NEXT
50 BASE(0)=0
```

このルーチンにはバグがあることにもご注意ください。[SETTXT](#settxt) は [40x24 テキストモード](#40x24_text_mode) では正しく使用されますが、[SETGRP](#setgrp) は [32x24 テキストモード](#32x24_text_mode) に、[SETMLT](#setmlt) は [グラフィックスモード](#graphics_mode) と [マルチカラーモード](#multicolour_mode) に使用されます。したがって、"`BASE`" ステートメントの直後に "`SCREEN`" ステートメントを続けて実行し、完全な初期化を実行する必要があります。

<a name="7ba3h"></a>

    Address... 7BA3H

このマスキングテーブルは、「`BASE`」ステートメントハンドラによって使用され、有効なVDPベースアドレスのみが受け入れられるようにします。各マスクには、テーブル番号と対応するワークスペース領域変数が表示されます。

|MASK   |TABLE
|-------|----------
|03FFH  |00, [TXTNAM](#txtnam)
|003FH  |01, [TXTCOL](#txtcol)
|07FFH  |02, [TXTCGP](#txtcgp)
|007FH  |03, [TXTATR](#txtatr)
|07FFH  |04, [TXTPAT](#txtpat)
|03FFH  |05, [T32NAM](#t32nam)
|003FH  |06, [T32COL](#t32col)
|07FFH  |07, [T32CGP](#t32cgp)
|007FH  |08, [T32ATR](#t32atr)
|07FFH  |09, [T32PAT](#t32pat)
|03FFH  |10, [GRPNAM](#grpnam)
|1FFFH  |11, [GRPCOL](#grpcol)
|1FFFH  |12, [GRPCGP](#grpcgp)
|007FH  |13, [GRPATR](#grpatr)
|07FFH  |14, [GRPPAT](#grppat)
|03FFH  |15, [MLTNAM](#mltnam)
|003FH  |16, [MLTCOL](#mltcol)
|07FFH  |17, [MLTCGP](#mltcgp)
|007FH  |18, [MLTATR](#mltatr)
|07FFH  |19, [MLTPAT](#mltpat)

</a>

<a name="7bcbh"></a>

    Address... 7BCBH

このルーチンは、Factor Evaluatorによって「`BASE`」関数を適用するために使用されます。VDPテーブル番号オペランド（0から19まで）が評価され（[7C08H](#7c08h)）、[TXTNAM](#txtnam)に加算されて、必要なワークスペース領域のベースアドレスが特定されます。そして、このアドレスは単精度数値（3236H）として[DAC](#dac)に格納されます。

<a name="7be2h"></a><a name="vpoke"></a>

    Address... 7BE2H

これは「`VPOKE`」文ハンドラです。VRAMアドレスオペランドが評価され（[4C64H](#4c64h)）、4000H（[7BFEH](#7bfeh)）未満であることを確認します。次に、データオペランドが評価され（521CH）、レジスタAの[WRTVRM](#wrtvrm)標準ルーチンに渡され、必要なアドレスに書き込みます。

<a name="7bf5h"></a>

    Address... 7BF5H

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`VPEEK`」関数を適用するために使用されます。VRAMアドレスオペランドが4000H（[7BFEH](#7bfeh)）未満であるかどうかがチェックされます。その後、[RDVRM](#rdvrm)標準ルーチンを介してVRAMが読み出され、その結果が整数（4FCFH）として[DAC](#dac)に格納されます。

<a name="7bfeh"></a>

    Address... 7BFEH

このルーチンは、[DAC](#dac) 内の数値オペランドを整数 ([2F8AH](#2f8ah)) に変換し、レジスタペア HL に格納します。オペランドが 4000H 以上で、VRAM の許容範囲外である場合、「`不正な関数呼び出し`」エラー (475AH) が生成されます。

<a name="7c08h"></a>

    Address... 7C08H

このルーチンは、括弧で囲まれた数値オペランドを評価 (521CH) し、それをレジスタ A に整数として返します。オペランドがレジスタ A に最初に指定された最大許容値より大きい場合、「`不正な関数呼び出し`」エラーが生成されます (475AH)。

<a name="7c16h"></a><a name="dsko$"></a>

    Address... 7C16H

これは「`DSKO$`」文のハンドラです。標準MSXマシンでは「`不正な関数呼び出し`」エラー（475AH）が発生します。

<a name="7c1bh"></a><a name="set"></a>

    Address... 7C1BH

これは「`SET`」文のハンドラです。標準のMSXマシンでは「`Illegal function call`」エラー（475AH）が発生します。

<a name="7c20h"></a><a name="名前"></a>

    Address... 7C20H

これは「`NAME`」ステートメントハンドラです。標準のMSXマシンでは「`Illegal function call`」エラー（475AH）が発生します。

<a name="7c25h"></a><a name="殺す"></a>

    Address... 7C25H

これは「`KILL`」文のハンドラです。標準のMSXマシンでは「`Illegal function call`」エラー（475AH）が発生します。

<a name="7c2ah"></a><a name="ipl"></a>

    Address... 7C2AH

これは「`IPL`」文ハンドラです。標準MSXマシンでは「`不正な関数呼び出し`」エラー（475AH）が発生します。

<a name="7c2fh"></a><a name="コピー"></a>

    Address... 7C2FH

これは「`COPY`」文のハンドラです。標準のMSXマシンでは「`Illegal function call`」エラー（475AH）が発生します。

<a name="7c34h"></a><a name="cmd"></a>

    Address... 7C34H

これは「`CMD`」文のハンドラです。標準のMSXマシンでは「`Illegal function call`」エラー（475AH）が発生します。

<a name="7c39h"></a>

    Address... 7C39H

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`DSKF`」関数を適用するために使用されます。標準MSXマシンでは「`不正な関数呼び出し`」エラー（475AH）が発生します。

<a name="7c3eh"></a>

    Address... 7C3EH

このルーチンは、Factor Evaluator が「`DSKI$`」関数を適用するために使用されます。標準の MSX マシンでは、「`Illegal function call`」エラー (475AH) が発生します。

<a name="7c43h"></a>

    Address... 7C43H

このルーチンは、Factor Evaluator が「`ATTR$`」関数を適用するために使用されます。標準の MSX マシンでは、「`Illegal function call`」エラー (475AH) が発生します。

<a name="7c48h"></a><a name="lset"></a>

    Address... 7C48H

これは「`LSET`」文のハンドラです。標準のMSXマシンでは「`Illegal function call`」エラー（475AH）が発生します。

<a name="7c4dh"></a><a name="rset"></a>

    Address... 7C4DH

これは「`RSET`」文のハンドラです。標準のMSXマシンでは「`Illegal function call`」エラー（475AH）が発生します。

<a name="7c52h"></a><a name="フィールド"></a>

    Address... 7C52H

これは「`FIELD`」文のハンドラです。標準のMSXマシンでは「`Illegal function call`」エラー（475AH）が発生します。

<a name="7c57h"></a>

    Address... 7C57H

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`MKI$`」関数を適用するために使用されます。標準MSXマシンでは「`不正な関数呼び出し`」エラー（475AH）が発生します。

<a name="7c5ch"></a>

    Address... 7C5CH

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`MKS$`」関数を適用するために使用されます。標準MSXマシンでは「`不正な関数呼び出し`」エラー（475AH）が発生します。

<a name="7c61h"></a>

    Address... 7C61H

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`MKD$`」関数を適用するために使用されます。標準MSXマシンでは「`不正な関数呼び出し`」エラー（475AH）が発生します。

<a name="7c66h"></a>

    Address... 7C66H

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`CVI`」関数を適用するために使用されます。標準MSXマシンでは「`不正な関数呼び出し`」エラー（475AH）が発生します。

<a name="7c6bh"></a>

    Address... 7C6BH

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`CVS`」関数を適用するために使用されます。標準MSXマシンでは「`不正な関数呼び出し`」エラー（475AH）が発生します。

<a name="7c70h"></a>

    Address... 7C70H

このルーチンは、Factor Evaluatorによって[DAC](#dac)に含まれるオペランドに「`CVD`」関数を適用するために使用されます。標準MSXマシンでは「`不正な関数呼び出し`」エラー（475AH）が発生します。

<a name="7c76h"></a>

    Address... 7C76H

このルーチンは電源投入時の初期化を完了します。この時点でワークスペース領域全体がゼロクリアされ、[EXPTBL](#exptbl)と[SLTTBL](#slttbl)のみが初期化されています。一時スタックはF376Hに設定され、112個のフック（560バイト）すべてがZ80 RETオペコード（C9H）で埋められます。[HIMEM](#himem)はF380Hに設定され、見つかったRAMの最下位アドレス（[7D5DH](#7d5dh)）が[BOTTOM](#bottom)に配置されます。 7F27Hから始まる144バイトのデータは、ワークスペース領域のF380HからF40FHにコピーされます。ファンクションキー文字列は[INIFNK](#inifnk)標準ルーチンによって初期化され、[ENDBUF](#endbuf)と[NLONLY](#nlonly)はゼロに設定され、[BUFMIN](#bufmin)にはカンマ、[KBFMIN](#kbfmin)にはコロンが設定されます。MSX ROM文字セットのアドレスは0004Hと0005Hから取得され、[CGPNT](#cgpnt)+1に格納され、[PRMPRV](#prmprv)は[PRMSTK](#prmstk)を指すように設定されます。 [STKTOP](#stktop)、[MEMSIZ](#memsiz)、[VARTAB](#vartab)にダミー値が配置されます（正しい値はまだ不明です）。I/Oバッファが1つ割り当てられ（[7E6BH](#7e6bh)）、Z80 SPがセットされます（62E5H）。RAMのベースにゼロバイトが配置され、[TXTTAB](#txttab)が次の位置にセットされ、"`NEW`"が実行されます（6287H）。

その後、VDPは[INITIO](#initio)、[INIT32](#init32)、[CLRSPR](#clrspr)標準ルーチンによって初期化され、カーソル座標は11行10列に設定され、サインオンメッセージ「`MSXシステムなど`」が表示されます([6678H](#6678h))。3秒の遅延の後、拡張ROMの検索が実行され([7D75H](#7d75h))、BASICプログラムがROMから実行された場合は、さらに「`NEW`」が実行されます(6287H)。

最後に識別メッセージ「`MSX BASIC etc.`」が表示され([7D29H](#7d29h))、制御はインタープリタメインループの「`OK`」ポイント411FHに移ります。

<a name="7d29h"></a>

    Address... 7D29H

このルーチンは電源投入時に使用され、ファンクションキーの表示を有効にし、[INITXT](#initxt)標準ルーチンを介して画面を[40x24テキストモード](#40x24_text_mode)に設定し、識別メッセージ「`MSX BASIC etc.`」を表示します([6678H](#6678h))。その後、[VARTAB](#vartab)の内容を[STKTOP](#stktop)の内容から差し引くことで空きメモリ量が計算され([3412H](#3412h))、最後に「`Bytes free`」メッセージが表示されます。

<a name="7d5dh"></a>

    Address... 7D5DH

このルーチンは、電源投入時にRAMの最下位アドレスを見つけるために使用されます。EF00Hから開始し、書き込み不可能なバイトが見つかるか、アドレスが8000Hに達するまで、各バイトをテストします。ベースアドレスは、最も近い256バイト境界に切り上げられ、レジスタペアHLに返されます。

<a name="7d75h"></a>

    Address... 7D75H

このルーチンは、電源投入時に拡張ROMの検索を実行するために使用されます。各スロットのページ1と2（4000H～BFFFH）が検査され、その結果が[SLTATR](#sltatr)に格納されます。拡張ROMの最初の2バイトには、RAMと区別するための識別文字「`AB`」が2つあります。また、最初の16バイトには、そのプロパティに関する情報も以下のように格納されています。

<a name="figure48"></a>![][CH05F48]

**図48:** ROMヘッダー

指定されたスロットの各ページは、最初の2バイト ([7E1AH](#7e1ah)) を読み取り、「`AB`」文字の有無をチェックすることで検査されます。ROMが存在する場合、初期化アドレス ([7E1AH](#7e1ah)) が読み取られ、[CALSLT](#calslt) 標準ルーチンを介して制御がROMに渡されます。ゲームROMの場合、この時点からBASICに戻れない可能性があります。次に、「`CALL`」拡張ステートメントハンドラアドレス ([7E1AH](#7e1ah)) が読み取られ、レジスタBのビット5が有効（つまり0以外）であればセットされます。拡張デバイスハンドラアドレス ([7E1AH](#7e1ah)) が読み取られ、レジスタBのビット6が有効であればセットされます。最後に、BASICプログラムテキストアドレス ([7E1AH](#7e1ah)) が読み取られ、レジスタBのビット7が有効であればセットされます。次にレジスタ B が [SLTATR](#sltatr) の関連する位置にコピーされ、スロットがなくなるまで検索が続行されます。

次に、[SLTATR](#sltatr) を調べ、BASICプログラムテキストを含むとフラグが付けられた拡張ROMがあるかどうかを確認します。拡張ROMが見つかった場合、[SLTATR](#sltatr) 内の位置がスロットID ([7E2AH](#7e2ah)) に変換され、[ENASLT](#enaslt) 標準ルーチンによってROMが恒久的に切り替えられます。プログラムテキスト領域の大きさが不明なため、[VARTAB](#vartab) はC000Hに設定され、[TXTTAB](#txttab) は8008Hに設定され、[BASROM](#basrom) はCtrl-Stopキーを無効にするためにゼロ以外の値に設定されます。システムがクリアされ([629AH](#629ah))、BASICプログラムを実行するために制御がRunloop ([4601H](#4601h)) に移ります。

<a name="7e1ah"></a>

    Address... 7E1AH

このルーチンは、拡張ROM内の連続する位置から2バイトを読み取るために使用されます。先頭アドレスはレジスタペアHLに、スロットIDはレジスタCに渡されます。バイトは[RDSLT](#rdslt)標準ルーチンを介して読み取られ、レジスタペアDEに返されます。両方の値がゼロの場合、FLAG Zが返されます。

<a name="7e2ah"></a>

    Address... 7E2AH

このルーチンは、レジスタ B に提供された [SLTATR](#sltatr) 位置を、レジスタ C の対応するスロット ID とレジスタ H の ROM ベース アドレスに変換します。位置は最初に 64 から 1 ではなく 0 から 63 になるように変更され、必要な情報が次の形式で提供されます。

<a name="figure49"></a>![][CH05F49]

**図49**

ビット0と1はレジスタHの最上位2ビットにシフトされ、アドレスを形成します。ビット4と5はレジスタCのビット0と1にシフトされ、プライマリスロット番号を形成します。ビット2と3はレジスタCのビット2と3にシフトされ、セカンダリスロット番号を形成します。対応する[EXPTBL](#exptbl)エントリのビット7はレジスタCのビット7にコピーされます。

<a name="7e4bh"></a><a name="maxfiles"></a>

    Address... 7E4BH

これは「`MAXFILES`」文ハンドラです。「`MAX`」トークン (CDH) が検出されると制御がここへ移るため、まずプログラムテキストの末尾に「`FILES`」トークン (B7H) があるかどうかがチェックされます。次に、バッファカウントオペランド (0～15) が評価され (521CH)、既存のバッファが閉じられます ([6C1CH](#6c1ch))。必要な数のI/Oバッファが割り当てられ ([7E6BH](#7e6bh))、システムがクリアされ (62A7H)、制御が直接実行ループ ([4601H](#4601h)) へ移ります。

<a name="7e6bh"></a>

    Address... 7E6BH

これはI/Oバッファ割り当てルーチンです。電源投入時および「`MAXFILES`」および「`CLEAR`」ステートメントハンドラによって、レジスタAに指定されたI/Oバッファの数に対応するストレージを割り当てるために使用されます。各バッファについて、[HIMEM](#himem)の内容から267バイトが減算され、新しい[MEMSIZ](#memsiz)値が生成されます。既存の文字列ストレージ領域（初期値は200バイト）のサイズは、[MEMSIZ](#memsiz)の古い内容から[STKTOP](#stktop)の古い内容を減算することで計算され、この減算された値が新しい[MEMSIZ](#memsiz)値から減算され、新しい[STKTOP](#stktop)値が生成されます。 Z80スタック用にさらに140バイトが減算され、このアドレスが変数記憶領域の先頭より小さい場合は「`Out of Memory`」エラー（6275H）が生成されます。それ以外の場合は、バッファカウントが[MAXFIL](#maxfil)に格納され、[MEMSIZ](#memsiz)と[STKTOP](#stktop)が新しい値に設定されます。呼び出し元の戻りアドレスがポップされ、Z80 SPが新しい位置に設定され、戻りアドレスがスタックにプッシュバックされます。次に、[FILTAB](#filtab)がI/Oバッファポインタブロックの先頭に設定され、各ポインタが対応するFCBを指すように設定されます。最後に、インタープリタの「`LOAD`」および「`SAVE`」バッファであるI/Oバッファ0のアドレスが[NULBUF](#nulbuf)に格納され、ルーチンが終了します。

<a name="7ed8h"></a>

    Address... 7ED8H

これはゼロバイトで終了するプレーンテキストメッセージ「`MSXシステム`」です。

<a name="7ee4h"></a>

    Address... 7EE4H

これは、ゼロ バイトで終了する CR、LF のプレーン テキスト メッセージ「`version 1.0`」です。

<a name="7ef2h"></a>

    Address... 7EF2H

これは、ゼロ バイトで終了するプレーン テキスト メッセージ「`MSX BASIC`」です。

<a name="7efdh"></a>

    Address... 7EFDH

これは、ゼロ バイトで終了する CR、LF のプレーン テキスト メッセージ「`Copyright 1983 by Microsoft`」です。

<a name="7f1bh"></a>

    Address... 7F1BH

これは、ゼロ バイトで終了するプレーン テキスト メッセージ「`Bytes free`」です。

<a name="7f27h"></a>

    Address... 7F27H

この 144 データ バイトのブロックは、ワークスペース領域を F380H から F40FH まで初期化するために使用されます。

<a name="7fb7h"></a>

    Address... 7FB7H

この7バイトのパッチは、外部デバイス解析ルーチン ([55F8H](#55f8h)) のバグを修正します。レジスタAに長さ0のデバイス名があるかどうかをチェックし、必要に応じて長さ1に変更します。

<a name="7fbeh"></a>

    Address... 7FBEH

ROM のこのセクションは未使用であり、ゼロ バイトで埋められています。

<br><br><br>

<a name="chapter_6"></a>

# 6. メモリマップ

BASICインタープリタは、プログラムテキスト、BASIC変数、Z80スタック、I/Oバッファ、内部ワークスペースを保持するために、最大32KBのRAMを利用できます。電源投入時のこれらの領域のメモリマップを以下に示します。

<a name="figure50"></a>![][CH05F50]

**図50:** メモリマップ8000HからFFFFH

プログラムテキストエリアは、行番号順に格納されたトークン化されたプログラム行で構成され、ゼロ終了リンクで終了します。「`NEW`」状態では、終了リンクのみが表示されます。8000Hのゼロバイトは、プログラム開始時にRunloopを同期するために必要なダミーの行末文字です。

変数と配列の記憶領域は、文字列または数値の変数と配列で構成され、プログラムテキスト内での出現順に記憶されます。プログラム内で変数を配列より先に宣言すると、上位に移動するメモリ量が削減されるため、実行速度がわずかに向上します。

Z80 スタックは文字列ストレージ領域のすぐ下に配置されており、スタック上部の構造は以下のとおりです。

<a name="figure51"></a>![][CH05F51]

**図51:** Z80スタックトップ

「`CLEAR`」または「`MAXFILES`」文の結果としてスタックの位置が変更されるたびに、まず2つのゼロバイトがプッシュされます。これは、「`FOR`」または「`GOSUB`」パラメータブロック検索中の終端文字として機能します。パラメータブロックが存在しないと仮定すると、Z80 SPはインタープリタのメインループ内では[STKTOP](#stktop)-2にあり、制御がランループからステートメントハンドラに移る際には[STKTOP](#stktop)-4になります。

文字列記憶領域は、変数または配列に割り当てられた文字列本体で構成されます。式の評価中、複数の中間文字列結果が一時的に永続文字列ヒープ下に存在する場合があります。文字列記憶領域に続くゼロバイトは、「`VAL`」関数の一時的な区切り文字です。

文字列記憶領域と[HIMEM](#himem)の間の領域は、I/Oバッファの記憶域として使用されます。I/Oバッファ0（「`SAVE`」および「`LOAD`」バッファ）は常に存在しますが、ユーザーバッファの数は「`MAXFILES`」ステートメントによって決定されます。各I/Oバッファは、9バイトのFCB（FCB 0のテーブルにアドレスが含まれています）と、それに続く256バイトのデータバッファで構成されます。FCBには、以下のようにI/Oバッファのステータスが含まれます。

<a name="figure52"></a>![][CH05F52]

**図52:** ファイル制御ブロック

MODバイトはバッファモード、DEVバイトはデバイスコード、POSバイトはバッファ内の現在位置（0～255）、PPSバイトは「`PRINT`」位置を保持します。FCBの残りの部分は、標準のMSXマシンでは使用されません。

<a name="ワークスペースエリア"></a>

## ワークスペースエリア

ワークスペース領域のF380HからFD99Hまでのセクションには、BIOS/インタープリタ変数が格納されます。これらの変数は、以下のページに標準的なアセンブリ言語形式で記載されています。

<a name="f380h"></a><a name="rdprim"></a>
<a name="f382h"></a>
<a name="f383h"></a>

```
F380H RDPRIM: OUT (0A8H),A ; Set new Primary Slot
F382H         LD E,(HL)    ; Read memory
F383H         JR WRPRM1    ; Restore old Primary Slot
```

このルーチンは、[RDSLT](#rdslt) 標準ルーチンによって使用され、プライマリスロットを切り替えてメモリからバイトを読み取ります。新しいプライマリスロットレジスタの設定はレジスタAに、古い設定はレジスタDに、読み取ったバイトはレジスタEに返されます。

<a name="f385h"></a><a name="wrprim"></a>
<a name="f387h"></a>
<a name="f388h"></a><a name="wrprm1"></a>
<a name="f389h"></a>
<a name="f38bh"></a>

```
F385H WRPRIM: OUT (0A8H),A ; Set new Primary Slot
F387H         LD (HL),E    ; Write to memory
F388H WRPRM1: LD A,D       ; Get old setting
F389H         OUT (0A8H),A ; Restore old Primary Slot
F38BH         RET
```

このルーチンは、[WRSLT](#wrslt) 標準ルーチンによって使用され、プライマリスロットを切り替えてメモリにバイトを書き込みます。新しいプライマリスロットレジスタの設定はレジスタAに、古い設定はレジスタDに、書き込むバイトはレジスタEに設定されます。

<a name="f38ch"></a><a name="clprim"></a>
<a name="f38eh"></a>
<a name="f38fh"></a>
<a name="f392h"></a>
<a name="f393h"></a>
<a name="f394h"></a>
<a name="f396h"></a>
<a name="f397h"></a>
<a name="f398h"></a><a name="clprm1"></a>

```
F38CH CLPRIM: OUT (0A8H),A ; Set new Primary Slot
F38EH         EX AF,AF'    ; Swap to AF for call
F38FH         CALL CLPRM1  ; Do it
F392H         EX AF,AF'    ; Swap to AF
F393H         POP AF       ; Get old setting
F394H         OUT (0A8H),A ; Restore old Primary Slot
F396H         EX AF,AF'    ; Swap to AF
F397H         RET
F398H CLPRM1: JP (IX)
```

このルーチンは、[CALSLT](#calslt) 標準ルーチンによって使用され、プライマリスロットを切り替えてアドレスを呼び出します。新しいプライマリスロットレジスタの設定はレジスタAに、古い設定はZ80スタックに、そして呼び出すアドレスはレジスタペアIXに渡されます。

<a name="f39ah"></a><a name="usrtab"></a>
<a name="f39ch"></a>
<a name="f39eh"></a>
<a name="f3a0h"></a>
<a name="f3a2h"></a>
<a name="f3a4h"></a>
<a name="f3a6h"></a>
<a name="f3a8h"></a>
<a name="f3aah"></a>
<a name="f3ach"></a>

```
F39AH USRTAB: DEFW 475AH   ; USR 0
F39CH         DEFW 475AH   ; USR 1
F39EH         DEFW 475AH   ; USR 2
F3A0H         DEFW 475AH   ; USR 3
F3A2H         DEFW 475AH   ; USR 4
F3A4H         DEFW 475AH   ; USR 5
F3A6H         DEFW 475AH   ; USR 6
F3A8H         DEFW 475AH   ; USR 7
F3AAH         DEFW 475AH   ; USR 8
F3ACH         DEFW 475AH   ; USR 9
```

これらの10個の変数には「`USR`」関数のアドレスが格納されます。これらの値は、起動時にインタープリタの「`Illegal function call`」エラージェネレータに設定され、その後は「`DEFUSR`」文によってのみ変更されます。

<a name="f3aeh"></a><a name="linl40"></a>

    F3AEH LINL40: 防御力 37

この変数には[40x24テキストモード](#40x24_text_mode)の画面幅が格納されます。この値は電源投入時に設定され、その後は「`WIDTH`」ステートメントによってのみ変更されます。

<a name="f3afh"></a><a name="linl32"></a>

    F3AFH LINL32: 防御力 29

この変数には、[32x24テキストモード](#32x24_text_mode)の画面幅が格納されます。この値は電源投入時に設定され、その後は「`WIDTH`」ステートメントによってのみ変更されます。

<a name="f3b0h"></a><a name="linlen"></a>

    F3B0H リンレン: DEFB 37

この変数は、現在のテキストモードの画面幅を保持します。この値は、VDPが[INITXT](#initxt)または[INIT32](#init32)標準ルーチンによってテキストモードに初期化されるたびに、[LINL40](#linl40)または[LINL32](#linl32)から設定されます。

<a name="f3b1h"></a><a name="crtcnt"></a>

    F3B1H CRTCNT: DEFB 24

この変数には画面上の行数が格納されます。この値は電源投入時に設定され、その後は変更されません。

<a name="f3b2h"></a><a name="clmlst"></a>

    F3B2H CLMLST: 防御力 14

この変数には、データ項目を「`PRINT`」するために1行に確保しておく必要のある最小の列数が格納されます。この列数が足りない場合は、まずCRとLFが発行されます。この値は電源投入時に設定され、その後は「`WIDTH`」および「`SCREEN`」ステートメントによってのみ変更されます。

<a name="f3b3h"></a><a name="txtnam"></a>
<a name="f3b5h"></a><a name="txtcol"></a>
<a name="f3b7h"></a><a name="txtcgp"></a>
<a name="f3b9h"></a><a name="txtatr"></a>
<a name="f3bbh"></a><a name="txtpat"></a>

```
F3B3H TXTNAM: DEFW 0000H   ; ネーム・テーブル ベース
F3B5H TXTCOL: DEFW 0000H   ; カラー・テーブル ベース
F3B7H TXTCGP: DEFW 0800H   ; キャラクター・パターン ベース
F3B9H TXTATR: DEFW 0000H   ; スプライト・アトリビュート ベース
F3BBH TXTPAT: DEFW 0000H   ; スプライト・パターン ベース
```

これら5つの変数には、[40x24テキストモード](#40x24_text_mode) VDPベースアドレスが格納されます。これらの値は電源投入時に設定され、その後は「`BASE`」ステートメントによってのみ変更されます。

<a name="f3bdh"></a><a name="t32nam"></a>
<a name="f3bfh"></a><a name="t32col"></a>
<a name="f3c1h"></a><a name="t32cgp"></a>
<a name="f3c3h"></a><a name="t32atr"></a>
<a name="f3c5h"></a><a name="t32pat"></a>

```
F3BDH T32NAM: DEFW 1800H   ; ネーム・テーブル ベース
F3BFH T32COL: DEFW 2000H   ; カラー・テーブル ベース
F3C1H T32CGP: DEFW 0000H   ; キャラクター・パターン ベース
F3C3H T32ATR: DEFW 1B00H   ; スプライト・アトリビュート ベース
F3C5H T32PAT: DEFW 3800H   ; スプライト・パターン ベース
```

これら5つの変数には、[32x24テキストモード](#32x24_text_mode) VDPベースアドレスが格納されます。これらの値は電源投入時に設定され、その後は「`BASE`」ステートメントによってのみ変更されます。

<a name="f3c7h"></a><a name="grpnam"></a>
<a name="f3c9h"></a><a name="grpcol"></a>
<a name="f3cbh"></a><a name="grpcgp"></a>
<a name="f3cdh"></a><a name="grpatr"></a>
<a name="f3cfh"></a><a name="grppat"></a>

```
F3C7H GRPNAM: DEFW 1800H   ; ネーム・テーブル ベース
F3C9H GRPCOL: DEFW 2000H   ; カラー・テーブル ベース
F3CBH GRPCGP: DEFW 0000H   ; キャラクター・パターン ベース
F3CDH GRPATR: DEFW 1B00H   ; スプライト・アトリビュート ベース
F3CFH GRPPAT: DEFW 3800H   ; スプライト・パターン ベース
```

これら5つの変数には、[グラフィックスモード](#graphics_mode) VDPのベースアドレスが格納されます。これらの値は電源投入時に設定され、その後は「`BASE`」ステートメントによってのみ変更されます。

<a name="f3d1h"></a><a name="mltnam"></a>
<a name="f3d3h"></a><a name="mltcol"></a>
<a name="f3d5h"></a><a name="mltcgp"></a>
<a name="f3d7h"></a><a name="mltatr"></a>
<a name="f3d9h"></a><a name="mltpat"></a>

```
F3D1H MLTNAM: DEFW 0800H   ; ネーム・テーブル ベース
F3D3H MLTCOL: DEFW 0000H   ; カラー・テーブル ベース
F3D5H MLTCGP: DEFW 0000H   ; キャラクター・パターン ベース
F3D7H MLTATR: DEFW 1B00H   ; スプライト・アトリビュート ベース
F3D9H MLTPAT: DEFW 3800H   ; スプライト・パターン ベース
```

これら5つの変数には、[マルチカラーモード](#multicolour_mode) VDPのベースアドレスが格納されます。これらの値は電源投入時に設定され、その後は「`BASE`」ステートメントによってのみ変更されます。

<a name="f3dbh"></a><a name="cliksw"></a>

    F3DBH CLIKSW: DEFB 01H

この変数は割り込みハンドラのキークリックを制御します：00H=オフ、NZ=オン。この値は電源投入時に設定され、その後は「`SCREEN`」ステートメントによってのみ変更されます。

<a name="f3dch"></a><a name="csry"></a>

    F3DCH CSRY:   DEFB 01H

この変数には、テキスト モード カーソルの行座標 (1 から [CTRCNT](#ctrcnt)) が含まれます。

<a name="f3ddh"></a><a name="csrx"></a>

    F3DDH CSRX:   DEFB 01H

この変数には、テキストモードカーソルの列座標（1から[LINLEN](#linlen)）が格納されます。BIOSカーソルのホームポジション座標は、画面幅に関係なく1,1であることに注意してください。

<a name="f3deh"></a><a name="cnsdfg"></a>

    F3DEH CNSDFG: DEFB FFH

この変数には、ファンクション キー表示の現在の状態が含まれます: 00H = オフ、NZ = オン。

<a name="f3dfh"></a><a name="rg0sav"></a>
<a name="f3e0h"></a><a name="rg1sav"></a>
<a name="f3e1h"></a><a name="rg2sav"></a>
<a name="f3e2h"></a><a name="rg3sav"></a>
<a name="f3e3h"></a><a name="rg4sav"></a>
<a name="f3e4h"></a><a name="rg5sav"></a>
<a name="f3e5h"></a><a name="rg6sav"></a>
<a name="f3e6h"></a><a name="rg7sav"></a>

```
F3DFH RG0SAV: DEFB 00H
F3E0H RG1SAV: DEFB F0H
F3E1H RG2SAV: DEFB 00H
F3E2H RG3SAV: DEFB 00H
F3E3H RG4SAV: DEFB 01H
F3E4H RG5SAV: DEFB 00H
F3E5H RG6SAV: DEFB 00H
F3E6H RG7SAV: DEFB F4H
```

これら8つの変数は、8つの書き込み専用[VDPモードレジスタ](#vdp_mode_registers)の状態を模倣します。表示されている値は[40x24テキストモード](#40x24_text_mode)の場合です。

<a name="f3e7h"></a><a name="statfl"></a>

    F3E7H STATFL: DEFB CAH

この変数は、割り込みハンドラによって [VDP ステータス レジスタ](#vdp_status_register) の内容で継続的に更新されます。

<a name="f3e8h"></a><a name="trgflg"></a>

    F3E8H TRGFLG: DEFB F1H

この変数は、4 つのジョイスティック トリガー入力とスペース キーの状態を使用して、割り込みハンドラーによって継続的に更新されます。

<a name="f3e9h"></a><a name="forclr"></a>

    F3E9H FORCLR: DEFB 0FH     ; White

この変数は現在の前景色を保持します。この値は電源投入時に設定され、その後は「`COLOR`」文によってのみ変更されます。前景色は、[CLRSPR](#clrspr) 標準ルーチンによってスプライトの色を設定するために使用され、[CHGCLR](#chgclr) 標準ルーチンによってテキストモードの1ピクセルの色を設定するために使用されます。また、[GRPPRT](#grpprt) 標準ルーチンによって [ATRBYT](#atrbyt) にコピーされ、インタープリタ全体で任意の色オペランドのデフォルト値として使用されるため、グラフィックスインクの色としても機能します。

<a name="f3eah"></a><a name="bakclr"></a>

    F3EAH BAKCLR: DEFB 04H     ; Dark blue

この変数は現在の背景色を保持します。この値は電源投入時に設定され、その後は「`COLOR`」ステートメントによってのみ変更されます。背景色は、グラフィックモードでは[CLS](#cls)標準ルーチンによって画面をクリアするために使用され、テキストモードでは[CHGCLR](#chgclr)標準ルーチンによって0ピクセルの色を設定するために使用されます。

<a name="f3ebh"></a><a name="bdrclr"></a>

    F3EBH BDRCLR: DEFB 04H     ; Dark blue

この変数には現在の境界線の色が格納されます。この値は電源投入時に設定され、その後は「`COLOR`」ステートメントによってのみ変更されます。この境界線の色は、[32x24 テキストモード](#32x24_text_mode)、[グラフィックモード](#graphics_mode)、[マルチカラーモード](#multicolour_mode)において、[CHGCLR](#chgclr)標準ルーチンによって境界線の色を設定するために使用されます。

<a name="f3ech"></a><a name="maxupd"></a>
<a name="f3edh"></a>

```
F3ECH MAXUPD: DEFB C3H
F3EDH         DEFW 0000H
```

これらの 2 つのバイトは、「`LINE`」ステートメント ハンドラーによって入力され、[RIGHTC](#rightc)、[LEFTC](#leftc)、[UPC](#upc)、または [DOWNC](#downc) 標準ルーチンへの Z80 JP を形成します。

<a name="f3efh"></a><a name="minupd"></a>
<a name="f3f0h"></a>

```
F3EFH MINUPD: DEFB C3H
F3F0H         DEFW 0000H
```

これらの 2 つのバイトは、「`LINE`」ステートメント ハンドラーによって入力され、[RIGHTC](#rightc)、[LEFTC](#leftc)、[UPC](#upc)、または [DOWNC](#downc) 標準ルーチンへの Z80 JP を形成します。

<a name="f3f2h"></a><a name="atrbyt"></a>

    F3F2H ATRBYT: DEFB 0FH

この変数には、[SETC](#setc) および [NSETCX](#nsetcx) 標準ルーチンで使用されるグラフィック インクの色が含まれます。

<a name="f3f3h"></a><a name="キュー"></a>

    F3F3H QUEUES: DEFW F959H

この変数には、3つの音楽キューの制御ブロックのアドレスが格納されます。この値は電源投入時に設定され、その後は変更されません。

<a name="f3f5h"></a><a name="frcnew"></a>

    F3F5H FRCNEW: DEFB FFH

この変数には、「`CLOAD/CLOAD?`」ステートメント ハンドラー内の 2 つのステートメントを区別するためのフラグが含まれています: 00H=CLOAD、FFH=CLOAD?。

<a name="f3f6h"></a><a name="scncnt"></a>

    F3F6H SCNCNT: DEFB 01H

この変数は、キーボード スキャンの実行速度を制御するために割り込みハンドラによってカウンターとして使用されます。

<a name="f3f7h"></a><a name="repcnt"></a>

    F3F7H REPCNT: DEFB 01H

この変数は、キーの繰り返し速度を制御するために割り込みハンドラによってカウンターとして使用されます。

<a name="f3f8h"></a><a name="putpnt"></a>

    F3F8H PUTPNT: DEFW FBF0H

この変数には、[KEYBUF](#keybuf) 内の配置位置のアドレスが含まれます。

<a name="f3fah"></a><a name="getpnt"></a>

    F3FAH GETPNT: DEFW FBF0H

この変数には、[KEYBUF](#keybuf) 内の取得位置のアドレスが含まれます。

<a name="f3fch"></a><a name="cs1200"></a>
<a name="f3fdh"></a>
<a name="f3feh"></a>
<a name="f3ffh"></a>
<a name="f400h"></a>

```
F3FCH CS1200: DEFB 53H     ; LO cycle 1st half
F3FDH         DEFB 5CH     ; LO cycle 2nd half
F3FEH         DEFB 26H     ; HI cycle 1st half
F3FFH         DEFB 2DH     ; HI cycle 2nd half
F400H         DEFB 0FH     ; Header cycle count
```

これら5つの変数には、1200ボーカセットのパラメータが格納されます。これらの値は電源投入時に設定され、その後は変更されません。

<a name="f401h"></a><a name="cs2400"></a>
<a name="f402h"></a>
<a name="f403h"></a>
<a name="f404h"></a>
<a name="f405h"></a>

```
F401H CS2400: DEFB 25H     ; LO cycle 1st half
F402H         DEFB 2DH     ; LO cycle 2nd half
F403H         DEFB 0EH     ; HI cycle 1st half
F404H         DEFB 16H     ; HI cycle 2nd half
F405H         DEFB 1FH     ; Header cycle count
```

これら5つの変数には、2400ボーカセットのパラメータが格納されます。これらの値は電源投入時に設定され、その後は変更されません。

<a name="f406h"></a><a name="low"></a>
<a name="f407h"></a>
<a name="f408h"></a><a name="high"></a>
<a name="f409h"></a>
<a name="f40ah"></a><a name="header"></a>

```
F406H LOW:    DEFB 53H     ; LO cycle 1st half
F407H         DEFB 5CH     ; LO cycle 2nd half
F408H HIGH:   DEFB 26H     ; HI cycle 1st half
F409H         DEFB 2DH     ; HI cycle 2nd half
F40AH HEADER: DEFB 0FH     ; Header cycle count
```

これら5つの変数には、現在のカセットパラメータが格納されます。これらの値は電源投入時に1200ボーに設定され、その後は「`CSAVE`」および「`SCREEN`」ステートメントによってのみ変更されます。

<a name="f40bh"></a><a name="aspct1"></a>

    F40BH ASPCT1: DEFW 0100H

この変数には、デフォルトの「`CIRCLE`」アスペクト比の逆数に 256 を掛けた値が含まれます。この値は電源投入時に設定され、その後は変更されません。

<a name="f40dh"></a><a name="aspct2"></a>

    F40DH ASPCT2: DEFW 01C0H

この変数には、デフォルトの「`CIRCLE`」アスペクト比に256を掛けた値が格納されます。この値は電源投入時に設定され、その後は変更されません。アスペクト比は2つの形式で表現されるため、「`CIRCLE`」文のハンドラは、プログラムテキスト内のオペランドのようにアスペクト比を調べて、場合によっては対応するアスペクト比を返す必要がなく、適切なアスペクト比を即座に選択できます。

<a name="f40fh"></a><a name="endprg"></a>
<a name="f410h"></a>
<a name="f411h"></a>
<a name="f412h"></a>
<a name="f413h"></a>

```
F40FH ENDPRG: DEFB ":"
F410H         DEFB 00H
F411H         DEFB 00H
FE12H         DEFB 00H
F413H         DEFB 00H
```

これらの5バイトはダミーのプログラム行です。これらの値は電源投入時に設定され、その後は変更されません。この行は、インタープリタのメインループでエラーが発生した場合、トークン化されたテキストが[KBUF](#kbuf)に書き込まれる前に発生します。この時点で「`ON ERROR GOTO`」がアクティブな場合、この行は「`RESUME`」文の終了位置となるテキストを提供します。

<a name="f414h"></a><a name="errflg"></a>

    F414H ERRFLG: DEFB 00H

この変数は、エラー番号を保存するためインタープリタのエラー ハンドラによって使用されます。

<a name="f415h"></a><a name="lptpos"></a>

    F415H LPTPOS: DEFB 00H

この変数は、プリンタ ヘッドの現在の位置を保持するため、 "`LPRINT`" ステートメント ハンドラーによって使用されます。

<a name="f416h"></a><a name="prtflg"></a>

    F416H PRTFLG: DEFB 00H

この変数は、[OUTDO](#outdo) 標準ルーチンが出力を画面に送るかプリンタに送るかを決定します: 00H = 画面、01H = プリンタ。

<a name="f417h"></a><a name="ntmsxp"></a>

    F417H NTMSXP: DEFB 00H

この変数は、[OUTDO](#outdo)標準ルーチンが、プリンタに送信されるヘッダー付きグラフィック文字をスペースに置き換えるかどうかを決定します。00H = グラフィック、NZ = スペース。この値は電源投入時に設定され、その後は「`SCREEN`」ステートメントによってのみ変更されます。

<a name="f418h"></a><a name="rawprt"></a>

    F418H RAWPRT: DEFB 00H

この変数は、[OUTDO](#outdo)標準ルーチンがプリンタに送信される制御文字とヘッダー付きグラフィック文字を変更するかどうかを決定します。00H=変更、NZ=Raw。この値は電源投入時に設定され、その後は変更されません。

<a name="f419h"></a><a name="vlzadr"></a>
<a name="f41bh"></a><a name="vlzdat"></a>

```
F419H VLZADR: DEFW 0000H
F41BH VLZDAT: DEFB 00H
```

これらの変数には、「`VAL`」関数によって一時的に削除された文字のアドレスと値が含まれます。

<a name="f41ch"></a><a name="カーリン"></a>

    F41CH CURLIN: DEFW FFFFH

この変数には現在のインタープリタの行番号が格納されます。FFFFH の値はダイレクトモードを示します。

<a name="f41eh"></a><a name="kbfmin"></a>

    F41EH KBFMIN: DEFB ":"

このバイトは、[KBUF](#kbuf) に含まれるトークン化されたテキストにダミーのプレフィックスを追加します。その機能は [ENDPRG](#endprg)​​ と似ていますが、直接文内でエラーが発生した場合に使用されます。

<a name="f41fh"></a><a name="kbuf"></a>

    F41FH KBUF:   DEFS 318

このバッファには、インタープリタのメインループによって収集された入力行のトークン化された形式が格納されます。直接文が実行されると、このバッファの内容がプログラムテキストとなります。

<a name="f55dh"></a><a name="bufmin"></a>

    F55DH BUFMIN: DEFB ","

このバイトは、[BUF](#buf) に含まれるテキストにダミーのプレフィックスを追加します。これは、入力テキストの解析を開始する "`INPUT`" ステートメントハンドラを同期させるために使用されます。

<a name="f55eh"></a><a name="buf"></a>

    F55EH BUF:    DEFS 259

このバッファには、[INLIN](#inlin) 標準ルーチンによってコンソールから収集されたテキストが含まれます。

<a name="f661h"></a><a name="ttypos"></a>

    F661H TTYPOS: DEFB 00H

この変数は、現在の画面位置 (テレタイプ!) を保持するため、 "`PRINT`" ステートメント ハンドラーによって使用されます。

<a name="f662h"></a><a name="dimflg"></a>

    F662H DIMFLG: DEFB 00H

この変数は通常はゼロですが、変数検索ルーチンの操作を制御するために「`DIM`」ステートメント ハンドラーによって設定されます。

<a name="f663h"></a><a name="valtyp"></a>

    F663H VALTYP: DEFB 02H

この変数には、現在 [DAC](#dac) に含まれているオペランドの型コードが含まれます: 整数、3=文字列、4=単精度、8=倍精度。

<a name="f664h"></a><a name="dores"></a>

    F664H DORES:  DEFB 00H

この変数は通常はゼロですが、「`DATA`」トークンに続く引用符で囲まれていないキーワードのトークン化を防ぐために設定されます。

<a name="f665h"></a><a name="donum"></a>

    F665H DONUM:  DEFB 00H

この変数は通常はゼロですが、数値定数がキーワード `GOTO`、`GOSUB`、`THEN` などのいずれかの後に続く場合に設定され、特殊な行番号オペランド形式にトークン化される必要があります。

<a name="f666h"></a><a name="contxt"></a>

    F666H CONTXT: DEFW 0000H

この変数は、[CHRGTR](#chrgtr) 標準ルーチンによって使用され、プログラム テキスト内の数値定数に続く文字のアドレスを保存します。

<a name="f668h"></a><a name="consav"></a>

    F668H CONSAV: DEFB 00H

この変数は、[CHRGTR](#chrgtr) 標準ルーチンによって使用され、プログラム テキスト内にある数値定数のトークンを保存します。

<a name="f669h"></a><a name="contyp"></a>

    F669H CONTYP: DEFB 00H

この変数は、[CHRGTR](#chrgtr) 標準ルーチンによって使用され、プログラム テキスト内にある数値定数の型を保存します。

<a name="f66ah"></a><a name="conlo"></a>

    F66AH CONLO:  DEFS 8

このバッファは、[CHRGTR](#chrgtr) 標準ルーチンによって使用され、プログラム テキスト内にある数値定数の値を保存します。

<a name="f672h"></a><a name="memsiz"></a>

    F672H MEMSIZ: DEFW F168H

この変数には、文字列記憶領域の先頭アドレスが格納されます。この値は電源投入時に設定され、その後は「`CLEAR`」および「`MAXFILES`」ステートメントによってのみ変更されます。

<a name="f674h"></a><a name="stktop"></a>

    F674H STKTOP: DEFW F0A0H

この変数はZ80スタックの最上位アドレスを保持します。この値は電源投入時に[MEMSIZ](#memsiz)-200に設定され、その後は「`CLEAR`」および「`MAXFILES`」ステートメントによってのみ変更されます。

<a name="f676h"></a><a name="txttab"></a>

    F676H TXTTAB: DEFW 8001H

この変数には、プログラムテキスト領域の最初のバイトのアドレスが格納されます。この値は電源投入時に設定され、その後は変更されません。

<a name="f678h"></a><a name="temppt"></a>

    F678H TEMPPT: DEFW F67AH

この変数には、[TEMPST](#tempst) 内の次の空き場所のアドレスが含まれます。

<a name="f67ah"></a><a name="テンプスト"></a>

    F67AH TEMPST: DEFS 30

このバッファは文字列ディスクリプタを格納するために使用されます。文字列生成側が結果をプッシュし、文字列消費側が結果をポップするスタックとして機能します。

<a name="f698h"></a><a name="dsctmp"></a>

    F698H DSCTMP: DEFS 3

このバッファは、文字列関数によって、構築中に結果ディスクリプタを保持するために使用されます。

<a name="f69bh"></a><a name="fretop"></a>

    F69BH FRETOP: DEFW F168H

この変数には、文字列記憶領域内の次の空き領域のアドレスが格納されます。領域が空の場合、[FRETOP](#fretop) は [MEMSIZ](#memsiz) と等しくなります。

<a name="f69dh"></a><a name="temp3"></a>

    F69DH TEMP3: DEFW 0000H

この変数は、インタープリタのさまざまな部分によって一時的な保存に使用されます。

<a name="f69fh"></a><a name="temp8"></a>

    F69FH TEMP8:  DEFW 0000H

この変数は、インタープリタのさまざまな部分によって一時的な保存に使用されます。

<a name="f6a1h"></a><a name="endfor"></a>

    F6A1H ENDFOR: DEFW 0000H

この変数は、パラメータ ブロックの構築中にステートメントの終了アドレスを保持するために、「`FOR`」ステートメント ハンドラによって使用されます。

<a name="f6a3h"></a><a name="datlin"></a>

    F6A3H DATLIN: DEFW 0000H

この変数には、プログラム テキスト内の現在の「`DATA`」項目の行番号が含まれます。

<a name="f6a5h"></a><a name="subflg"></a>

    F6A5H SUBFLG: DEFB 00H

この変数は通常はゼロですが、変数検索ルーチンによる添字の処理を制御するために、「`ERASE`」、「`FOR`」、「`FN`」、および「`DEF FN`」ハンドラによって設定されます。

<a name="f6a6h"></a><a name="flginp"></a>

    F6A6H FLGINP: DEFB 00H

この変数には、「`READ/INPUT`」ステートメント ハンドラー内の 2 つのステートメントを区別するためのフラグが含まれています: 00H=INPUT、NZ=READ。

<a name="f6a7h"></a><a name="temp"></a>

    F6A7H TEMP:   DEFW 0000H

この変数は、インタープリタのさまざまな部分によって一時的な保存に使用されます。

<a name="f6a9h"></a><a name="ptrflg"></a>

    F6A9H PTRFLG: DEFB 00H

この変数は通常はゼロですが、プログラム テキスト領域内の行番号オペランドがポインタに変換された場合に設定されます。

<a name="f6aah"></a><a name="autflg"></a>

    F6AAH AUTFLG: DEFB 00H

この変数は通常はゼロですが、「`AUTO`」モードがオンになっているときに設定されます。

<a name="f6abh"></a><a name="autlin"></a>

    F6ABH AUTLIN: DEFW 0000H

この変数には、現在の「`AUTO`」行番号が含まれます。

<a name="f6adh"></a><a name="autinc"></a>

    F6ADH AUTINC: DEFW 0000H

この変数には、現在の「`AUTO`」行番号の増分値が含まれています。

<a name="f6afh"></a><a name="savtxt"></a>

    F6AFH SAVTXT: DEFW 0000H

この変数は、各文の開始時にRunloopによってプログラムテキスト内の現在位置で更新されます。エラー回復時に使用され、"`RESUME`"文ハンドラの場合は[ERRTXT](#errtxt)、"`CONT`"文ハンドラの場合は[OLDTXT](#oldtxt)が設定されます。

<a name="f6b1h"></a><a name="savstk"></a>

    F6B1H SAVSTK: DEFW F09EH

この変数は、エラー回復の目的で、現在の Z80 SP を使用して各ステートメントの開始時に Runloop によって更新されます。

<a name="f6b3h"></a><a name="errlin"></a>

    F6B3H ERRLIN: DEFW 0000H

この変数は、エラーを生成したプログラム行の行番号を保持するためにエラー ハンドラによって使用されます。

<a name="f6b5h"></a><a name="dot"></a>

    F6B5H DOT:    DEFW 0000H

この変数は、メインループとエラー ハンドラーによって、 "." パラメーターで使用するために現在の行番号で更新されます。

<a name="f6b7h"></a><a name="errtxt"></a>

    F6B7H ERRTXT: DEFW 0000H

この変数は、"`RESUME`" ステートメント ハンドラーで使用するために、エラー ハンドラーによって [SAVTXT](#savtxt) から更新されます。

<a name="f6b9h"></a><a name="onelin"></a>

    F6B9H ONELIN: DEFW 0000H

この変数は、エラーが発生したときに実行するプログラム行のアドレスを使用して、「`ON ERROR GOTO`」ステートメント ハンドラーによって設定されます。

<a name="f6bbh"></a><a name="oneflg"></a>

    F6BBH ONEFLG: DEFB 00H

この変数は通常はゼロですが、制御が「`ON ERROR GOTO`」文に移った際にエラーハンドラによって設定されます。これは、エラー回復文内でエラーが発生した場合にループが発生するのを防ぐためです。

<a name="f6bch"></a><a name="temp2"></a>

    F6BCH TEMP2:  DEFW 0000H

この変数は、インタープリタのさまざまな部分によって一時的な保存に使用されます。

<a name="f6beh"></a><a name="oldlin"></a>

    F6BEH OLDLIN: DEFW 0000H

この変数には、終了するプログラム行の行番号が格納されます。この変数は、「`END`」および「`STOP`」ステートメントハンドラによって設定され、「`CONT`」ステートメントで使用されます。

<a name="f6c0h"></a><a name="oldtxt"></a>

    F6C0H OLDTXT: DEFW 0000H

この変数には終了するプログラム ステートメントのアドレスが含まれます。

<a name="f6c2h"></a><a name="vartab"></a>

    F6C2H VARTAB: DEFW 8003H

この変数には、変数記憶領域の最初のバイトのアドレスが含まれます。

<a name="f6c4h"></a><a name="arytab"></a>

    F6C4H ARYTAB: DEFW 8003H

この変数には、配列ストレージ領域の最初のバイトのアドレスが含まれます。

<a name="f6c6h"></a><a name="strend"></a>

    F6C6H STREND: DEFW 8003H

この変数には、配列ストレージ領域に続くバイトのアドレスが含まれます。

<a name="f6c8h"></a><a name="datptr"></a>

    F6C8H DATPTR: DEFW 8000H

この変数には、プログラム テキスト内の現在の「`DATA`」項目のアドレスが含まれます。

<a name="f6cah"></a><a name="deftbl"></a>
<a name="f6cbh"></a>
<a name="f6cch"></a>
<a name="f6cdh"></a>
<a name="f6ceh"></a>
<a name="f6cfh"></a>
<a name="f6d0h"></a>
<a name="f6d1h"></a>
<a name="f6d2h"></a>
<a name="f6d3h"></a>
<a name="f6d4h"></a>
<a name="f6d5h"></a>
<a name="f6d6h"></a>
<a name="f6d7h"></a>
<a name="f6d8h"></a>
<a name="f6d9h"></a>
<a name="f6dah"></a>
<a name="f6dbh"></a>
<a name="f6dch"></a>
<a name="f6ddh"></a>
<a name="f6deh"></a>
<a name="f6dfh"></a>
<a name="f6e0h"></a>
<a name="f6e1h"></a>
<a name="f6e2h"></a>
<a name="f6e3h"></a>

```
F6CAH DEFTBL: DEFB 08H     ; A
F6CBH         DEFB 08H     ; B
F6CCH         DEFB 08H     ; C
F6CDH         DEFB 08H     ; D
F6CEH         DEFB 08H     ; E
F6CFH         DEFB 08H     ; F
F6D0H         DEFB 08H     ; G
F6D1H         DEFB 08H     ; H
F6D2H         DEFB 08H     ; I
F6D3H         DEFB 08H     ; J
F6D4H         DEFB 08H     ; K
F6D5H         DEFB 08H     ; L
F6D6H         DEFB 08H     ; M
F6D7H         DEFB 08H     ; N
F6D8H         DEFB 08H     ; O
F6D9H         DEFB 08H     ; P
F6DAH         DEFB 08H     ; Q
F6DBH         DEFB 08H     ; R
F6DCH         DEFB 08H     ; S
F6DDH         DEFB 08H     ; T
F6DEH         DEFB 08H     ; U
F6DFH         DEFB 08H     ; V
F6E0H         DEFB 08H     ; W
F6E1H         DEFB 08H     ; X
F6E2H         DEFB 08H     ; Y
F6E3H         DEFB 08H     ; Z
```

これら26個の変数は、BASIC変数の各グループのデフォルトの型を保持します。これらの値は、電源投入時、"`NEW`"、および "`CLEAR` 実行時に倍精度に設定され、その後は "`DEF`" グループのステートメントによってのみ変更されます。

<a name="f6e4h"></a><a name="prmstk"></a>

    F6E4H PRMSTK: DEFW 0000H

この変数には、Z80スタック上の前の「`FN`」パラメータブロックのベースアドレスが格納されます。文字列ガベージコレクション中に、スタック上のブロック間を移動するために使用されます。

<a name="f6e6h"></a><a name="prmlen"></a>

    F6E6H PRMLEN: DEFW 0000H

この変数には、[PARM1](#parm1) 内の現在の "`FN`" パラメータ ブロックの長さが含まれます。

<a name="f6e8h"></a><a name="parm1"></a>

    F6E8H PARM1 : DEFS 100

このバッファには、現在評価中の「`FN`」関数に属するローカル変数が含まれています。

<a name="f74ch"></a><a name="prmprv"></a>

    F74CH PRMPRV: DEFW F6E4H

この変数には、前の「`FN`」パラメータブロックのアドレスが格納されます。これは実際には、文字列ガベージコレクションがスタック上のパラメータブロックに進む前に、現在のパラメータブロックから開始されることを保証するために使用される定数です。

<a name="f74eh"></a><a name="prmln2"></a>

    F74EH PRMLN2: DEFW 0000H

この変数には、[PARM2](#parm2) で構築される「`FN`」パラメータブロックの長さが含まれます。

<a name="f750h"></a><a name="parm2"></a>

    F750H PARM2:  DEFS 100

このバッファは、現在の「`FN`」関数が所有するローカル変数を構築するために使用されます。

<a name="f7b4h"></a><a name="prmflg"></a>

    F7B4H PRMFLG: DEFB 00H

この変数は変数検索中に使用され、ローカル変数またはグローバル変数が検査されているかどうかを示します。

<a name="f7b5h"></a><a name="aryta2"></a>

    F7B5H ARYTA2: DEFW 0000H

この変数は、変数検索中に、検査対象のストレージ領域の終了アドレスを保持するために使用されます。

<a name="f7b7h"></a><a name="nofuns"></a>

    F7B7H NOFUNS: DEFB 00H

この変数は通常はゼロですが、「`FN`」関数ハンドラによって設定され、変数検索ルーチンにローカル変数が存在することを示します。

<a name="f7b8h"></a><a name="temp9"></a>

    F7B8H TEMP9:  DEFW 0000H

この変数は、インタープリタのさまざまな部分によって一時的な保存に使用されます。

<a name="f7bah"></a><a name="funact"></a>

    F7BAH FUNACT: DEFW 0000H

この変数には、現在アクティブな「`FN`」関数の数が含まれます。

<a name="f7bch"></a><a name="swptmp"></a>

    F7BCH SWPTMP: DEFS 8

このバッファは、「`SWAP`」ステートメントの最初のオペランドを保持するために使用されます。

<a name="f7c4h"></a><a name="trcflg"></a>

    F7C4H TRCFLG: DEFB 00H

この変数は通常はゼロですが、トレース機能をオンにするために「`TRON`」ステートメント ハンドラーによって設定されます。

<a name="f7c5h"></a><a name="fbuffr"></a>

    F7C5H FBUFFR: DEFS 43

このバッファは、数値出力変換中に生成されたテキストを保持するために使用されます。

<a name="f7f0h"></a><a name="dectmp"></a>

    F7F0H DECTMP: DEFW 0000H

この変数は、倍精度除算ルーチンによって一時的な保存に使用されます。

<a name="f7f2h"></a><a name="dectm2"></a>

    F7F2H DECTM2: DEFW 0000H

この変数は、倍精度除算ルーチンによって一時的な保存に使用されます。

<a name="f7f4h"></a><a name="deccnt"></a>

    F7F4H DECCNT: DEFB 00H

この変数は、倍精度除算ルーチンによって使用され、2 番目のオペランドの仮数部の非ゼロバイト数を保持します。

<a name="f7f6h"></a><a name="dac"></a>

    F7F6H DAC:    DEFS 16

このバッファは、式の評価中にインタープリタの主なアキュムレータとして機能します。

<a name="f806h"></a><a name="hold8"></a>

    F806H HOLD8:  DEFS 65

このバッファは、倍精度乗算ルーチンによって、最初のオペランドの倍数を保持するために使用されます。

<a name="f847h"></a><a name="arg"></a>

    F847H ARG:    DEFS 16

このバッファは、式の評価中にインタープリタの二次アキュムレータとして機能します。

<a name="f857h"></a><a name="rndx"></a>

    F857H RNDX:   DEFS 8

このバッファには現在の倍精度乱数が含まれています。

<a name="f85fh"></a><a name="マックスフィル"></a>

    F85FH MAXFIL: DEFB 01H

この変数には、現在割り当てられているユーザーI/Oバッファの数が格納されます。この値は電源投入時に1に設定され、その後は「`MAXFILES`」ステートメントによってのみ変更されます。

<a name="f860h"></a><a name="filtab"></a>

    F860H FILTAB: DEFW F16AH

この変数には、I/O バッファ FCB のポインタ テーブルのアドレスが含まれます。

<a name="f862h"></a><a name="nulbuf"></a>

    F862H NULBUF: DEFW F177H

この変数には、I/O バッファ 0 に属するデータ バッファの最初のバイトのアドレスが含まれます。

<a name="f864h"></a><a name="ptrfil"></a>

    F864H PTRFIL: DEFW 0000H

この変数には、現在アクティブな I/O バッファ FCB のアドレスが含まれます。

<a name="f866h"></a><a name="filnam"></a>

    F866H FILNAM: DEFS 11

このバッファは、ユーザーが指定したファイル名を保持します。「`FILENAME.BAS`」のようなディスクファイル指定に対応するため、11文字の長さになっています。

<a name="f871h"></a><a name="filnm2"></a>

    F871H FILNM2: DEFS 11

このバッファは、[FILNAM](#filnam) の内容と比較するために、I/O デバイスから読み取ったファイル名を保持します。

<a name="f87ch"></a><a name="nlonly"></a>

    F87CH NLONLY: DEFB 00H

この変数は通常はゼロですが、プログラム「`LOAD`」実行中に設定されます。ビット0は、ロード中にI/Oバッファ0が閉じられるのを防ぐために使用され、ビット7は、自動実行が必要な場合にユーザーI/Oバッファが閉じられるのを防ぐために使用されます。

<a name="f87dh"></a><a name="savend"></a>

    F87DH SAVEND: DEFW 0000H

この変数は、保存するメモリ ブロックの終了アドレスを保持するために、 "`BSAVE`" ステートメント ハンドラーによって使用されます。

<a name="f87fh"></a><a name="fnkstr"></a>

    F87FH FNKSTR: DEFS 160

このバッファには、16文字のファンクションキー文字列が10個格納されています。これらの値は電源投入時に設定され、その後は「`KEY`」ステートメントによってのみ変更されます。

<a name="f91fh"></a><a name="cgpnt"></a>
<a name="f920h"></a>

```
F91FH CGPNT:  DEFB 00H     ; Slot ID
F920H         DEFW 1BBFH   ; Address
```

これらの変数は、[INITXT](#initxt) および [INIT32](#init32) 標準ルーチンによってVDPにコピーされた文字セットの位置を保持します。これらの値は電源投入時にMSX ROMの文字セットに設定され、その後は変更されません。

<a name="f922h"></a><a name="ナンバス"></a>

    F922H NAMBAS: DEFW 0000H

この変数には、現在のテキストモードのVDPネームテーブルベースアドレスが格納されます。この値は、[INITXT](#initxt) または [INIT32](#init32) 標準ルーチンによってVDPがテキストモードに初期化されるたびに、[TXTNAM](#txtnam) または [T32NAM](#t32nam) から設定されます。

<a name="f924h"></a><a name="cgpbas"></a>

    F924H CGPBAS: DEFW 0800H

この変数には、現在のテキストモードのVDP文字パターンテーブルのベースアドレスが格納されます。この値は、[INITXT](#initxt) または [INIT32](#init32) 標準ルーチンによってVDPがテキストモードに初期化されるたびに、[TXTCGP](#txtcgp) または [T32CGP](#t32cgp) から設定されます。

<a name="f926h"></a><a name="patbas"></a>

    F926H PATBAS: DEFW 3800H

この変数は、現在のVDPスプライトパターンテーブルのベースアドレスを保持します。この値は、VDPが[INIT32](#init32)、[INIGRP](#inigrp)、または[INIMLT](#inimlt)標準ルーチンによって初期化されるたびに、[T32PAT](#t32pat)、[GRPPAT](#grppat)、または[MLTPAT](#mltpat)から設定されます。

<a name="f928h"></a><a name="atrbas"></a>

    F928H ATRBAS: DEFW 1B00H

この変数は、現在のVDPスプライト属性テーブルのベースアドレスを保持します。この値は、VDPが[INIT32](#init32)、[INIGRP](#inigrp)、または[INIMLT](#inimlt)標準ルーチンによって初期化されるたびに、[T32ATR](#t32atr)、[GRPATR](#grpatr)、または[MLTATR](#mltatr)から設定されます。

<a name="f92ah"></a><a name="cloc"></a>
<a name="f92ch"></a><a name="cmask"></a>

```
F92AH CLOC:   DEFW 0000H   ; ピクセル位置
F92CH CMASK:  DEFB 80H     ; ピクセルマスク
```

これらの変数には、[RIGHTC](#rightc)、[LEFTC](#leftc)、[UPC](#upc)、[TUPC](#tupc)、[DOWNC](#downc)、[TDOWNC](#tdownc)、[FETCHC](#fetchc)、[STOREC](#storec)、[READC](#readc)、[SETC](#setc)、[NSETCX](#nsetcx)、[SCANR](#scanr)、[SCANL](#scanl) 標準ルーチンで使用される現在のピクセルの物理アドレスが含まれます。[CLOC](#cloc) は現在のピクセルを含むバイトのアドレスを保持し、[CMASK](#cmask) はそのバイト内のピクセルを定義します。

<a name="f92dh"></a><a name="mindel"></a>

    F92DH MINDEL: DEFW 0000H

この変数は、線の終点間の最小差を保持するために、「`LINE`」ステートメント ハンドラーによって使用されます。

<a name="f92fh"></a><a name="maxdel"></a>

    F92FH MAXDEL: DEFW 0000H

この変数は、"`LINE`" ステートメント ハンドラーによって使用され、線の終点間の最大差を保持します。

<a name="f931h"></a><a name="aspect"></a>

    F931H ASPECT: DEFW 0000H

この変数は、「`CIRCLE`」文ハンドラによって現在のアスペクト比を保持するために使用されます。これは1バイトのバイナリ小数として保存されるため、アスペクト比が0.75の場合は00C0Hとなります。MSBは、アスペクト比がちょうど1.00、つまり0100Hの場合にのみ必要です。

<a name="f933h"></a><a name="cencnt"></a>

    F933H CENCNT: DEFW 0000H

この変数は、終了角度のポイント数を保持するため、「`CIRCLE`」ステートメント ハンドラーによって使用されます。

<a name="f935h"></a><a name="clinef"></a>

    F935H CLINEF: DEFB 00H

この変数は、「`CIRCLE`」ステートメントハンドラによって、2つの線フラグを保持するために使用されます。開始角度から中心までの線が必要な場合はビット0が設定され、終了角度からの線が必要な場合はビット7が設定されます。

<a name="f936h"></a><a name="cnpnts"></a>

    F936H CNPNTS: DEFW 0000H

この変数は、45 度のセグメント内のポイントの数を保持するため、「`CIRCLE`」ステートメント ハンドラーによって使用されます。

<a name="f938h"></a><a name="cplotf"></a>

    F938H CPLOTF: DEFB 00H

この変数は通常はゼロですが、終了角度が開始角度よりも小さい場合、「`CIRCLE`」ステートメントハンドラによって設定されます。この変数は、ピクセルを角度の「内側」に配置するか「外側」に配置するかを決定するために使用されます。

<a name="f939h"></a><a name="cpcnt"></a>

    F939H CPCNT:  DEFW 0000H

この変数は、現在の 45 度セグメント内のポイント数 (実際には Y 座標) を保持するために、「`CIRCLE`」ステートメント ハンドラーによって使用されます。

<a name="f93bh"></a><a name="cpcnt8"></a>

    F93BH CPCNT8: DEFW 0000H

この変数は、現在の位置の合計ポイント数を保持するため、「`CIRCLE`」ステートメント ハンドラーによって使用されます。

<a name="f93dh"></a><a name="crcsum"></a>

    F93DH CRCSUM: DEFW 0000H

この変数は、"`CIRCLE`" ステートメント ハンドラーによってポイント計算カウンターとして使用されます。

<a name="f93fh"></a><a name="cstcnt"></a>

    F93FH CSTCNT: DEFW 0000H

この変数は、開始角度のポイント数を保持するため、「`CIRCLE`」ステートメント ハンドラーによって使用されます。

<a name="f941h"></a><a name="csclxy"></a>

    F941H CSCLXY: DEFB 00H

この変数は、楕円形押し潰しを適用する方向を決定するフラグとして、「`CIRCLE`」ステートメント ハンドラーによって使用されます (00H=Y、01H=X)。

<a name="f942h"></a><a name="csavea"></a>

    F942H CSAVEA: DEFW 0000H

この変数は、[SCANR](#scanr) 標準ルーチンによって一時的な保存に使用されます。

<a name="f944h"></a><a name="csavem"></a>

    F944H CSAVEM: DEFB 00h

この変数は、[SCANR](#scanr) 標準ルーチンによって一時的な保存に使用されます。

<a name="f945h"></a><a name="cxoff"></a>

    F945H CXOFF:  DEFW 0000H

この変数は、「`CIRCLE`」ステートメント ハンドラーによって一時的な保存に使用されます。

<a name="f947h"></a><a name="cyoff"></a>

    F947H CYOFF:  DEFW 0000H

この変数は、「`CIRCLE`」ステートメント ハンドラーによって一時的な保存に使用されます。

<a name="f949h"></a><a name="lohmsk"></a>

    F949H LOHMSK: DEFB 00H

この変数は、LH エクスカーションの左端の位置を保持するため、「`PAINT`」ステートメント ハンドラーによって使用されます。

<a name="f94ah"></a><a name="lohdir"></a>

    F94AH LOHDIR: DEFB 00H

この変数は、LH エクスカーションに必要な新しいペイント方向を保持するために、「`PAINT`」ステートメント ハンドラーによって使用されます。

<a name="f94bh"></a><a name="lohadr"></a>

    F94BH LOHADR: DEFW 0000H

この変数は、LH エクスカーションの左端の位置を保持するため、「`PAINT`」ステートメント ハンドラーによって使用されます。

<a name="f94dh"></a><a name="lohcnt"></a>

    F94DH LOHCNT: DEFW 0000H

この変数は、LH エクスカーションのサイズを保持するため、 "`PAINT`" ステートメント ハンドラーによって使用されます。

<a name="f94fh"></a><a name="skpcnt"></a>

    F94FH SKPCNT: DEFW 0000H

この変数は、「`PAINT`」ステートメント ハンドラーによって使用され、[SCANR](#scanr) 標準ルーチンによって返されるスキップ カウントを保持します。

<a name="f951h"></a><a name="movcnt"></a>

    F951H MOVCNT: DEFW 0000H

この変数は、「`PAINT`」ステートメント ハンドラーによって使用され、[SCANR](#scanr) 標準ルーチンによって返される移動カウントを保持します。

<a name="f953h"></a><a name="pdirec"></a>

    F953H PDIREC: DEFB 00H

この変数は、現在のペイント方向を保持するため、 "`PAINT`" ステートメント ハンドラーによって使用されます: 40H = 下、C0H = 上、00H = 終了。

<a name="f954h"></a><a name="lfprog"></a>

    F954H LFPROG: DEFB 00H

この変数は通常はゼロですが、左方向の進行があった場合には「`PAINT`」ステートメント ハンドラーによって設定されます。

<a name="f955h"></a><a name="rtprog"></a>

    F955H RTPROG: DEFB 00H

この変数は通常はゼロですが、右方向の進行があった場合には「`PAINT`」ステートメント ハンドラーによって設定されます。

<a name="f956h"></a><a name="mcltab"></a>

    F956H MCLTAB: DEFW 0000H

この変数には、マクロ言語パーサーが使用するコマンドテーブルのアドレスが格納されます。「`DRAW`」テーブルは5D83H、「`PLAY`」テーブルは752EHにあります。

<a name="f958h"></a><a name="mclflg"></a>

    F958H MCLFLG: DEFB 00H

この変数は、マクロ言語パーサーが "`DRAW` ステートメント ハンドラーによって使用されている場合は 0 になり、"`PLAY` によって使用されている場合は 0 以外になります。

<a name="f959h"></a><a name="quetab"></a>
<a name="f95ah"></a>
<a name="f95bh"></a>
<a name="f95ch"></a>
<a name="f95dh"></a>
<a name="f95fh"></a>
<a name="f960h"></a>
<a name="f961h"></a>
<a name="f962h"></a>
<a name="f963h"></a>
<a name="f965h"></a>
<a name="f966h"></a>
<a name="f967h"></a>
<a name="f968h"></a>
<a name="f969h"></a>
<a name="f96bh"></a>
<a name="f96ch"></a>
<a name="f96dh"></a>
<a name="f96eh"></a>
<a name="f96fh"></a>

```
F959H QUETAB: DEFB 00H     ; AQ Put position
F95AH         DEFB 00H     ; AQ Get position
F95BH         DEFB 00H     ; AQ Putback flag
F95CH         DEFB 7FH     ; AQ Size
F95DH         DEFW F975H   ; AQ Address

F95FH         DEFB 00H     ; BQ Put position
F960H         DEFB 00H     ; BQ Get position
F961H         DEFB 00H     ; BQ Putback flag
F962H         DEFB 7FH     ; BQ Size
F963H         DEFW F9F5H   ; BQ Address

F965H         DEFB 00H     ; CQ Put position
F966H         DEFB 00H     ; CQ Get position
F967H         DEFB 00H     ; CQ Putback flag
F968H         DEFB 7FH     ; CQ Size
F969H         DEFW FA75H   ; CQ Address

F96BH         DEFB 00H     ; RQ Put position
F96CH         DEFB 00H     ; RQ Get position
F96DH         DEFB 00H     ; RQ Putback flag
F96EH         DEFB 00H     ; RQ Size
F96FH         DEFW 0000H   ; RQ Address
```

これら24個の変数は、3つの音楽キュー（[VOICAQ](#voicaq)、[VOICBQ](#voicbq)、[VOICCQ](#voiccq)）とRS232キューの制御ブロックを構成します。3つの音楽制御ブロックは[GICINI](#gicini)標準ルーチンによって初期化され、その後は割り込みハンドラと[PUTQ](#putq)標準ルーチンによって管理されます。RS232制御ブロックは、現在のMSX ROMでは使用されていません。

<a name="f971h"></a><a name="quebak"></a>
<a name="f972h"></a>
<a name="f973h"></a>
<a name="f974h"></a>

```
F971H QUEBAK: DEFB 00H     ; AQ Putback character
F972H         DEFB 00H     ; BQ Putback character
F973H         DEFB 00H     ; CQ Putback character
F974H         DEFB 00H     ; RQ Putback character
```

これらの4つの変数は、関連するキューに返された不要な文字を保持するために使用されます。プットバック機能はMSX ROMに実装されていますが、現在は使用されていません。

<a name="f975h"></a><a name="voicaq"></a>
<a name="f9f5h"></a><a name="voicbq"></a>
<a name="fa75h"></a><a name="voiccq"></a>
<a name="faf5h"></a><a name="rs2iq"></a>

```
F975H VOICAQ: DEFS 128     ; ボイスAキュー
F9F5H VOICBQ: DEFS 128     ; ボイスBキュー
FA75H VOICCQ: DEFS 128     ; ボイスCキュー
FAF5H RS2IQ:  DEFS 64      ; RS232 キュー
```

これら 4 つのバッファには 3 つの音楽キューと RS232 キューが含まれており、後者は使用されません。

<a name="fb35h"></a><a name="prscnt"></a>

    FB35H PRSCNT: DEFB 00H

この変数は、「`PLAY`」文ハンドラによって、完了したオペランド文字列の数をカウントするために使用されます。また、3つのオペランドがそれぞれ解析された後にビット7が設定され、標準ルーチン[STRTMS](#strtms)が繰り返し実行されるのを防ぎます。

<a name="fb36h"></a><a name="savsp"></a>

    FB36H SAVSP: DEFW 0000H

この変数は、「`PLAY`」文ハンドラによって、マクロ言語パーサに制御が移る前にZ80のSPを保存するために使用されます。この値は、パーサがキューフルで終了したためにスタックにデータが残っていないかどうかを判断するために、戻り時にSPと比較されます。

<a name="fb38h"></a><a name="voicen"></a>

    FB38H VOICEN: DEFB 00H

この変数には、"`PLAY`" ステートメントハンドラによって処理されている現在のボイス番号が格納されます。値 0、1、2 はそれぞれ PSG チャンネル A、B、C に対応します。

<a name="fb39h"></a><a name="savvol"></a>

    FB39H SAVVOL: DEFW 0000H

この変数は、ゼロ振幅の休符が生成されている間に現在の音量設定を保存するために、 "`PLAY`" ステートメントの "`R`" コマンド ハンドラーによって使用されます。

<a name="fb3bh"></a><a name="mcllen"></a>

    FB3BH MCLLEN: DEFB 00H

この変数は、解析中の文字列オペランドの長さを保持するため、マクロ言語パーサーによって使用されます。

<a name="fb3ch"></a><a name="mclptr"></a>

    FB3CH MCLPTR: DEFW 0000H

この変数は、解析中の文字列オペランドのアドレスを保持するため、マクロ言語パーサーによって使用されます。

<a name="fb3eh"></a><a name="queuen"></a>

    FB3EH QUEUEN: DEFB 00H

この変数は、割り込みハンドラによって、現在処理中の音楽キューの番号を保持するために使用されます。値0、1、2は、PSGチャンネルA、B、Cに対応します。

<a name="fb3fh"></a><a name="musicf"></a>

    FB3FH MUSICF: DEFB 00H

この変数には、[STRTMS](#strtms)標準ルーチンによって設定される3つのビットフラグが格納されます。これらのフラグは、割り込みハンドラによる音楽キューの処理を開始するために使用されます。ビット0、1、2はそれぞれ[VOICAQ](#voicaq)、[VOICBQ](#voicbq)、[VOICCQ](#voiccq)に対応します。

<a name="fb40h"></a><a name="plycnt"></a>

    FB40H PLYCNT: DEFB 00H

この変数は、[STRTMS](#strtms) 標準ルーチンによって使用され、現在音楽キューに保持されている「`PLAY`」文シーケンスの数を保持します。1つのシーケンスのキュー終了マークが3つすべて検出された場合、この変数の値を調べて、キューからの取り出しを再開するかどうかを決定します。

<a name="fb41h"></a><a name="vcba"></a>
<a name="fb43h"></a>
<a name="fb44h"></a>
<a name="fb46h"></a>
<a name="fb48h"></a>
<a name="fb49h"></a>
<a name="fb50h"></a>
<a name="fb51h"></a>
<a name="fb52h"></a>
<a name="fb53h"></a>
<a name="fb54h"></a>
<a name="fb56h"></a>

```
FB41H VCBA:   DEFW 0000H   ; 期間カウンタ
FB43H         DEFB 00H     ; 文字列の長さ
FB44H         DEFW 0000H   ; 文字列アドレス
FB46H         DEFW 0000H   ; スタックデータアドレス
FB48H         DEFB 00H     ; 音楽パケット長
FB49H         DEFS 7       ; 音楽パケット
FB50H         DEFB 04H     ; オクターブ
FB51H         DEFB 04H     ; 長さ
FB52H         DEFB 78H     ; テンポ
FB53H         DEFB 88H     ; ボリューム
FB54H         DEFW 00FFH   ; エンベロープ期間
FB56H         DEFS 16      ; スタックデータ用のスペース
```

この 37 バイトのバッファは、音声 A の現在のパラメータを保持するために、「`PLAY`」ステートメント ハンドラによって使用されます。

<a name="fb66h"></a><a name="vcbb"></a>

    FB66H VCBB:   DEFS 37

このバッファは、ボイス B の現在のパラメータを保持するために "`PLAY`" ステートメント ハンドラによって使用され、その構造は [VCBA](#vcba) と同じです。

<a name="fb8bh"></a><a name="vcbc"></a>

    FB8BH VCBC:   DEFS 37

このバッファは、ボイス C の現在のパラメータを保持するために "`PLAY`" ステートメント ハンドラによって使用され、その構造は [VCBA](#vcba) と同じです。

<a name="fbb0h"></a><a name="enstop"></a>

    FBB0H ENSTOP: DEFB 00H

この変数は、CODE、GRAPH、CTRL、SHIFT キーが同時に押されたことを検出したときに、割り込みハンドラがインタープリタのウォーム スタートを実行するかどうかを決定します。00H = 無効、NZ = 有効。

<a name="fbb1h"></a><a name="basrom"></a>

    FBB1H BASROM: DEFB 00H

この変数は、[ISCNTC](#iscntc) および [INLIN](#inlin) 標準ルーチンが CTRL-STOP キーに応答するかどうかを決定します。00H = 有効、NZ = 無効。これは、電源投入時の ROM 検索中に検出された BASIC ROM の終了を防ぐために使用されます。

<a name="fbb2h"></a><a name="linttb"></a>

    FBB2H LINTTB: DEFS 24

これら24個の変数は通常は非ゼロですが、対応する画面行の内容が次の行にオーバーフローした場合はゼロになります。これらの変数はBIOSによって管理されますが、実際には[INLIN](#inlin)標準ルーチン（画面エディタ）によって論理行と物理行を区別するためにのみ使用されます。

<a name="fbcah"></a><a name="fstpos"></a>

    FBCAH FSTPOS: DEFW 0000H

この変数は、[INLIN](#inlin)標準ルーチンのエントリ時にカーソル座標を保持するために使用されます。この変数の機能は、終了時に画面からテキストを収集する際に実行されるバックトラックの範囲を制限することです。

<a name="fbcch"></a><a name="cursav"></a>

    FBCCH CURSAV: DEFB 00H

この変数は、テキスト カーソルによって置き換えられた画面文字を保持するために使用されます。

<a name="fbcdh"></a><a name="fnkswi"></a>

    FBCDH FNKSWI: DEFB 00H

この変数は、[CHSNS](#chsns) 標準ルーチンによって使用され、シフトされたファンクション キーとシフトされていないファンクション キーのどちらが現在表示されているかを判断します。00H = シフト済み、01H = シフトなし。

<a name="fbceh"></a><a name="fnkflg"></a>

    FBCEH FNKFLG: DEFS 10

これら10個の変数は通常はゼロですが、「`KEY(n) ON`」文によって対応するファンクションキーがオンにされた場合は01Hに設定されます。これらの変数は、割り込みハンドラによって、プログラムモードにおいてのみ、文字列を返すか、[TRPTBL](#trptbl)内の対応するエントリを更新するかを決定するために使用されます。

<a name="fbd8h"></a><a name="ongsbf"></a>

    FBD8H ONGSBF: DEFB 00H

この変数は通常はゼロですが、デバイスがプログラム割り込みを生成するために必要な条件を満たすたびに、割り込みハンドラによってインクリメントされます。この変数は、Runloop によって [TRPTBL](#trptbl) を参照することなく、保留中のプログラム割り込みがあるかどうかを判断するために使用されます。

<a name="fbd9h"></a><a name="clikfl"></a>

    FBD9H CLIKFL: DEFB 00H

この変数は、ファンクション キーなどの単一のキーの押下から複数の文字を返すときに、誤ったキー クリックを防ぐために、割り込み ハンドラーによって内部的に使用されます。

<a name="fbdah"></a><a name="oldkey"></a>

    FBDAH OLDKEY: DEFS 11

このバッファは、割り込みハンドラによってキーボード マトリックスの前の状態を保持するために使用されます。各バイトには、行 0 から始まる 1 行のキーが含まれます。

<a name="fbe5h"></a><a name="newkey"></a>

    FBE5H NEWKEY: DEFS 11

このバッファは、割り込みハンドラによってキーボードマトリックスの現在の状態を保持するために使用されます。キーの遷移は[OLDKEY](#oldkey)の内容と比較することで検出され、その後[OLDKEY](#oldkey)が現在の状態に更新されます。

<a name="fbf0h"></a><a name="keybuf"></a>

    FBF0H KEYBUF: DEFS 40

このバッファには、割り込みハンドラによって生成されたデコードされたキーボード文字が格納されます。このバッファは[GETPNT](#getpnt)と[PUTPNT](#putpnt)によって駆動される循環キューとして構成されているため、固定の開始点はありません。

<a name="fc18h"></a><a name="linwrk"></a>

    FC18H LINWRK: DEFS 40

このバッファは、画面上の文字の完全な行を保持するため BIOS によって使用されます。

<a name="fc40h"></a><a name="patwrk"></a>

    FC40H PATWRK: DEFS 8

このバッファは、8x8 ピクセル パターンを保持するために BIOS によって使用されます。

<a name="fc48h"></a><a name="bottom"></a>

    FC48H BOTTOM: DEFW 8000H

この変数には、インタープリタが使用するRAMの最下位アドレスが格納されます。この値は電源投入時に設定され、その後は変更されません。

<a name="fc4ah"></a><a name="himem"></a>

    FC4AH HIMEM:  DEFW F380H

この変数には、インタープリタが使用するRAMの最上位アドレスに続くバイトのアドレスが格納されます。この値は電源投入時に設定され、その後は「`CLEAR`」文によってのみ変更されます。

<a name="fc4ch"></a><a name="trptbl"></a>
<a name="fc4fh"></a>
<a name="fc52h"></a>
<a name="fc55h"></a>
<a name="fc58h"></a>
<a name="fc5bh"></a>
<a name="fc5eh"></a>
<a name="fc61h"></a>
<a name="fc64h"></a>
<a name="fc67h"></a>
<a name="fc6ah"></a>
<a name="fc6dh"></a>
<a name="fc70h"></a>
<a name="fc73h"></a>
<a name="fc76h"></a>
<a name="fc79h"></a>
<a name="fc7ch"></a>
<a name="fc7fh"></a>
<a name="fc82h"></a>
<a name="fc85h"></a>
<a name="fc88h"></a>
<a name="fc8bh"></a>
<a name="fc8eh"></a>
<a name="fc91h"></a>
<a name="fc94h"></a>
<a name="fc97h"></a>

```
FC4CH TRPTBL: DEFS 3       ; KEY 1
FC4FH         DEFS 3       ; KEY 2
FC52H         DEFS 3       ; KEY 3
FC55H         DEFS 3       ; KEY 4
FC58H         DEFS 3       ; KEY 5
FC5BH         DEFS 3       ; KEY 6
FC5EH         DEFS 3       ; KEY 7
FC61H         DEFS 3       ; KEY 8
FC64H         DEFS 3       ; KEY 9
FC67H         DEFS 3       ; KEY 10
FC6AH         DEFS 3       ; STOP
FC6DH         DEFS 3       ; SPRITE
FC70H         DEFS 3       ; STRIG 0
FC73H         DEFS 3       ; STRIG 1
FC76H         DEFS 3       ; STRIG 2
FC79H         DEFS 3       ; STRIG 3
FC7CH         DEFS 3       ; STRIG 4
FC7FH         DEFS 3       ; INTERVAL
FC82H         DEFS 3       ; Unused
FC85H         DEFS 3       ; Unused
FC88H         DEFS 3       ; Unused
FC8BH         DEFS 3       ; Unused
FC8EH         DEFS 3       ; Unused
FC91H         DEFS 3       ; Unused
FC94H         DEFS 3       ; Unused
FC97H         DEFS 3       ; Unused
```

これら26個の3バイト変数は、割り込み生成デバイスの現在の状態を保持します。各エントリの最初のバイトには、デバイスのステータス（ビット0=オン、ビット1=停止、ビット2=イベントアクティブ）が含まれ、割り込みハンドラ、Runloop割り込みプロセッサ、および「`DEVICE 0=ON/OFF/STOP`」および「`RETURN`」ステートメントハンドラによって更新されます。各エントリの残りの2バイトは、「`ON DEVICE GOSUB`」ステートメントハンドラによって設定され、プログラム割り込み時に実行されるプログラム行のアドレスが含まれます。

<a name="fc9ah"></a><a name="rtycnt"></a>

    FC9AH RTYCNT: DEFB 00H

この変数は現在の MSX ROM では使用されていません。

<a name="fc9bh"></a><a name="intflg"></a>

    FC9BH INTFLG: DEFB 00H

この変数は通常はゼロですが、割り込みハンドラによって CTRL-STOP キーまたは STOP キーが検出された場合には 03H または 04H に設定されます。

<a name="fc9ch"></a><a name="pady"></a>

    FC9CH PADY:   DEFB 00H

この変数には、タッチパッドによって最後に検出されたポイントの Y 座標が含まれます。

<a name="fc9dh"></a><a name="padx"></a>

    FC9DH PADX:   DEFB 00H

この変数には、タッチパッドによって最後に検出されたポイントの X 座標が含まれます。

<a name="fc9eh"></a><a name="jiffy"></a>

    FC9EH JIFFY:  DEFW 0000H

この変数は割り込みハンドラによって継続的に増加します。その値は「`TIME`」文または関数によって設定または読み出すことができます。

<a name="fca0h"></a><a name="intval"></a>

    FCA0H INTVAL: DEFW 0000H

この変数は、「`ON INTERVAL`」ステートメント ハンドラーによって設定された間隔の期間を保持します。

<a name="fca2h"></a><a name="intcnt"></a>

    FCA2H INTCNT: DEFW 0000H

この変数は割り込みハンドラによって継続的に減算されます。値がゼロに達すると、[INTVAL](#intval) からリセットされ、該当する場合はプログラム割り込みが生成されます。この変数は、「`INTERVAL ON`」文がアクティブかどうかに関係なく、常にカウントされることに注意してください。

<a name="fca4h"></a><a name="lowlim"></a>

    FCA4H LOWLIM: DEFB 31H

この変数は、[TAPION](#tapion) 標準ルーチンによって決定された最小許容スタートビット期間を保持するために使用されます。

<a name="fca5h"></a><a name="winwid"></a>

    FCA5H WINWID: DEFB 22H

この変数は、[TAPION](#tapion) 標準ルーチンによって決定された LO/HI サイクル識別期間を保持するために使用されます。

<a name="fca6h"></a><a name="grphed"></a>

    FCA6H GRPHED: DEFB 00H

この変数は通常はゼロですが、グラフィック ヘッダー コードが検出されると [CNVCHR](#cnvchr) 標準ルーチンによって 01H に設定されます。

<a name="fca7h"></a><a name="esccnt"></a>

    FCA7H ESCCNT: DEFB 00H

この変数は、[CHPUT](#chput) 標準ルーチン ESC シーケンス プロセッサによって、エスケープ パラメータをカウントするために使用されます。

<a name="fca8h"></a><a name="insflg"></a>

    FCA8H INSFLG: DEFB 00H

この変数は通常はゼロですが、挿入モードがオンのときは [INLIN](#inlin) 標準ルーチンによって FFH に設定されます。

<a name="fca9h"></a><a name="csrsw"></a>

    FCA9H CSRSW:  DEFB 00H

この変数がゼロの場合、カーソルは[CHGET](#chget)標準ルーチンがキーボード入力を待機している間のみ表示されます。ゼロ以外の場合、カーソルは[CHPUT](#chput)標準ルーチンによって常時表示されます。

<a name="fcaah"></a><a name="cstyle"></a>

    FCAAH CSTYLE: DEFB 00H

この変数はカーソルのスタイルを決定します: 00H = ブロック、NZ = 下線。

<a name="fcabh"></a><a name="capst"></a>

    FCABH CAPST:  DEFB 00H

この変数は、割り込みハンドラによって、現在の Caps Lock ステータスを保持するために使用されます: 00H = オフ、NZ = オン。

<a name="fcach"></a><a name="kanast"></a>

    FCACH KANAST: DEFB 00H

この変数は、日本語マシンのキーボードのカナロック状態と、ヨーロッパのマシンの DEAD キー状態を保持するために使用されます。

<a name="fcadh"></a><a name="kanamd"></a>

    FCADH KANAMD: DEFB 00H

この変数は日本語マシンのみのキーボード モードを保持します。

<a name="fcaeh"></a><a name="flbmem"></a>

    FCAEH FLBMEM: DEFB 00H

この変数はファイル I/O エラー ジェネレータによって設定されますが、それ以外では使用されません。

<a name="fcafh"></a><a name="scrmod"></a>

    FCAFH SCRMOD: DEFB 00H

この変数には現在の画面モードが含まれます: 0=[40x24 テキスト モード](#40x24_text_mode)、1=[32x24 テキスト モード](#32x24_text_mode)、2=[グラフィック モード](#graphics_mode)、3=[マルチカラー モード](#multicolour_mode)。

<a name="fcb0h"></a><a name="oldscr"></a>

    FCB0H OLDSCR: DEFB 00H

この変数は、最後に設定されたテキスト モードの画面モードを保持します。

<a name="fcb1h"></a><a name="casprv"></a>

    FCB1H CASPRV: DEFB 00H

この変数は、カセット プットバック機能によって I/O バッファに返される文字を保持するために使用されます。

<a name="fcb2h"></a><a name="bdratr"></a>

    FCB2H BDRATR: DEFB 00H

この変数には、「`PAINT`」ステートメントハンドラの境界色が格納されます。この値は[PNTINI](#pntini)標準ルーチンによって設定され、[SCANR](#scanr)および[SCANL](#scanl)標準ルーチンによって使用されます。

<a name="fcb3h"></a><a name="gxpos"></a>

    FCB3H GXPOS:  DEFW 0000H

この変数はグラフィックスの X 座標を一時的に保存するために使用されます。

<a name="fcb5h"></a><a name="gypos"></a>

    FCB5H GYPOS:  DEFW 0000H

この変数はグラフィックスの Y 座標を一時的に保存するために使用されます。

<a name="fcb7h"></a><a name="grpacx"></a>

    FCB7H GRPACX: DEFW 0000H

この変数には、[GRPPRT](#grpprt) 標準ルーチンの現在のグラフィック X 座標が含まれます。

<a name="fcb9h"></a><a name="grpacy"></a>

    FCB9H GRPACY: DEFW 0000H

この変数には、[GRPPRT](#grpprt) 標準ルーチンの現在のグラフィック Y 座標が含まれます。

<a name="fcbbh"></a><a name="drwflg"></a>

    FCBBH DRWFLG: DEFB 00H

この変数のビット 6 と 7 は、関連するモードをオンにするために、"`DRAW`" ステートメントの "`N`" および "`B`" コマンド ハンドラーによって設定されます。

<a name="fcbch"></a><a name="drwscl"></a>

    FCBCH DRWSCL: DEFB 00H

この変数は、現在のスケール係数を保持するため、 "`DRAW`" ステートメントの "`S`" コマンド ハンドラーによって使用されます。

<a name="fcbdh"></a><a name="drwang"></a>

    FCBDH DRWANG: DEFB 00H

この変数は、現在の角度を保持するため、 "`DRAW`" ステートメントの "`A`" コマンド ハンドラーによって使用されます。

<a name="fcbeh"></a><a name="runbnf"></a>

    FCBEH RUNBNF: DEFB 00H

この変数は通常はゼロですが、自動実行の「`R`」パラメータが指定されている場合は「`BLOAD`」ステートメント ハンドラーによって設定されます。

<a name="fcbfh"></a><a name="savent"></a>

    FCBFH SAVENT: DEFW 0000H

この変数には、「`BSAVE`」および「`BLOAD`」エントリ アドレスが含まれます。

<a name="fcc1h"></a><a name="exptbl"></a>
<a name="fcc2h"></a>
<a name="fcc3h"></a>
<a name="fcc4h"></a>

```
FCC1H EXPTBL: DEFB 00H     ; Primary Slot 0
FCC2H         DEFB 00H     ; Primary Slot 1
FCC3H         DEFB 00H     ; Primary Slot 2
FCC4H         DEFB 00H     ; Primary Slot 3
```

これら 4 つの変数は通常はゼロですが、関連するプライマリ スロットが拡張されていることが判明した場合、電源投入時の RAM 検索中に 80H に設定されます。

<a name="fcc5h"></a><a name="slttbl"></a>
<a name="fcc6h"></a>
<a name="fcc7h"></a>
<a name="fcc8h"></a>

```
FCC5H SLTTBL: DEFB 00H     ; Primary Slot 0
FCC6H         DEFB 00H     ; Primary Slot 1
FCC7H         DEFB 00H     ; Primary Slot 2
FCC8H         DEFB 00H     ; Primary Slot 3
```

これらの4つの変数は、4つのセカンダリスロットレジスタの内容を複製します。各変数の内容は、[EXPTBL](#exptbl) が拡張対象となるプライマリスロットを示している場合にのみ有効とみなされます。

<a name="fcc9h"></a><a name="sltatr"></a>
<a name="fccdh"></a>
<a name="fcd1h"></a>
<a name="fcd5h"></a>
<a name="fcd9h"></a>
<a name="fcddh"></a>
<a name="fce1h"></a>
<a name="fce5h"></a>
<a name="fce9h"></a>
<a name="fcedh"></a>
<a name="fcf1h"></a>
<a name="fcf5h"></a>
<a name="fcf9h"></a>
<a name="fcfdh"></a>
<a name="fd01h"></a>
<a name="fd05h"></a>

```
FCC9H SLTATR: DEFS 4       ; PS0, SS0
FCCDH         DEFS 4       ; PS0, SS1
FCD1H         DEFS 4       ; PS0, SS2
FCD5H         DEFS 4       ; PS0, SS3

FCD9H         DEFS 4       ; PS1, SS0
FCDDH         DEFS 4       ; PS1, SS1
FCE1H         DEFS 4       ; PS1, SS2
FCE5H         DEFS 4       ; PS1, SS3

FCE9H         DEFS 4       ; PS2, SS0
FCEDH         DEFS 4       ; PS2, SS1
FCF1H         DEFS 4       ; PS2, SS2
FCF5H         DEFS 4       ; PS2, SS3

FCF9H         DEFS 4       ; PS3, SS0
FCFDH         DEFS 4       ; PS3, SS1
FD01H         DEFS 4       ; PS3, SS2
FD05H         DEFS 4       ; PS3, SS3
```

これらの64個の変数には、電源投入時のROM検索で見つかった拡張ROMの属性が格納されます。各16KB ROMの特性は1バイトにエンコードされているため、各スロットごとに4バイトが必要です。エンコードは以下のとおりです。

```
Bit 7 set=BASIC program
Bit 6 set=Device handler
Bit 5 set=Statement handler
```

ページ0（0000H～3FFFH）とページ3（C000H～FFFFH）のエントリは常にゼロになることに注意してください。実際に検査されるのはページ1（4000H～7FFFH）とページ2（8000H～BFFFH）のみです。MSXの慣例により、マシンコード拡張ROMはページ1に、BASICプログラムROMはページ2に配置されます。

<a name="fd09h"></a><a name="sltwrk"></a>

    FD09H SLTWRK: DEFS 128

このバッファは、64 個の拡張 ROM それぞれに対して 2 バイトのローカル ワークスペースを提供します。

<a name="fd89h"></a><a name="procnm"></a>

    FD89H PROCNM: DEFS 16

このバッファは、拡張 ROM による検査のためにデバイス名またはステートメント名を保持するために使用されます。

<a name="fd99h"></a><a name="device"></a>

    FD99H DEVICE: DEFB 00H

この変数は、0 から 3 までのデバイス コードを拡張 ROM に渡すために使用されます。

<a name="the_hooks"></a>

## フック

ワークスペース領域のFD9AHからFFC9Hまでのセクションには112個のフックが含まれており、それぞれに電源投入時に5個のZ80 RETオペコードがセットされます。これらのフックはBIOS/インタープリタ内の重要な位置から呼び出されるため、ROMを拡張することができ、特にDisk BASICへのアップグレードが容易になります。各フックには、任意のスロットへのファーコールを保持するのに十分なスペースがあります。

```
RST 30H
DEFB Slot ID
DEFW Address
RET
```

次のページに、フックの一覧と、その呼び出し元のアドレス、およびその機能に関する簡単な説明が記載されています。

|ADDRESS                    |NAME   |SIZE   |FROM           |FUNCTION|
|---------------------------|-------|-------|---------------|---------------------------------|
|<a name="fd9ah"></a>FD9AH  |HKEYI: |DEFS 5 |0C4AH          |割り込みハンドラ|
|<a name="fd9fh"></a>FD9FH  |HTIMI: |DEFS 5 |0C53H          |割り込みハンドラ|
|<a name="fda4h"></a>FDA4H  |HCHPU: |DEFS 5 |08C0H          |[CHPUT](#chput) standard routine|
|<a name="fda9h"></a>FDA9H  |HDSPC: |DEFS 5 |09E6H          |カーソル表示|
|<a name="fdaeh"></a>FDAEH  |HERAC: |DEFS 5 |0A33H          |カーソル消去|
|<a name="fdb3h"></a>FDB3H  |HDSPF: |DEFS 5 |0B2BH          |[DSPFNK](#dspfnk) standard routine|
|<a name="fdb8h"></a>FDB8H  |HERAF: |DEFS 5 |0B15H          |[ERAFNK](#erafnk) standard routine|
|<a name="fdbdh"></a>FDBDH  |HTOTE: |DEFS 5 |0842H          |[TOTEXT](#totext) standard routine|
|<a name="fdc2h"></a>FDC2H  |HCHGE: |DEFS 5 |10CEH          |[CHGET](#chget) standard routine|
|<a name="fdc7h"></a>FDC7H  |HINIP: |DEFS 5 |071EH          |Copy character set to VDP|
|<a name="fdcch"></a>FDCCH  |HKEYC: |DEFS 5 |1025H          |Keyboard decoder|
|<a name="fdd1h"></a>FDD1H  |HKYEA: |DEFS 5 |0F10H          |Keyboard decoder|
|<a name="fdd6h"></a>FDD6H  |HNMI:  |DEFS 5 |1398H          |[NMI](#nmi) standard routine|
|<a name="fddbh"></a>FDDBH  |HPINL: |DEFS 5 |23BFH          |[PINLIN](#pinlin) standard routine|
|<a name="fde0h"></a>FDE0H  |HQINL: |DEFS 5 |23CCH          |[QINLIN](#qinlin) standard routine|
|<a name="fde5h"></a>FDE5H  |HINLI: |DEFS 5 |23D5H          |[INLIN](#inlin) standard routine|
|<a name="fdeah"></a>FDEAH  |HONGO: |DEFS 5 |7810H          |"`ON DEVICE GOSUB`"|
|<a name="fdefh"></a>FDEFH  |HDSKO: |DEFS 5 |7C16H          |"`DSKO$`"|
|<a name="fdf4h"></a>FDF4H  |HSETS: |DEFS 5 |7C1BH          |"`SET`"|
|<a name="fdf9h"></a>FDF9H  |HNAME: |DEFS 5 |7C20H          |"`NAME`"|
|<a name="fdfeh"></a>FDFEH  |HKILL: |DEFS 5 |7C25H          |"`KILL`"|
|<a name="fe03h"></a>FE03H  |HIPL:  |DEFS 5 |7C2AH          |"`IPL`"|
|<a name="fe08h"></a>FE08H  |HCOPY: |DEFS 5 |7C2FH          |"`COPY`"|
|<a name="fe0dh"></a>FE0DH  |HCMD:  |DEFS 5 |7C34H          |"`CMD`"|
|<a name="fe12h"></a>FE12H  |HDSKF: |DEFS 5 |7C39H          |"`DSKF`"|
|<a name="fe17h"></a>FE17H  |HDSKI: |DEFS 5 |7C3EH          |"`DSKI$`"|
|<a name="fe1ch"></a>FE1CH  |HATTR: |DEFS 5 |7C43H          |"`ATTR$`"|
|<a name="fe21h"></a>FE21H  |HLSET: |DEFS 5 |7C48H          |"`LSET`"|
|<a name="fe26h"></a>FE26H  |HRSET: |DEFS 5 |7C4DH          |"`RSET`"|
|<a name="fe2bh"></a>FE2BH  |HFIEL: |DEFS 5 |7C52H          |"`FIELD`"|
|<a name="fe30h"></a>FE30H  |HMKI$: |DEFS 5 |7C57H          |"`MKI$`"|
|<a name="fe35h"></a>FE35H  |HMKS$: |DEFS 5 |7C5CH          |"`MKS$`"|
|<a name="fe3ah"></a>FE3AH  |HMKD$: |DEFS 5 |7C61H          |"`MKD$`"|
|<a name="fe3fh"></a>FE3FH  |HCVI:  |DEFS 5 |7C66H          |"`CVI`"|
|<a name="fe44h"></a>FE44H  |HCVS:  |DEFS 5 |7C6BH          |"`CVS`"|
|<a name="fe49h"></a>FE49H  |HCVD:  |DEFS 5 |7C70H          |"`CVD`"|
|<a name="fe4eh"></a>FE4EH  |HGETP: |DEFS 5 |6A93H          |Locate FCB|
|<a name="fe53h"></a>FE53H  |HSETF: |DEFS 5 |6AB3H          |Locate FCB|
|<a name="fe58h"></a>FE58H  |HNOFO: |DEFS 5 |6AF6H          |"`OPEN`"|
|<a name="fe5dh"></a>FE5DH  |HNULO: |DEFS 5 |6B0FH          |"`OPEN`"|
|<a name="fe62h"></a>FE62H  |HNTFL: |DEFS 5 |6B3BH          |Close I/O buffer 0|
|<a name="fe67h"></a>FE67H  |HMERG: |DEFS 5 |6B63H          |"`MERGE/LOAD`"|
|<a name="fe6ch"></a>FE6CH  |HSAVE: |DEFS 5 |6BA6H          |"`SAVE`"|
|<a name="fe71h"></a>FE71H  |HBINS: |DEFS 5 |6BCEH          |"`SAVE`"|
|<a name="fe76h"></a>FE76H  |HBINL: |DEFS 5 |6BD4H          |"`MERGE/LOAD`"|
|<a name="fe7bh"></a>FE7BH  |HFILE: |DEFS 5 |6C2FH          |"`FILES`"|
|<a name="fe80h"></a>FE80H  |HDGET: |DEFS 5 |6C3BH          |"`GET/PUT`"|
|<a name="fe85h"></a>FE85H  |HFILO: |DEFS 5 |6C51H          |Sequential output|
|<a name="fe8ah"></a>FE8AH  |HINDS: |DEFS 5 |6C79H          |Sequential input|
|<a name="fe8fh"></a>FE8FH  |HRSLF: |DEFS 5 |6CD8H          |"`INPUT$`"|
|<a name="fe94h"></a>FE94H  |HSAVD: |DEFS 5 |6D03H, 6D14H   |"`LOC`", "`LOF`",|
|                           |       |       |6D25H, 6D39H   |"`EOF`", "`FPOS`"|
|<a name="fe99h"></a>FE99H  |HLOC:  |DEFS 5 |6D0FH          |"`LOC`"|
|<a name="fe9eh"></a>FE9EH  |HLOF:  |DEFS 5 |6D20H          |"`LOF`"|
|<a name="fea3h"></a>FEA3H  |HEOF:  |DEFS 5 |6D33H          |"`EOF`"|
|<a name="fea8h"></a>FEA8H  |HFPOS: |DEFS 5 |6D43H          |"`FPOS`"|
|<a name="feadh"></a>FEADH  |HBAKU: |DEFS 5 |6E36H          |"`LINE INPUT#`"|
|<a name="feb2h"></a>FEB2H  |HPARD: |DEFS 5 |6F15H          |Parse device name|
|<a name="feb7h"></a>FEB7H  |HNODE: |DEFS 5 |6F33H          |Parse device name|
|<a name="febch"></a>FEBCH  |HPOSD: |DEFS 5 |6F37H          |Parse device name|
|<a name="fec1h"></a>FEC1H  |HDEVN: |DEFS 5 |               |This hook is not used.|
|<a name="fec6h"></a>FEC6H  |HGEND: |DEFS 5 |6F8FH          |I/O function dispatcher|
|<a name="fecbh"></a>FECBH  |HRUNC: |DEFS 5 |629AH          |Run-clear|
|<a name="fed0h"></a>FED0H  |HCLEA: |DEFS 5 |62A1H          |Run-clear|
|<a name="fed5h"></a>FED5H  |HLOPD: |DEFS 5 |62AFH          |Run-clear|
|<a name="fedah"></a>FEDAH  |HSTKE: |DEFS 5 |62F0H          |Reset stack|
|<a name="fedfh"></a>FEDFH  |HISFL: |DEFS 5 |145FH          |[ISFLIO](#isflio) standard routine |
|<a name="fee4h"></a>FEE4H  |HOUTD: |DEFS 5 |1B46H          |[OUTDO](#outdo) standard routine|
|<a name="fee9h"></a>FEE9H  |HCRDO: |DEFS 5 |7328H          |CR,LF to [OUTDO](#outdo)|
|<a name="feeeh"></a>FEEEH  |HDSKC: |DEFS 5 |7374H          |Mainloop line input|
|<a name="fef3h"></a>FEF3H  |HDOGR: |DEFS 5 |593CH          |Line draw|
|<a name="fef8h"></a>FEF8H  |HPRGE: |DEFS 5 |4039H          |Program end|
|<a name="fefdh"></a>FEFDH  |HERRP: |DEFS 5 |40DCH          |Error handler|
|<a name="ff02h"></a>FF02H  |HERRF: |DEFS 5 |40FDH          |Error handler|
|<a name="ff07h"></a>FF07H  |HREAD: |DEFS 5 |4128H          |Mainloop "`OK`"|
|<a name="ff0ch"></a>FF0CH  |HMAIN: |DEFS 5 |4134H          |Mainloop|
|<a name="ff11h"></a>FF11H  |HDIRD: |DEFS 5 |41A8H          |Mainloop direct statement|
|<a name="ff16h"></a>FF16H  |HFINI: |DEFS 5 |4237H          |Mainloop finished|
|<a name="ff1bh"></a>FF1BH  |HFINE: |DEFS 5 |4247H          |Mainloop finished|
|<a name="ff20h"></a>FF20H  |HCRUN: |DEFS 5 |42B9H          |Tokenize|
|<a name="ff25h"></a>FF25H  |HCRUS: |DEFS 5 |4353H          |Tokenize|
|<a name="ff2ah"></a>FF2AH  |HISRE: |DEFS 5 |437CH          |Tokenize|
|<a name="ff2fh"></a>FF2FH  |HNTFN: |DEFS 5 |43A4H          |Tokenize|
|<a name="ff34h"></a>FF34H  |HNOTR: |DEFS 5 |44EBH          |Tokenize|
|<a name="ff39h"></a>FF39H  |HSNGF: |DEFS 5 |45D1H          |"`FOR`"|
|<a name="ff3eh"></a>FF3EH  |HNEWS: |DEFS 5 |4601H          |Runloop new statement|
|<a name="ff43h"></a>FF43H  |HGONE: |DEFS 5 |4646H          |Runloop execute|
|<a name="ff48h"></a>FF48H  |HCHRG: |DEFS 5 |4666H          |[CHRGTR](#chrgtr) standard routine|
|<a name="ff4dh"></a>FF4DH  |HRETU: |DEFS 5 |4821H          |"`RETURN`"|
|<a name="ff52h"></a>FF52H  |HPRTF: |DEFS 5 |4A5EH          |"`PRINT`"|
|<a name="ff57h"></a>FF57H  |HCOMP: |DEFS 5 |4A54H          |"`PRINT`"|
|<a name="ff5ch"></a>FF5CH  |HFINP: |DEFS 5 |4AFFH          |"`PRINT`"|
|<a name="ff61h"></a>FF61H  |HTRMN: |DEFS 5 |4B4DH          |"`READ/INPUT`" error|
|<a name="ff66h"></a>FF66H  |HFRME: |DEFS 5 |4C6DH          |Expression Evaluator|
|<a name="ff6bh"></a>FF6BH  |HNTPL: |DEFS 5 |4CA6H          |Expression Evaluator|
|<a name="ff70h"></a>FF70H  |HEVAL: |DEFS 5 |4DD9H          |Factor Evaluator|
|<a name="ff75h"></a>FF75H  |HOKNO: |DEFS 5 |4F2CH          |Factor Evaluator|
|<a name="ff7ah"></a>FF7AH  |HFING: |DEFS 5 |4F3EH          |Factor Evaluator|
|<a name="ff7fh"></a>FF7FH  |HISMI: |DEFS 5 |51C3H          |Runloop execute|
|<a name="ff84h"></a>FF84H  |HWIDT: |DEFS 5 |51CCH          |"`WIDTH`"|
|<a name="ff89h"></a>FF89H  |HLIST: |DEFS 5 |522EH          |"`LIST`"|
|<a name="ff8eh"></a>FF8EH  |HBUFL: |DEFS 5 |532DH          |Detokenize|
|<a name="ff93h"></a>FF93H  |HFRQI: |DEFS 5 |543FH          |Convert to integer|
|<a name="ff98h"></a>FF98H  |HSCNE: |DEFS 5 |5514H          |Line number to pointer|
|<a name="ff9dh"></a>FF9DH  |HFRET: |DEFS 5 |67EEH          |Free descriptor|
|<a name="ffa2h"></a>FFA2H  |HPTRG: |DEFS 5 |5EA9H          |Variable search|
|<a name="ffa7h"></a>FFA7H  |HPHYD: |DEFS 5 |148AH          |[PHYDIO](#phydio) standard routine|
|<a name="ffach"></a>FFACH  |HFORM: |DEFS 5 |148EH          |[FORMAT](#format) standard routine|
|<a name="ffb1h"></a>FFB1H  |HERRO: |DEFS 5 |406FH          |Error handler|
|<a name="ffb6h"></a>FFB6H  |HLPTO: |DEFS 5 |085DH          |[LPTOUT](#lptout) standard routine|
|<a name="ffbbh"></a>FFBBH  |HLPTS: |DEFS 5 |0884H          |[LPTSTT](#lptstt) standard routine|
|<a name="ffc0h"></a>FFC0H  |HSCRE: |DEFS 5 |79CCH          |"`SCREEN`"|
|<a name="ffc5h"></a>FFC5H  |HPLAY: |DEFS 5 |73E5H          |"`PLAY`" statement|

</a>

FFCAHからFFFFHまでのワークスペース領域は未使用です。(MSX 1の場合)

<br><br><br>

<a name="chapter_7"></a>

# 7. マシンコードプログラム

この章では、MSXシステムリソースの使用方法を説明するために、いくつかのマシンコードプログラムを掲載しています。これらのプログラムはZENアセンブラで作成されていますが、BASICから実行できるように設計されており、必要に応じて、以下に示すローダーを使用して16進形式で入力することもできます。実行する前に、コードをカセットに保存してください。

```
10 CLEAR 200,&HE000
20 ADDR=&HE000
30 PRINT RIGHT$ ("000"+HEX$(ADDR),4);
40 INPUT D$
50 POKE ADDR,VAL("&H"+D$)
60 ADDR=ADDR+l
70 GOTO 30
```

すべてのプログラムはアドレスE000Hから開始し、同じポイントから開始されます。特に指定がない限り、プログラムにパラメータを渡す必要はありません。したがって、単純な`DEFUSR=&HE000:?USR(0)`ステートメントで実行を開始できます。

<a name="keyboard_matrix"></a>

## キーボードマトリックス

このプログラムは、キーボードマトリックスを画面に表示し、キーの押下を直接観察できるようにします。プログラムはCtrlキーとStopキーを押すことで終了できます。ただし、3つまたは4つ以上のキーを同時に押すと、特定の状況下でキーの誤押下が発生する可能性があることに注意してください。これは、すべてのマトリックス型キーボードに共通する特性です。

```
                            ORG     0E000H
                            LOAD    0E000H

                    ; ******************************
                    ; *   BIOS STANDARD ROUTINES   *
                    ; ******************************

                    INITXT: EQU     006CH
                    CHPUT:  EQU     00A2H
                    SNSMAT: EQU     0141H
                    BREAKX: EQU     00B7H

                    ; ******************************
                    ; *     WORKSPACE VARIABLES    *
                    ; ******************************

                    INTFLG: EQU     0FC9BH

                    ; ******************************
                    ; *      CONTROL CHARACTERS    *
                    ; ******************************

                    LF:     EQU     10
                    HOME:   EQU     11
                    CR:     EQU     13

E000    CD6C00      MATRIX: CALL    INITXT              ; SCREEN 0
E003    3E0B        MX1:    LD      A,HOME              ;
E005    CDA200              CALL    CHPUT               ; Home Cursor
E008    AF                  XOR     A                   ; A=KBD row
E009    F5          MX2:    PUSH    AF                  ;
E00A    CD4101              CALL    SNSMAT              ; Read a row
E00D    0608                LD      B,6                 ; Eight cols
E00F    07          MX3:    RLCA                        ; Select col
E010    F5                  PUSH    AF                  ;
E011    E601                AND     1                   ;
E013    C630                ADD     A,"0"               ; Result
E015    CDA200              CALL    CHPUT               ; Display col
E018    F1                  POP     AF                  ;
E019    10F4                DJNZ    MX3                 ;
E01B    3E0D                LD      A,CR                ; Newline
E01D    CDA200              CALL    CHPUT               ;
E020    3E0A                LD      A,LF                ;
E022    CDA200              CALL    CHPUT               ;
E025    F1                  POP     AF                  ; A=KBD row
E026    3C                  INC     A                   ; Next row
E027    FE0B                CP      11                  ; Finished?
E029    20DE                JR      NZ,MX2              ;
E02B    CDB700              CALL    BREAKX              ; CTRL-STOP
E02E    30D3                JR      NC,MX1              ; Continue
E030    AF                  XOR     A                   ;
E031    329BFC              LD      (INTFLG),A          ; Clear possible STOP
E034    C9                  RET                         ; Back to BASIC

                            END
```

<a name="40_column_graphics_text"></a>

## 40列のグラフィックテキスト

このプログラムは、[グラフィックスモード](#graphics_mode) 画面に1行40文字のテキストを出力します。表示する文字列は `USR` 呼び出しパラメータとして渡されます（例：`A$=USR("something")`）。事前にGRPファイルを開く必要はありません。プログラムを実行するために必要なのは、画面が正しいモードになっていることだけです。プログラムの核心部分は機能的には [GRPPRT](#grpprt) 標準ルーチンと同等ですが、指定された文字パターンの最初の8ドット列ではなく6ドット列のみが画面に表示されます。[GRPPRT](#grpprt) と同様に、パターンは現在のグラフィックス位置に配置され、認識される制御文字は ASCII CR (13) のみで、これはCRとLFの組み合わせとして機能します。[GRPPRT](#grpprt) 標準ルーチンとは異なり、負の座標に印刷され、画面に重なる文字も正しく表示されます。このプログラムは現在、ドットカラム239の後に自動改行を行うように設定されており、1行あたり40文字分となります。必要に応じて、RMDCOLサブルーチン内の定数を使用してこの設定を変更し、画面の全幅を利用できるようになります。

```
                            ORG     0E000H
                            LOAD    0E000H

                    ; ******************************
                    ; *   BIOS STANDARD ROUTINES   *
                    ; ******************************

                    RDSLT:  EQU     000CH
                    CNVCHR: EQU     00ABH
                    MAPXYC: EQU     0111H
                    SETC:   EQU     0120H

                    ; ******************************
                    ; *     WORKSPACE VARIABLES    *
                    ; ******************************

                    FORCLR: EQU     0F3E9H
                    ATRBYT: EQU     0F3F2H
                    CGPNT:  EQU     0F91FH
                    PATWRK: EQU     0FC40H
                    SCRMOD: EQU     0FCAFH
                    GRPACX: EQU     0FCB7H
                    GRPACY: EQU     0FCB9H

                    ; ******************************
                    ; *      CONTROL CHARACTERS    *
                    ; ******************************

                    CR:     EQU     13

E000    FE03        GFORTY: CP      3                   ; String type?
E002    C0                  RET     NZ                  ;
E003    3AAFFC              LD      A,(SCRMOD)          ; Mode
E006    FE02                CP      2                   ; Graphics?
E008    C0                  RET     NZ                  ;
E009    EB                  EX      DE,HL               ; HL->Descriptor
E00A    46                  LD      B,(HL)              ; B=String len
E00B    23                  INC     HL                  ;
E00C    5E                  LD      E,(HL)              ; Address LSB
E00D    23                  INC     HL                  ;
E00E    56                  LD      D,(HL)              ; DE->String
E00F    04                  INC     B                   ;
E010    05          GF2:    DEC     B                   ; Finished?
E011    C8                  RET     Z                   ;
E012    1A                  LD      A,(DE)              ; A=Chr from string
E013    CD19E0              CALL    GPRINT              ; Print it
E016    13                  INC     DE                  ;
E017    18F7                JR      GF2                 ; Next chr
E019    F5          GPRINT: PUSH    AF                  ;
E01A    C5                  PUSH    BC                  ;
E01B    D5                  PUSH    DE                  ;
E01C    E5                  PUSH    HL                  ;
E01D    FDE5                PUSH    IY                  ;
E01F    ED4BB7FC            LD      BC,(GRPACX)         ; BC=X coord
E023    ED5BB9FC            LD      DE,(GRPACY)         ; DE=Y coord
E027    CD39E0              CALL    GDC                 ; Decode chr
E02A    ED43B7FC            LD      (GRPACX),BC         ; New X coord
E02E    ED53B9FC            LD      (GRPACY),DE         ; New Y coord
E032    FDE1                POP     IY                  ;
E034    E1                  POP     HL                  ;
E035    D1                  POP     DE                  ;
E036    C1                  POP     BC                  ;
E037    F1                  POP     AF                  ;
E038    C9                  RET                         ;

E039    CDAB00      GDC:    CALL    CNVCHR              ; Check graphic
E03C    D0                  RET     NC                  ; NC=Header
E03D    2007                JR      NZ,GD2              ; NZ=Converted
E03F    FE0D                CP      CR                  ; Carriage Return?
E041    2873                JR      Z,GCRLF             ;
E043    FE20                CP      20H                 ; Other control?
E045    D8                  RET     C                   ; Ignore
E046    6F          GD2:    LD      L,A                 ;
E047    2600                LD      H,0                 ; HL=Chr code
E049    29                  ADD     HL,HL               ;
E04A    29                  ADD     HL,HL               ;
E04B    29                  ADD     HL,HL               ; HL=Chr*8
E04C    C5                  PUSH    BC                  ; X coord
E04D    D5                  PUSH    DE                  ; Y coord
E04E    ED5B20F9            LD      DE,(CGPNT+1)        ; Character set
E052    19                  ADD     HL,DE               ; HL->Pattern
E053    1140FC              LD      DE,PATWRK           ; DE->Buffer
E056    0608                LD      B,8                 ; Eight byte pattern
E058    C5          GD3:    PUSH    BC                  ;
E059    D5                  PUSH    DE                  ;
E05A    3A1FF9              LD      A,(CGPNT)           ; Slot ID
E05D    CD0C00              CALL    RDSLT               ; Get pattern
E060    FB                  EI                          ;
E061    D1                  POP     DE                  ;
E062    C1                  POP     BC                  ;
E063    12                  LD      (DE),A              ; Put in buffer
E064    13                  INC     DE                  ;
E065    23                  INC     HL                  ;
E066    10F0                DJNZ    GD3                 ; Next
E068    D1                  POP     DE                  ;
E069    C1                  POP     BC                  ;
E06A    3AE9F3              LD      A,(FORCLR)          ; Current colour
E06D    32F2F3              LS      (ATRBYT),A          ; Set ink
E070    FD2140FC            LD      IY,PATWRK           ; IY->Patterns
E074    D5                  PUSH    DE                  ;
E075    2608                LD      H,8                 ; Max dot rows
E077    CB7A        GD4:    BIT     7,D                 ; Pos Y coord?
E079    202A                JR      NZ,GD8              ;
E07B    CDBFE0              CALL    BMDROW              ; Bottom most row?
E07E    382B                JR      C,GD9               ; C=Y too large
E080    C5                  PUSH    BC                  ;
E081    2E06                LD      L,6                 ; Max dot cols
E083    FD7E00              LD      A,(IY+0)            ; A=Pattern row
E086    CB78        GD5:    BIT     7,B                 ; Pos X coord
E088    2015                JR      NZ,GD6              ;
E08A    CDC8E0              CALL    RMDCOL              ; Rightmost col?
E08D    3815                JR      C,GD7               ; C=X too large
E08F    CB7F                BIT     7,A                 ; Pattern bit
E091    280C                JR      Z,GD6               ; Z=0 Pixel
E093    F5                  PUSH    AF                  ;
E094    D5                  PUSH    DE                  ;
E095    E5                  PUSH    HL                  ;
E096    CD1101              CALL    MAPXYC              ; Map coords
E099    CD2001              CALL    SETC                ; Set pixel
E09C    E1                  POP     HL                  ;
E09D    D1                  POP     DE                  ;
E09E    F1                  POP     AF                  ;
E09F    07          GD6:    RLCA                        ; Shift pattern
E0A0    03                  INC     BC                  ; X=X+1
E0A1    2D                  DEC     L                   ; Finished dot cols?
E0A2    20E2                JR      NZ,GD5              ;
E0A4    C1          GD7:    POP     BC                  ; Initial X coord
E0A5    FD23        GD8:    INC     IY                  ; Next pattern byte
E0A7    13                  INC     DE                  ; Y=Y+1
E0A8    25                  DEC     H                   ; Finished dot rows?
E0A9    20CC                JR      NZ,GD4              ;
E0AB    D1          GD9:    POP     DE                  ; Initial Y coord
E0AC    210600              LD      HL,6                ; Step
E0AF    09                  ADD     HL,BC               ; X=X+6
E0B0    44                  LD      B,H                 ;
E0B1    4D                  LD      C,L                 ; BC=New X coord
E0B2    CDC8E0              CALL    RMDCOL              ; Rightmost col?
E0B5    D0                  RET     NC                  ;

E0B6    010000      GCRLF:  LD      BC,0                ; X=0
E0B9    210800              LD      HL,8                ;
E0BC    19                  ADD     HL,DE               ;
E0BD    EB                  EX      DE,HL               ; Y=Y+8
E0BE    C9                  RET                         ;

E0BF    E5          BMDROW: PUSH    HL                  ;
E0C0    21BF00              LD      HL,191              ; Bottom dot row
E0C3    B7                  OR      A                   ;
E0C4    ED52                SBC     HL,DE               ; Check Y coord
E0C6    E1                  POP     HL                  ;
E0C7    C9                  RET                         ; C=Below screen

E0C8    E5          RMDCOL: PUSH    HL                  ;
E0C9    21EF00              LD      HL,239              ; Rightmost dot col
E0CC    B7                  OR      A                   ;
E0CD    ED42                SBC     HL,BC               ; Check X coord
E0CF    E1                  POP     HL                  ;
E0D0    C9                  RET                         ; C=Beyond right

                            END
```

<a name="string_bubble_sort"></a>

## 文字列バブルソート

このプログラムは、文字列配列の内容をアルファベットの昇順でソートします。配列の位置は`USR`呼び出しパラメータとして渡されます（例：`V=USR(VARPRT(A$(0)))`）。配列のサイズや内容に制限はありませんが、1次元である必要があります。このプログラムは、文字列のペアを比較し、2番目の文字列が1番目の文字列より小さい場合は位置を入れ替える、古典的なバブルソートアルゴリズムに基づいています。ランダムに生成された文字列の250要素配列は約2.5秒でソートされます。同等のBASICプログラムを実行するには6分以上かかります。

```
                            ORG     0E000H
                            LOAD    0E000H

E000    FE02        SORT:   CP      2                   ; Integer type?
E002    C0                  RET     NZ                  ;
E003    23                  INC     HL                  ; HL->DAC+1
E004    23                  INC     HL                  ; HL->DAC+2
E005    5E                  LD      E,(HL)              ; Address LSB
E006    23                  INC     HL                  ; HL->DAC+3
E007    56                  LD      D,(HL)              ; Address MSB
E008    EB                  EX      DE,HL               ; HL->A$(0)
E009    E5                  PUSH    HL                  ;
E00A    DDE1                POP     IX                  ; IX->A$(0)
E00C    DD7EF8              LD      A,(IX-8)            ; Array type
E00F    FE03                CP      3                   ; String Array?
E011    C0                  RET     NZ                  ;
E012    DD7EFD              LD      A,(IX-3)            ; Dimension
E015    3D                  DEC     A                   ; Single dimension?
E016    C0                  RET     NZ                  ;
E017    DD4EFE              LD      C,(IX-2)            ;
E01A    DD46FF              LD      B,(IX-1)            ; BC=Element count
E01D    C5          SR2:    PUSH    BC                  ;
E01E    E5                  PUSH    HL                  ; HL->Dsc(N)
E01F    46          SR3:    LD      B,(HL)              ; B=Len(N)
E020    23                  INC     HL                  ;
E021    5E                  LD      E,(HL)              ;
E022    23                  INC     HL                  ;
E023    E5                  PUSH    HL                  ;
E024    56                  LD      D,(HL)              ; DE->String(N)
E025    23                  INC     HL                  ; HL->Dsc(N+1)
E026    4E                  LD      C,(HL)              ; C=Len(N+1)
E027    23                  INC     HL                  ;
E028    7E                  LD      A,(HL)              ;
E029    23                  INC     HL                  ;
E02A    E5                  PUSH    HL                  ;
E02B    66                  LD      H,(HL)              ;
E02C    6F                  LD      L,A                 ; HL->String(N+1)
E02D    EB                  EX      DE,HL               ; HL->(N),DE->(N+1)
E02E    04                  INC     B                   ;
E02F    0C                  INC     C                   ;
E030    05          SR4:    DEC     B                   ; Remaining len(N)
E031    2B25                JR      Z,NEXT              ; Z=(N)<=(N+1)
E033    0D                  DEC     C                   ; Remaining len(N+1)
E034    2808                JR      Z,SWAP              ; Z=(N+1)<(N)
E036    1A                  LD      A,(DE)              ; Chr from (N+1)
E037    BE                  CP      (HL)                ; Chr from (N)
E038    13                  INC     DE                  ;
E039    23                  INC     HL                  ;
E03A    28F4                JR      Z,SR4               ; Same, continue
E03C    301A                JR      NC,NEXT             ; NC=(N)<(N+1)
E03E    E1          SWAP:   POP     HL                  ; HL->Dsc(N+1)
E03F    D1                  POP     DE                  ; DE->Dsc(N)
E040    0603                LD      B,3                 ; Descriptor size
E042    1A          SW2:    LD      A,(DE)              ; Swap descriptors
E043    4E                  LD      C,(HL)              ;
E044    77                  LD      (HL),A              ;
E045    79                  LD      A,C                 ;
E046    12                  LD      (DE),A              ;
E047    1B                  DEC     DE                  ;
E048    2B                  DEC     HL                  ;
E049    10F7                DJNZ    SW2                 ;
E04B    DDE5                PUSH    IX                  ;
E04D    E1                  POP     HL                  ; HL->A$(0)
E04E    B7                  OR      A                   ;
E04F    ED52                SBC     HL,DE               ; At Array start?
E051    3007                JR      NC,NX2              ; NC=At start
E053    1B                  DEC     DE                  ; Back up
E054    1B                  DEC     DE                  ;
E055    EB                  EX      DE,HL               ; HL->Dsc(N-1_
E056    18C7                JR      SR3                 ; Go check again
E058    E1          NEXT:   POP     HL                  ; Lose junk
E059    E1                  POP     HL                  ;
E05A    E1          NX2:    POP     HL                  ; HL->Dsc(N)
E05B    C1                  POP     BC                  ; BC=Element count
E05C    23                  INC     HL                  ; Next descriptor
E05D    23                  INC     HL                  ;
E05E    23                  INC     HL                  ;
E05F    0B                  DEC     BC                  ;
E060    78                  LD      A,B                 ;
E061    B1                  OR      C                   ; Finished?
E062    20B9                JR      NZ,SR2              ;
E064    C9                  RET                         ;

                            END
```

<a name="graphics_screen_dump"></a>

## グラフィック画面ダンプ

このプログラムは、どのモードでも画面の内容をプリンタに出力します。`USR` 呼び出しで最初に起動されると、プログラムは割り込みハンドラのキースキャンフックに自身をパッチするだけです。

プログラムがインストールされると、実質的に割り込みハンドラの拡張機能となり、システムのどこからでもESCキーを押すだけで画面ダンプを開始できます。必要に応じて、CTRLキーとSTOPキーを押してダンプを終了できます。32個のスプライトすべてがアクティブな[グラフィックモード](#graphics_mode)画面の例を以下に示します。

画面ダンプを生成する最も簡単な方法は、ネームテーブルからすべての文字コードをプリンタにコピーすることです。ただし、この方法は2つのテキストモードでのみ機能し、スプライトは表示できず、結果はVDP文字セットではなくプリンタの内部文字セットを反映します。そのため、プログラムはすべてのモードで画面を240/256x192ビットの画像としてプリンタに再現します。画像内の各点は、画面上の対応する点のカラーコードから派生します。0から7の色にはドットがなく、8から15の色にはドットがあります。

与えられた点のカラーコードは、まず32個のスプライトを順番に調べ、その点と重なるスプライトがあるかどうかを調べることで取得されます。その点においてすべてのスプライトが透明であれば、文字プレーンを調べます。これは、点の座標を用いて名前テーブル内の対応するエントリを見つけ、文字コードを用いて、関連するパターン内の関連ビットを分離することで行われます。ビットのカラーコードが透明であると判断された場合、背景プレーンの色が返されます。

プログラムで使用されている制御コードシーケンスは、Epson FX80プリンタのものです。他のプリンタを使用する場合に備えて、リストにこれらのシーケンスを記載しています。1つのシーケンスは、240/256バイトの行（各バイトは垂直方向の8ドットを定義）の先頭でビットイメージモードに入るために使用され、もう1つのシーケンスは行の末尾で用紙送りを開始するために使用されます。このプログラムは、コードサイズを最小化することよりも速度を重視して最適化されており、イメージ内の46,080/49,152ドットを生成するのに約5秒とプリンタの稼働時間が必要です。

```
                            ORG     0E000H
                            LOAD    0E000H

                    ; ******************************
                    ; *   BIOS STANDARD ROUTINES   *
                    ; ******************************

                    RDVRM:  EQU     004AH
                    CALATR: EQU     0087H
                    LPTOUT: EQU     00A5H

                    ; ******************************
                    ; *     WORKSPACE VARIABLES    *
                    ; ******************************

                    T32COL: EQU     0F3BFH
                    GRPNAM: EQU     0F3C7H
                    GRPCOL: EQU     0F3C9H
                    GRPCGP: EQU     0F3CBH
                    MLTNAM: EQU     0F3D1H
                    MLTCGP: EQU     0F3D5H
                    RG1SAV: EQU     0F3E0H
                    RG7SAV: EQU     0F3E6H
                    NAMBAS: EQU     0F922H
                    CGPBAS: EQU     0F924H
                    PATBAS: EQU     0F926H
                    ATRBAS: EQU     0F928H
                    SCRMOD: EQU     0FCAFH
                    HKEYC:  EQU     0FDCCH

                    ; ******************************
                    ; *      CONTROL CHARACTERS    *
                    ; ******************************

                    CR:     EQU     13
                    ESC:    EQU     27

E000    3ACCFD      ENTRY:  LD      A,(HKEYC)           ; Hook
E003    FEC9                CP      0C9H                ; Free to use?
E005    C0                  RET     NZ                  ;
E006    2112E0              LD      HL,DUMP             ; Where to go
E009    22CDFD              LD      (HKEYC+1),HL        ; Redirect hook
E00C    3ECD                LD      A,0CDH              ; CALL
E00E    32CCFD              LD      (HKEYC),A           ;
E011    C9                  RET                         ;

E012    FE3A        DUMP:   CP      3AH                 ; ESC key number?
E014    C0                  RET     NZ                  ;
E015    F5                  PUSH    AF                  ;
E016    C5                  PUSH    BC                  ;
E017    D5                  PUSH    DE                  ;
E018    E5                  PUSH    HL                  ;
E019    ED734FE2            LD      (BRKSTK),SP         ; For CTRL-STOP
E01D    0E00                LD      C,0                 ; C=Row
E01F    3AAFFC      DU1:    LD      A,(SCRMOD)          ; Mode
E022    B7                  OR      A                   ;
E023    21F000              LD      HL,240              ; T40 Dots per row
E026    112B06              LD      DE,6*256+40         ;
E029    2806                JR      Z,DU2               ;
E02B    210001              LD      HL,256              ; T32,GRP,MLT Dots
E02E    112008              LD      DE,8*256+32         ;
E031    3E1B        DU2:    LD      A,ESC               ; ***** FX80 *****
E033    CD8DE0              CALL    PRINT               ; *              *
E036    3E4B                LD      A,"K"               ; *   Bit mode   *
E038    CD8DE0              CALL    PRINT               ; *              *
E03B    7D                  LD      A,L                 ; *  Bytes  LSB  *
E03C    CD8DE0              CALL    PRINT               ; *              *
E03F    7C                  LD      A,H                 ; *  Bytes  MSB  *
E040    CD8DE0              CALL    PRINT               ; ****************
E043    0600                LD      B,0                 ; B=Column
E045    CD97E0      DU3:    CALL    CELL                ; Do an 8x8 cell
E048    D5                  PUSH    DE                  ;
E049    C5                  PUSH    BC                  ;
E04A    2151E2              LD      HL,CBUFF            ; HL->Colours
E04D    42                  LD      B,D                 ; B=Dot cols (6 or 8)
E04E    110800              LD      DE,8                ; CBUFF offset
E051    C5          DU4:    PUSH    BC                  ;
E052    E5                  PUSH    HL                  ;
E053    0608                LD      B,8                 ; B=Dot rows
E055    7E          DU5:    LD      A,(HL)              ; A=Colour code
E056    FE08                CP      8                   ; Dark or light?
E058    3F                  CCF                         ; Light=Print dot
E059    CB11                RL      C                   ; Build result
E05B    19                  ADD     HL,DE               ; Next dot row
E05C    10F7                DJNZ    DU5                 ;
E05E    79                  LD      A,C                 ; 8 Vertical dots
E05F    CD8DE0              CALL    PRINT               ;
E062    E1                  POP     HL                  ;
E063    C1                  POP     BC                  ;
E064    23                  INC     HL                  ; Next dot col
E065    10EA                DJNZ    DU4                 ;
E067    C1                  POP     BC                  ;
E068    D1                  POP     DE                  ;
E069    04                  INC     B                   ; Next column
E06A    78                  LD      A,B                 ;
E06B    BB                  CP      E                   ; End of row?
E06C    20D7                JR      NZ,DU3              ;
E06E    3E0D                LD      A,CR                ; Head left
E070    CD8DE0              CALL    PRINT               ;
E073    3E1B                LD      A,ESC               ; ***** FX80 *****
E075    CD8DE0              CALL    PRINT               ; *              *
E078    3E4A                LD      A,"J"               ; *  Paper feed  *
E07A    CD8DE0              CALL    PRINT               ; *              *
E07D    3E18                LD      A,24                ; * 24/216= 1/9" *
E07F    CD8DE0              CALL    PRINT               ; ****************
E082    0C                  INC     C                   ; Next row
E083    79                  LD      A,C                 ;
E084    FE18                CP      24                  ; Finished screen?
E086    2097                JR      NZ,DU1              ;
E088    E1          DU6:    POP     HL                  ;
E089    D1                  POP     DE                  ;
E08A    C1                  POP     BC                  ;
E08B    F1                  POP     AF                  ;
E08C    C9                  RET                         ;

E08D    CDA500      PRINT:  CALL    LPTOUT              ; To printer
E090    D0                  RET     NC                  ; CTRL-STOP?
E091    ED7B4FE2            LD      SP,(BRKSTK)         ; Restore stack
E095    18F1                JR      DU6                 ; Terminate program

E097    C5          CELL:   PUSH    BC                  ;
E098    D5                  PUSH    DE                  ;
E099    E5                  PUSH    HL                  ;
E09A    FDE5                PUSH    IY                  ;
E09C    2151E2              LD      HL,CBUFF            ; For results
E09F    3E40                LD      A,64                ;
E0A1    3600        CL1:    LD      (HL),0              ; Transparent
E0A3    23                  INC     HL                  ;
E0A4    3D                  DEC     A                   ; Fill
E0A5    20FA                JR      NZ,CL1              ;
E0A7    3AAFFC              LD      A,(SCRMOD)          ; Mode
E0AA    B7                  OR      A                   ; T40?
E0AB    F5                  PUSH    AF                  ;
E0AC    C5                  PUSH    BC                  ;
E0AD    C469E1              CALL    NZ,SPRTES           ; Sprites first
E0B0    C1                  POP     BC                  ;
E0B1    69                  LD      L,C                 ;
E0B2    2600                LD      H,0                 ; HL=Row
E0B4    29                  ADD     HL,HL               ;
E0B5    29                  ADD     HL,HL               ;
E0B6    29                  ADD     HL,HL               ; HL=Row*8
E0B7    5D                  LD      E,L                 ;
E0B8    54                  LD      D,H                 ; DE=Row*8
E0B9    29                  ADD     HL,HL               ;
E0BA    29                  ADD     HL,HL               ; HL=Row*32
E0BB    F1                  POP     AF                  ; Mode
E0BC    F5                  PUSH    AF                  ;
E0BD    2001                JR      NZ,CL2              ; T40?
E0BF    19                  ADD     HL,DE               ; HL=Row*40
E0C0    58          CL2:    LD      E,B                 ; DE=Column
E0C1    19                  ADD     HL,DE               ;
E0C2    EB                  EX      DE,HL               ; DE=NAMTAB offset
E0C3    D602                SUB     2                   ; Mode
E0C5    79                  LD      A,C                 ; A=Row
E0C6    010000              LD      BC,0                ; BC=CGPTAB offset
E0C9    2A24F9              LD      HL,(CGPBAS)         ;
E0CC    E5                  PUSH    HL                  ;
E0CD    2A22F9              LD      HL,(NAMBAS)         ;
E0D0    3819                JR      C,CL4               ; C=T40 or T32
E0D2    200C                JR      NZ,CL3              ; NZ=MLT
E0D4    2ACBF3              LD      HL,(GRPCGP)         ; Else GRP
E0D7    E3                  EX      (SP),HL             ;
E0D8    2AC7F3              LD      HL,(GRPNAM)         ;
E0DB    E618                AND     18H                 ; Row MSBs
E0DD    47                  LD      B,A                 ; 1/3=2kB CGP offset
E0DE    180B                JR      CL4                 ;
E0E0    2AD5F3      CL3:    LD      HL,(MLTCGP)         ;
E0E3    E3                  EX      (SP),HL             ;
E0E4    2AD1F3              LD      HL,(MLTNAM)         ;
E0E7    07                  RLCA                        ; Row*2
E0E8    E606                AND     6                   ;
E0EA    4F                  LD      C,A                 ; 1/6=2B CGP offset
E0EB    19          CL4:    ADD     HL,DE               ; HL->NAMTAB
E0EC    CD4A00              CALL    RDVRM               ; Get chr code
E0EF    6F                  LD      L,A                 ;
E0F0    2600                LD      H,0                 ; HL=Chr code
E0F2    29                  ADD     HL,HL               ;
E0F3    29                  ADD     HL,HL               ;
E0F4    29                  ADD     HL,HL               ; HL=Chr*8
E0F5    09                  ADD     HL,BC               ; GRP,MLT offsets
E0F6    EB                  EX      DE,HL               ; DE=CGPTAB offset
E0F7    FDE1                POP     IY                  ; IY=CGPTAB base
E0F9    FD19                ADD     IY,DE               ; IY->Pattern
E0FB    2AC9F3              LD      HL,(GRPCOL)         ;
E0FE    19                  ADD     HL,DE               ; HL->GRP colours
E0FF    0F                  RRCA                        ;
E100    0F                  RRCA                        ;
E101    0F                  RRCA                        ; Chr code/8
E102    E61F                AND     1FH                 ;
E104    4F                  LD      C,A                 ;
E105    0600                LD      B,0                 ;
E107    3AE6F3              LD      A,(RG7SAV)          ; T40 Colours
E10A    57                  LD      D,A                 ; D=T40 Colours
E10B    E60F                AND     0FH                 ;
E10D    5F                  LD      E,A                 ; E=Background colour
E10E    F1                  POP     AF                  ; Mode
E10F    E5                  PUSH    HL                  ; STK->GRP Colours
E110    3D                  DEC     A                   ;
E111    2008                JR      NZ,CL5              ; Z=T32
E113    2ABFF3              LD      HL,(T32COL)         ;
E116    09                  ADD     HL,BC               ; HL->T32 Colours
E117    CD4A00              CALL    RDVRM               ; Get T32 Colours
E11A    57                  LD      D,A                 ; D=T32 Colours
E11B    2151E2      CL5:    LD      HL,CBUFF            ; Results
E11E    0608                LD      B,8                 ; Dot rows
E120    FDE5        CL6:    PUSH    IY                  ;
E122    E3                  EX      (SP),HL             ; HL->Pattern
E123    CD4A00              CALL    RDVRM               ; Get pattern
E126    4F                  LD      C,A                 ; C=Pattern
E127    E1                  POP     HL                  ;
E128    FD23                INC     IY                  ; Next dot row
E12A    3AAFFC              LD      A,(SCRMOD)          ; Mode
E12D    D602                SUB     2                   ;
E12F    3815                JR      C,CL8               ; C=T40 or T32
E131    280C                JR      Z,CL7               ; Z=GRP
E133    51                  LD      D,C                 ; MLT Colours=Pattern
E134    0EF0                LD      C,0F0H              ; Dummy MLT pattern
E136    78                  LD      A,B                 ; Dot row
E137    FE05                CP      5                   ; Cell halfway mark?
E139    280B                JR      Z,CL8               ;
E13B    FD2B                DEC     IY                  ; Back up pattern
E13D    1807                JR      CL8                 ;
E13F    E3          CL7:    EX      (SP),HL             ; HL->GRP Colours
E140    CD4A00              CALL    RDVRM               ; Get colours
E143    57                  LD      D,A                 ; D=GRP Colours
E144    23                  INC     HL                  ; Next dot row
E145    E3                  EX      (SP),HL             ; STK->GRP Colours
E146    C5          CL8:    PUSH    BC                  ;
E147    0608                LD      B,8                 ; Dot cols
E149    CB11        CL9:    RL      C                   ; Dot from pattern
E14B    34                  INC     (HL)                ;
E14C    35                  DEC     (HL)                ; Check CBUFF clear
E14D    200D                JR      NZ,CL12             ; NZ=Sprite above
E14F    7A                  LD      A,D                 ; A=Colours
E150    3004                JR      NC,CL10             ; NC=0 Pixel
E152    0F                  RRCA                        ;
E153    0F                  RRCA                        ;
E154    0F                  RRCA                        ;
E155    0F                  RRCA                        ; Select 1 colour
E156    E60F        CL10:   AND     0FH                 ;
E158    2001                JR      NZ,CL11             ; Z=Transparent
E15A    7B                  LD      A,E                 ; Use background
E15B    77          CL11:   LD      (HL),A              ; Colour in CBUFF
E15C    23          CL12:   INC     HL                  ;
E15D    10EA                DJNZ    CL9                 ; Next dot col
E15F    C1                  POP     BC                  ;
E160    10BE                DJNZ    CL6                 ; Next dot row
E162    E1                  POP     HL                  ;
E163    FDE1                POP     IY                  ;
E165    E1                  POP     HL                  ;
E166    D1                  POP     DE                  ;
E167    C1                  POP     BC                  ;
E168    C9                  RET                         ;

E169    78          SPRTES: LD      A,B                 ; A=Column
E16A    07                  RLCA                        ;
E16B    07                  RLCA                        ;
E16C    07                  RLCA                        ; A=X coord
E16D    C607                ADD     A,7                 ; RH edge of cell
E16F    47                  LD      B,A                 ; B=X coord
E170    79                  LD      A,C                 ; A=Row
E171    07                  RLCA                        ;
E172    07                  RLCA                        ;
E173    07                  RLCA                        ; A=Y coord
E174    C607                ADD     A,7                 ; Bottom of cell
E176    4F                  LD      C,A                 ; C=Y coord
E177    AF                  XOR     A                   ; Sprite number
E178    CD8700      SS1:    CALL    CALATR              ; HL->Attributes
E17B    57                  LD      D,A                 ; D=Sprite number
E17C    CD4A00              CALL    RDVRM               ; Get Sprite Y
E17F    FED0                CP      208                 ; Terminator?
E181    C8                  RET     Z                   ;
E182    D5                  PUSH    DE                  ;
E183    C5                  PUSH    BC                  ;
E184    CD8FE1              CALL    SPRITE              ; Do a sprite
E187    C1                  POP     BC                  ;
E188    F1                  POP     AF                  ;
E189    3C                  INC     A                   ; Next sprite number
E18A    FE20                CP      32                  ; Done all?
E18C    20EA                JR      NZ,SS1              ;
E18E    C9                  RET                         ;

E18F    91          SPRITE: SUB     C                   ; (SY-Y)
E190    2F                  CPL                         ; Make (Y-SY)
E191    FE27                CP      39                  ; Possible overlap?
E193    D0                  RET     NC                  ;
E194    4F                  LD      C,A                 ; C=(Y-SY)
E195    23                  INC     HL                  ;
E196    CD4A00              CALL    RDVRM               ; Get Sprite X
E199    5F                  LD      E,A                 ;
E19A    78                  LD      A,B                 ; A=X coord
E19B    93                  SUB     E                   ;
E19C    5F                  LD      E,A                 ; E=(X-SX)
E19D    9F                  SBC     A,A                 ; Make 16 bit
E19E    57                  LD      D,A                 ; DE=(X-SX)
E19F    23                  INC     HL                  ;
E1A0    CD4A00              CALL    RDVRM               ; Get pattern#
E1A3    47                  LD      B,A                 ;
E1A4    23                  INC     HL                  ;
E1A5    CD4A00              CALL    RDVRM               ; Get EC & Colour
E1A8    CB7F                BIT     7,A                 ; Early clock?
E1AA    2805                JR      Z,SP1               ;
E1AC    212000              LD      HL,32               ;
E1AF    19                  ADD     HL,DE               ; Increase (X-SX)
E1B0    EB                  EX      DE,HL               ;
E1B1    14          SP1:    INC     D                   ;
E1B2    15                  DEC     D                   ; (X-SX)>255 or neg?
E1B3    C0                  RET     NZ                  ; NZ-Outside cell
E1B4    E60F                AND     0FH                 ; Colour
E1B6    C8                  RET     Z                   ; Z=Transparent
E1B7    57                  LD      D,A                 ; D=Colour
E1B8    3AE0F3              LD      A,(RG1SAV)          ; Flags
E1BB    DB4F                BIT     1,A                 ; SIZE
E1BD    0F                  RRCA                        ; MAG
E1BE    3E08                LD      A,8                 ; Minimum size
E1C0    3001                JR      NC,SP2              ;
E1C2    87                  ADD     A,A                 ; Double for MAG
E1C3    2800        SP2:    JR      Z,SP3               ;
E1C5    CB80                RES     0,B                 ; Change pattern#
E1C7    CB88                RES     1,B                 ;
E1C9    87                  ADD     A,A                 ; Double for SIZE
E1CA    6F          SP3:    LD      L,A                 ; L=Sprite size
E1CB    C606                ADD     A,6                 ; Allow cell size
E1CD    B9                  CP      C                   ;
E1CE    D8                  RET     C                   ; Sprite above
E1CF    BB                  CP      E                   ;
E1D0    D8                  RET     C                   ; Sprite to left
E1D1    79                  LD      A,C                 ;
E1D2    D607                SUB     7                   ; (Y-SY) from top
E1D4    4F                  LD      C,A                 ;
E1D5    7D                  LD      A,L                 ; A=Sprite size
E1D6    2608                LD      H,8                 ; Max dot rows
E1D8    3800                JR      C,SP5               ; C=Below cell top
E1DA    91                  SUB     C                   ; A=Dot row overlap
E1DB    FE09                CP      9                   ;
E1DD    3802                JR      C,SP4               ;
E1DF    3E08                LD      A,8                 ;
E1E1    67          SP4:    LD      H,A                 ; H=Row overlap
E1E2    7B          SP5:    LD      A,E                 ;
E1E3    D607                SUB     7                   ; (X-SX) from cell LH
E1E5    5F                  LD      E,A                 ;
E1E6    7D                  LD      A,L                 ; A=Sprite size
E1E7    2E08                LD      L,8                 ; Max dot cols
E1E9    3808                JR      C,SP7               ; C=Past cell LH
E1EB    93                  SUB     E                   ; A=Dot col overlap
E1EC    FE09                CP      9                   ;
E1EE    3802                JR      C,SP6               ;
E1F0    3E08                LD      A,8                 ;
E1F2    6F          SP6:    LD      L,A                 ; L=Col overlap
E1F3    FD2151E2    SP7:    LD      IY,CBUFF            ; Results
E1F7    D5          SP8:    PUSH    DE                  ;
E1F8    CB79                BIT     7,C                 ; Reached sprite?
E1FA    2048                JR      NZ,SP15             ;
E1FC    E5                  PUSH    HL                  ;
E1FD    FDE5                PUSH    IY                  ;
E1FF    CB7B        SP9:    BIT     7,E                 ; Reached sprite?
E201    2038                JR      NZ,SP14             ;
E203    FD7E00              LD      A,(IY+0)            ; CBUFF
E206    B7                  OR      A                   ; Transparent?
E207    2032                JR      NZ,SP14             ;
E209    C5                  PUSH    BC                  ;
E20A    D5                  PUSH    DE                  ;
E20B    E5                  PUSH    HL                  ;
E20C    3AE0F3              LD      A,(RG1SAV)          ; Flags
E10F    0F                  RRCA                        ; MAG
E210    3004                JR      NC,SP10             ;
E212    CB39                SRL     C                   ; (Y-SY)/2
E214    CB3B                SRL     E                   ; (X-SX)/2
E216    CB5B        SP10:   BIT     3,E                 ; (X-SX)>7?
E218    2804                JR      Z,SP11              ;
E21A    CB9B                RES     3,E                 ; (X-SX)-8
E21C    CBE1                SET     4,C                 ; (Y-SY)+16
E21E    68          SP11:   LD      L,B                 ;
E21F    2600                LD      H,0                 ; HL=Pattern#
E221    44                  LD      B,H                 ; BC=Y offset
E222    29                  ADD     HL,HL               ;
E223    29                  ADD     HL,HL               ;
E224    29                  ADD     HL,HL               ; HL=Pattern*8
E225    09                  ADD     HL,BC               ; Select dot row
E226    ED4B26F9            LD      BC,(PATBAS)         ;
E22A    09                  ADD     HL,BC               ; HL->Pattern
E22B    CD4A00              CALL    RDVRM               ; Get dot row
E22E    1C                  INC     E                   ;
E22F    07          SP12:   RLCA                        ; Select dot col
E230    1D                  DEC     E                   ;
E231    20FC                JR      NZ,SP12             ;
E233    3003                JR      NC,SP13             ; NC=0 Pixel
E235    FD7200              LD      (IY+0),D            ; Colour in CBUFF
E238    E1          SP13:   POP     HL                  ;
E239    D1                  POP     DE                  ;
E23A    C1                  POP     BC                  ;
E23B    FD23        SP14:   INC     IY                  ;
E23D    1C                  INC     E                   ; Right a dot col
E23E    2D                  DEC     L                   ; Finished cols?
E23F    20BE                JR      NZ,SP9              ;
E241    FDE1                POP     IY                  ;
E243    E1                  POP     HL                  ;
E244    110800      SP15:   LD      DE,8                ;
E247    FD19                ADD     IY,DE               ;
E249    D1                  POP     DE                  ;
E24A    0C                  INC     C                   ; Down a dot row
E24B    25                  DEC     H                   ; Finished?
E24C    20A9                JR      NZ,SP8              ;
E24E    C9                  RET                         ;

E24F    0000        BRKSTK: DEFW    0                   ; Break stack

                    ; ****************************
                    ; * This buffer holds the 64 *
                    ; * colour codes produced by *
                    ; *       a cell scan:       *
                    ; *                          *
                    ; *   CCCCCCCC Bytes 00-07   *
                    ; *   CCCCCCCC Bytes 08-15   *
                    ; *   CCCCCCCC Bytes 16-23   *
                    ; *   CCCCCCCC Bytes 24-31   *
                    ; *   CCCCCCCC Bytes 32-39   *
                    ; *   CCCCCCCC Bytes 40-47   *
                    ; *   CCCCCCCC Bytes 48-55   *
                    ; *   CCCCCCCC Bytes 56-64   *
                    ; *                          *
                    ; ****************************

E251                CBUFF:  DEFS    64                  ; Cell buffer

                            END
```

<a name="character_editor"></a>

## キャラクターエディター

このプログラムは、MSXの文字パターンを変更することができます。プログラムが最初に実行されると、2KBの文字セットが現在の位置（通常はMSX ROM）からCHRTABバッファ（E2A3H～EAA2H）にコピーされ、画面が以下のように設定されます。

このプログラムにはコマンドと編集の2つの操作レベルがあり、RETURNキーで切り替えます。コマンドモードでは、4つの矢印キーを使用して編集する文字を選択します。選択した文字は大きなカーソルで示され、画面の右側に拡大表示されます。「Q」キーを押すとプログラムを終了し、BASICに戻ります。「A」キーを押すと文字セットが採用され、システム文字セットになります。採用された文字セットはメモリの最上位領域（EB80H～F37FH）にコピーされ、そのスロットIDとアドレスが[CGPNT](#cgpnt)に格納されます。

編集モードでは、4つの矢印キーを使って編集するドットを選択します。ドットは小さなカーソルで表示されます。スペースキーで現在のドットを消去し、「.」キーで確定します。パターンが変更されると、画面左側の文字メニューが更新されます。

CHRTAB内の文字セットは、「BSAVE」ステートメントを使用してカセットに保存し、後で「BLOAD」ステートメントを使用して再ロードすることができます。ADOPTサブルーチンはパターンと共に保存し、再ロード時に実行することで、システムが新しい文字セットを採用するようにします。あるいは、BASICステートメントを使用して文字セットのみを保存し、再ロード時にそのスロットIDとアドレスを[CGPNT](#cgpnt)に格納することもできます。なお、文字パターンを変更しても、MSXシステムの動作には一切影響しません。

```
                            ORG     0E000H
                            LOAD    0E000H

                    ; ******************************
                    ; *   BIOS STANDARD ROUTINES   *
                    ; ******************************

                    RDSLT:  EQU     000CH
                    RDVRM:  EQU     004AH
                    WRTVRM: EQU     004AH
                    FILVRM: EQU     0056H
                    INIGRP: EQU     0072H
                    CHSNS:  EQU     009CH
                    CHGET:  EQU     009FH
                    MAPXYC: EQU     0111H
                    FETCHC: EQU     0114H
                    RSLREG: EQU     0138H

                    ; ******************************
                    ; *     WORKSPACE VARIABLES    *
                    ; ******************************

                    GRPCOL: EQU     0F3D9H
                    FORCLR: EQU     0F3E9H
                    BAKCLR: EQU     0F3EAH
                    CGPNT:  EQU     0F91FH
                    EXPTBL: EQU     0FCC1H
                    SLTTBL: EQU     0FCC5H

                    ; ******************************
                    ; *      CONTROL CHARACTERS    *
                    ; ******************************

                    CR:     EQU     13
                    RIGHT:  EQU     28
                    LEFT:   EQU     29
                    UP:     EQU     30
                    DOWN:   EQU     31

E000    CDF6E0      CHEDIT: CALL    INIT                ; Cold start
E003    CDBDE0      CH1:    CALL    CHRMAG              ; Magnify chr
E006    CDFEE1              CALL    CHRXY               ; Chr coords
E009    1608                LD      D,8                 ; Cursor size
E00B    CD2FE2              CALL    GETKEY              ; Get command
E00E    FE51                CP      "Q"                 ; Quit
E010    C8                  RET     Z                   ;
E011    2103E0              LD      HL,CH1              ; Set up return
E014    E5                  PUSH    HL                  ;
E015    FE41                CP      "A"                 ; Adopt
E017    CA6EE2              JP      Z,ADOPT             ;
E01A    FE0D                CP      CR                  ; Edit
E01C    281F                JR      Z,EDIT              ;
E01E    0E01                LD      C,1                 ; C=Offset
E020    FE1C                CP      RIGHT               ; Right
E022    2811                JR      Z,CH2               ;
E024    0EFF                LD      C,0FFH              ;
E026    FE1D                CP      LEFT                ; Left
E028    280B                JR      Z,CH2               ;
E02A    0EF0                LD      C,0F0H              ;
E02C    FE1E                CP      UP                  ; Up
E02E    2805                JR      Z,CH2               ;
E030    0E10                LD      C,16                ;
E032    FE1F                CP      DOWN                ; Down
E034    C0                  RET     NZ                  ;
E035    3AA1E2      CH2:    LD      A,(CHRNUM)          ; Current chr
E038    81                  ADD     A,C                 ; Add offset
E039    32A1E2              LD      (CHRNUM),A          ; New chr
E03C    C9                  RET                         ;

E03D    CDE6E1      EDIT:   CALL    DOTXY               ; Dot coords
E040    1602                LD      D,2                 ; Cursor size
E042    CD2FE2              CALL    GETKEY              ; Get command
E045    FE0D                CP      CR                  ; Quit
E047    C8                  RET     Z                   ;
E048    213DE0              LD      HL,EDIT             ; Set up return
E04B    E5                  PUSH    HL                  ;
E04C    0100FE              LD      BC,0FE00H           ; AND/OR masks
E04F    FE20                CP      " "                 ; Space
E051    2824                JR      Z,ED3               ;
E053    0C                  INC     C                   ; New OR mask
E054    FE2E                CP      "."                 ; Dot
E056    281F                JR      Z,ED3               ;
E058    FE1C                CP      RIGHT               ; Right
E05A    2811                JR      Z,ED2               ;
E05C    0EFF                LD      C,0FFH              ; C=Offset
E05E    FE1D                CP      LEFT                ; Left
E060    280B                JR      Z,ED2               ;
E062    0EF8                LD      C,0F8H              ;
E064    FE1E                CP      UP                  ; Up
E066    2805                JR      Z,ED2               ;
E068    0E08                LD      C,8                 ;
E06A    FE1F                CP      DOWN                ; Down
E06C    C0                  RET     NZ                  ;
E06D    3AA2E2      ED2:    LD      A,(DOTNUM)          ; Current dot
E070    81                  ADD     A,C                 ; Add offset
E071    E63F                AND     63                  ; Wrap round
E073    32A2E2              LD      (DOTNUM),A          ; New dot
E076    C9                  RET                         ;
E077    CD1EE2      ED3:    CALL    PATPOS              ; IY->Pattern
E07A    3AA2E2              LD      A,(DOTNUM)          ; Current dot
E07D    F5                  PUSH    AF                  ;
E07E    0F                  RRCA                        ;
E07F    0F                  RRCA                        ;
E080    0F                  RRCA                        ;
E081    E607                AND     7                   ; A=Row
E083    5F                  LD      E,A                 ;
E084    1600                LD      D,0                 ; DE=Row
E086    FD19                ADD     IY,DE               ; IY->Row
E088    F1                  POP     AF                  ;
E089    E607                AND     7                   ; A=Column
E08B    3C                  INC     A                   ;
E08C    CB08        ED4:    RRC     B                   ; AND mask
E08E    CB09                RRC     C                   ; OR mask
E090    3D                  DEC     A                   ; Count columns
E091    20F9                JR      NZ,ED4              ;
E093    FD7E00              LD      A,(IY+0)            ; A=Pattern
E096    A0                  AND     B                   ; Strip old bit
E097    B1                  OR      C                   ; New bit
E098    FD7700              LD      (IY+0),A            ; New pattern
E09B    CDBDE0              CALL    CHRMAG              ; Update magnified

E09E    CD1EE2      CHROUT: CALL    PATPOS              ; IY->Pattern
E0A1    CDFEE1              CALL    CHRXY               ; Get coords
E0A4    CDA3E1              CALL    MAP                 ; Map
E0A7    0608                LD      B,8                 ; Dot rows
E0A9    D5          CO1:    PUSH    DE                  ;
E0AA    E5                  PUSH    HL                  ;
E0AB    3E08                LD      A,8                 ; Dot cols
E0AD    FD5E00              LD      E,(IY+0)            ; E=Pattern
E0B0    CDC4E1              CALL    SETROW              ; Set row
E0B3    E1                  POP     HL                  ; HL=CLOC
E0B4    D1                  POP     DE                  ; D=CMASK
E0B5    CDB8E1              CALL    DOWNP               ; Down a pixel
E0B8    FD23                INC     IY                  ;
E0BA    10ED                DJNZ    CO1                 ;
E0BC    C9                  RET                         ;

E0BD    CD1EE2      CHRMAG: CALL    PATPOS              ; IY->Pattern
E0C0    0EBF                LD      C,191               ; Start X
E0C2    1E07                LD      E,7                 ; Start Y
E0C4    CDA3E1              CALL    MAP                 ; Map
E0C7    0608                LD      B,8                 ; Dot rows
E0C9    0E05        CM1:    LD      C,5                 ; Row mag
E0CB    C5          CM2:    PUSH    BC                  ;
E0CC    D5                  PUSH    DE                  ;
E0CD    E5                  PUSH    HL                  ;
E0CE    0608                LD      B,8                 ; Dot columns
E0D0    FD7E00              LD      A,(IY+0)            ; A=Pattern
E0D3    07          CM3:    RLCA                        ; Test bit
E0D4    F5                  PUSH    AF                  ;
E0D5    9F                  SBC     A,A                 ; 0=00H, 1=FFH
E0D6    5F                  LD      E,A                 ; E=Mag pattern
E0D7    3E05                LD      A,5                 ; Column mag
E0D9    CDC4E1              CALL    SETROW              ; Set row
E0DC    CDAEE1              CALL    RIGHTP              ; Right a pixel
E0DF    CDAEE1              CALL    RIGHTP              ; Skip grid
E0E2    F1                  POP     AF                  ;
E0E3    10EE                DJNZ    CM3                 ;
E0E5    E1                  POP     HL                  ; HL=CLOC
E0E6    D1                  POP     DE                  ; D=CMASK
E0E7    C1                  POP     BC                  ;
E0E8    CDB8E1              CALL    DOWNP               ; Down a pixel
E0EB    0D                  DEC     C                   ;
E0EC    20DD                JR      NZ,CM2              ;
E0EE    CDB8E1              CALL    DOWNP               ; Skip grid
E0F1    FD23                INC     IY                  ;
E0F3    10D4                DJNZ    CM1                 ;
E0F5    C9                  RET                         ;

E0F6    100008      INIT:   LD      BC,2048             ; Size
E0F9    11A3E2              LD      DE,CHRTAB           ; Destination
E0FC    2A20F9              LD      HL,(CGPNT+1)        ; Source
E0FF    C5          IN1:    PUSH    BC                  ;
E100    D5                  PUSH    DE                  ;
E101    3A1FF9              LD      A,(CGPNT)           ; Slot ID
E104    CD0C00              CALL    RDSLT               ; Read chr  pattern
E107    FB                  EI                          ;
E108    D1                  POP     DE                  ;
E109    C1                  POP     BC                  ;
E10A    12                  LD      (DE),A              ; Put in buffer
E10B    13                  INC     DE                  ;
E10C    23                  INC     HL                  ;
E10D    0B                  DEC     BC                  ;
E10E    78                  LD      A,B                 ;
E10F    B1                  OR      C                   ;
E110    20ED                JR      NZ,IN1              ;
E112    CD7200              CALL    INIGRP              ; SCREEN 2
E115    3AE9F3              LD      A,(FORCLR)          ; Colour 1
E118    07                  RLCA                        ;
E119    07                  RLCA                        ;
E11A    07                  RLCA                        ;
E11B    07                  RLCA                        ;
E11C    4F                  LD      C,A                 ; C=Colour 1
E11D    3AEAF3              LD      A,(BAKCLR)          ; Colour 0
E120    B1                  OR      C                   ; Mix
E121    010018              LD      BC,6144             ; Colour table size
E124    2AC9F3              LD      HL,(GRPCOL)         ; Colour table
E127    CD5600              CALL    FILVRM              ; Fill colours
E12A    210BB1              LD      HL,177*256+11       ;
E12D    010AFF              LD      BC,0FFH*256+10      ;
E130    1E06                LD      E,6                 ;
E132    3E11                LD      A,17                ;
E134    CD62E1              CALL    GRID                ; Draw chr grid
E137    210631              LD      HL,49*256+6         ;
E13A    01BEAA              LD      BC,0AAH*256+190     ;
E13D    1E06                LD      E,6                 ;
E13F    3E09                LD      A,9                 ;
E141    CD62E1              CALL    GRID                ; Draw mag grid
E144    213031              LD      HL,49*256+48        ;
E147    01BEFF              LD      BC,0FFH*256+190     ;
E14A    1E06                LD      E,6                 ;
E14C    3E02                LD      A,2                 ;
E14E    CD62E1              CALL    GRID                ; Draw mag box
E151    AF                  XOR     A                   ;
E152    32A2E2              LD      (DOTNUM),A          ; Current dot
E155    21A1E2              LD      HL,CHRNUM           ;
E158    77                  LD      (HL),A              ; Current chr
E159    E5          IN2:    PUSH    HL                  ;
E15A    CD9EE0              CALL    CHROUT              ; Display chr
E15D    E1                  POP     HL                  ;
E15E    34                  INC     (HL)                ; Next chr
E15F    20F8                JR      NZ,IN2              ; Do 256
E161    C9                  RET                         ;

E162    F5          GRID:   PUSH    AF                  ;
E163    C5                  PUSH    BC                  ;
E164    E5                  PUSH    HL                  ;
E165    CDA3E1              CALL    MAP                 ; Map
E168    C1                  POP     BC                  ; B=Len,C=Step
E169    F1                  POP     AF                  ;
E16A    5F                  LD      E,A                 ; E=Pattern
E16B    F1                  POP     AF                  ; A=Count
E16C    F5                  PUSH    AF                  ;
E16D    D5                  PUSH    DE                  ;
E16E    E5                  PUSH    HL                  ;
E16F    F5          GR1:    PUSH    AF                  ;
E170    C5                  PUSH    BC                  ;
E171    D5                  PUSH    DE                  ;
E172    E5                  PUSH    HL                  ;
E173    78                  LD      A,B                 ; A=Len
E174    CDC4E1              CALL    SETROW              ; Horizontal line
E177    E1                  POP     HL                  ; HL=CLOC
E178    D1                  POP     DE                  ; D=CMASK
E179    CDB8E1      GR3:    CALL    DOWNP               ; Down a pixel
E17C    0D                  DEC     C                   ; Done step?
E17D    20FA                JR      NZ,GR3              ;
E17F    C1                  POP     BC                  ;
E180    F1                  POP     AF                  ; A=Count
E181    3D                  DEC     A                   ; Done lines?
E182    20EB                JR      NZ,GR1              ;
E184    E1                  POP     HL                  ; HL=Initial CLOC
E185    D1                  POP     DE                  ; D=Initial CMASK
E186    F1                  POP     AF                  ; A=Count
E187    F5          GR4:    PUSH    AF                  ;
E188    C5                  PUSH    BC                  ;
E189    D5                  PUSH    DE                  ;
E18A    E5                  PUSH    HL                  ;
E18B    3E01        GR5:    LD      A,1                 ; Line width
E18D    CDC4E1              CALL    SETROW              ; Thin line
E190    CDB8E1              CALL    DOWNP               ; Down a pixel
E193    10F6                DJNZ    GR5                 ; Vertical len
E195    E1                  POP     HL                  ; HL=CLOC
E196    D1                  POP     DE                  ; D=CMASK
E197    CDAEE1      GR6:    CALL    RIGHTP              ; Right a pixel
E19A    0D                  DEC     C                   ; Done step?
E19B    20FA                JR      NZ,GR6              ;
E19D    C1                  POP     BC                  ;
E19E    F1                  POP     AF                  ; A=Count
E19F    3D                  DEC     A                   ; Done lines?
E1A0    20E5                JR      NZ,GR4              ;
E1A2    C9                  RET                         ;

E1A3    0600        MAP:    LD      B,0                 ; X MSB
E1A5    50                  LD      D,B                 ; Y MSB
E1A6    CD1101              CALL    MAPXYC              ; Map coords
E1A9    CD1401              CALL    FETCHC              ; HL=CLOC
E1AC    57                  LD      D,A                 ; D=CMASK
E1AD    C9                  RET                         ;

E1AE    CB0A        RIGHTP: RRC     D                   ; Shift CMASK
E1B0    D0                  RET     NC                  ; NC=Same cell
E1B1    C5          RP1:    PUSH    BC                  ;
E1B2    010800              LD      BC,8                ; Offset
E1B5    09                  ADD     HL,BC               ; HL=Next cell
E1B6    C1                  POP     BC                  ;
E1B7    C9                  RET                         ;

E1B8    23          DOWNP:  INC     HL                  ; CLOC down
E1B9    7D                  LD      A,L                 ;
E1BA    E607                AND     7                   ; Select pixel row
E1BC    C0                  RET     NZ                  ; NZ=Same cell
E1BD    C5                  PUSH    BC                  ;
E1BE    01F800              LD      BC,00F8H            ; Offset
E1C1    09                  ADD     HL,BC               ; HL=Next cell
E1C2    C1                  POP     BC                  ;
E1C3    C9                  RET                         ;

E1C4    C5          SETROW: PUSH    BC                  ;
E1C5    47                  LD      B,A                 ; B=Count
E1C6    CD4A00      SE1:    CALL    RDVRM               ; Get old pattern
E1C9    4F          SE2:    LD      C,A                 ; C=Old
E1CA    7A                  LD      A,D                 ; A=CMASK
E1CB    2F                  CPL                         ; AND mask
E1CC    A1                  AND     C                   ; Strip old bit
E1CD    CB03                RLC     E                   ; Shift pattern
E1CF    3001                JR      NC,SE3              ; NC=0 Pixel
E1D1    B2                  OR      D                   ; Set 1 Pixel
E1D2    05          SE3:    DEC     B                   ; Finished?
E1D3    280C                JR      Z,SE4               ;
E1D5    CB0A                RRC     D                   ; CMASK right
E1D7    30F0                JR      NC,SE2              ; NC=Same cell
E1D9    CD4D00              CALL    WRTVRM              ; Update cell
E1DC    CDB1E1              CALL    RP1                 ; Next cell
E1DF    18E5                JR      SE1                 ; Start again
E1E1    CD4D00      SE4:    CALL    WRTVRM              ; Update cell
E1E4    C1                  POP     BC                  ;
E1E5    C9                  RET                         ;

E1E6    3AA2E2      DOTXY:  LD      A,(DOTNUM)          ; Current dot
E1E9    F5                  PUSH    AF                  ;
E1EA    E607                AND     7                   ; Column
E1EC    07                  RLCA                        ;
E1ED    4F                  LD      C,A                 ; C=Col*2
E1EE    07                  RLCA                        ; A=Col*4
E1EF    81                  ADD     A,C                 ; A=Col*6
E1F0    C6BF                ADD     A,191               ; Grid atart
E1F2    4F                  LD      C,A                 ; C=X coord
E1F3    F1                  POP     AF                  ;
E1F4    E638                AND     38H                 ; Row*8
E1F6    0F                  RRCA                        ;
E1F7    5F                  LD      E,A                 ; E=Row*4
E1F8    0F                  RRCA                        ; A=Row*2
E1F9    83                  ADD     A,E                 ; A=Row*6
E1FA    C607                ADD     A,7                 ; Grid start
E1FC    5F                  LD      E,A                 ; E=Y coord
E1FD    C9                  RET                         ;

E1FE    3AA1E2      CHRXY:  LD      A,(CHRNUM)          ; Current chr
E201    F5                  PUSH    AF                  ;
E202    CD14E2              CALL    MULT11              ; Column*11
E205    C60C                ADD     A,12                ; Grid start
E207    4F                  LD      C,A                 ; C=X coord
E208    F1                  POP     AF                  ;
E209    0F                  RRCA                        ;
E20A    0F                  RRCA                        ;
E20B    0F                  RRCA                        ;
E20C    0F                  RRCA                        ;
E20D    CD14E2              CALL    MULT11              ; Row*11
E210    C608                ADD     A,8                 ; Grid start
E212    5F                  LD      E,A                 ; E=Y coord
E213    C9                  RET                         ;

E214    E60F        MULT11: AND     0FH                 ;
EF16    57                  LD      D,A                 ; D=N
E217    07                  RLCA                        ;
E218    47                  LD      B,A                 ; B=N*2
E219    07                  RLCA                        ;
E21A    07                  RLCA                        ; A=N*8
E21B    80                  ADD     A,B                 ;
E21C    82                  ADD     A,D                 ; A=N*11
E21D    C9                  RET                         ;

E21E    3AA1E2      PATPOS: LD      A,(CHRNUM)          ; Current chr
E221    6F                  LD      L,A                 ;
E222    2600                LD      H,0                 ; HL=Chr
E224    29                  ADD     HL,HL               ;
E225    29                  ADD     HL,HL               ;
E226    29                  ADD     HL,HL               ; HL=Chr*8
E227    EB                  EX      DE,HL               ; DE=Chr*8
E228    FD21A3E2            LD      IY,CHRTAB           ; Patterns
E22C    FD19                ADD     IY,DE               ; IY->Pattern
E22E    C9                  RET                         ;

E22F    0600        GETKEY: LD      B,0                 ; Cursor flag
E231    C5          GE1:    PUSH    BC                  ; C=X coord
E232    D5                  PUSH    DE                  ; E=Y coord
E233    CD50E2              CALL    INVERT              ; Flip cursor
E236    D1                  POP     DE                  ;
E237    C1                  POP     BC                  ;
E238    04                  INC     B                   ; Flip flag
E239    21401F              LD      HL,8000             ; Blink rate
E23C    CD9C00      GE2:    CALL    CHSNS               ; Check KEYBUF
E23F    2007                JR      NZ,GE3              ; NZ=Got key
E241    2B                  DEC     HL                  ;
E242    7C                  LD      A,H                 ;
E243    B5                  OR      L                   ;
E244    20F6                JR      NZ,GE2              ;
E246    18E9                JR      GE1                 ; Time for cursor
E248    CB40        GE3:    BIT     0,B                 ; Cursor state
E24A    C450E2              CALL    NZ,INVERT           ; Remove cursor
E24D    C39F00              JP      CHGET               ; Collect character

E250    D5          INVERT: PUSH    DE                  ;
E251    CDA3E1              CALL    MAP                 ; Map coords
E254    F1                  POP     AF                  ; A=Cursor size
E255    47                  LD      B,A                 ; B=Rows
E256    5F                  LD      E,A                 ; E=Cols
E257    D5          IV1:    PUSH    DE                  ;
E258    E5                  PUSH    HL                  ;
E259    CD4A00      IV2:    CALL    RDVRM               ; Old pattern
E25C    AA                  XOR     D                   ; Flip a bit
E25D    CD4D00              CALL    WRTVGM              ; Put it back
E260    CDAEE1              CALL    RIGHTP              ; Right a pixel
E263    1D                  DEC     E                   ;
E264    20F3                JR      NZ,IV2              ;
E266    E1                  POP     HL                  ; HL=CLOC
E267    D1                  POP     DE                  ; D=CMASK
E268    CDB8E1              CALL    DOWNP               ; Down a pixel
E26B    10EA                DJNZ    IV1                 ;
E26D    C9                  RET                         ;

E26E    010008      ADOPT:  LD      BC,2048             ; Size
E271    1180EB              LD      DE,0EB80H           ; Destination
E274    ED5320F9            LD      (CGPNT+1),DE        ;
E278    21A3E2              LD      HL,CHRTAB           ; Source
E27B    EDB0                LDIR                        ; Copy up high
E27D    CD3801              CALL    RSLREG              ; Read PSLOT reg
E280    07                  RLCA                        ;
E281    07                  RLCA                        ;
E282    E603                AND     3                   ; Select Page 3
E284    4F                  LD      C,A                 ;
E285    0600                LD      B,0                 ; BC=Page 3 PSLOT#
E287    21C1FC              LD      HL,EXPTBL           ; Expanders
E28A    09                  ADD     HL,BC               ;
E28B    CB7E                BIT     7,(HL)              ; PSLOT expanded?
E28D    280E                JR      Z,AD1               ; A=Normal
E28F    21C5FC              LD      HL,SLTTBL           ; Secondary regs
E292    09                  ADD     HL,BC               ;
E293    7E                  LD      A,(HL)              ; A=Secondary reg
E294    07                  RLCA                        ;
E295    07                  RLCA                        ;
E296    07                  RLCA                        ;
E297    07                  RLCA                        ;
E298    E60C                AND     0CH                 ; A=Page 3 SSLOT#
E29A    B1                  OR      C                   ; Mix Page 3 PSLOT#
E29B    CBFF                SET     7,A                 ; A=Slot ID
E29D    321FF9      AD1:    LD      (CGPNT),A           ;
E2A0    C9                  RET                         ;

E2A1    00          CHRNUM: DEFB    0                   ; Current chr
E2A2    00          DOTNUM: DEFB    0                   ; Current dot
E2A3                CHRTAB: DEFS    2048                ; Patterns to EAA2H

                            END
```

[CH01F01]: ./images/CH01F01.svg
[CH01F02]: ./images/CH01F02.svg
[CH01F03]: ./images/CH01F03.svg
[CH01F04]: ./images/CH01F04.svg
[CH01F05]: ./images/CH01F05.svg
[CH01F06]: ./images/CH01F06.svg
[CH02F07]: ./images/CH02F07.svg
[CH02F08]: ./images/CH02F08.svg
[CH02F09]: ./images/CH02F09.svg
[CH02F10]: ./images/CH02F10.svg
[CH02F11]: ./images/CH02F11.svg
[CH02F12]: ./images/CH02F12.svg
[CH02F13]: ./images/CH02F13.svg
[CH02F14]: ./images/CH02F14.svg
[CH02F15]: ./images/CH02F15.svg
[CH02F16]: ./images/CH02F16.svg
[CH02F17]: ./images/CH02F17.svg
[CH02F18]: ./images/CH02F18.svg
[CH02F19]: ./images/CH02F19.svg
[CH02F20]: ./images/CH02F20.svg
[CH02F21]: ./images/CH02F21.svg
[CH02F22]: ./images/CH02F22.svg
[CH02F23]: ./images/CH02F23.svg
[CH02F24]: ./images/CH02F24.svg
[CH03F25]: ./images/CH03F25.svg
[CH03F26]: ./images/CH03F26.svg
[CH03F27]: ./images/CH03F27.svg
[CH03F28]: ./images/CH03F28.svg
[CH03F29]: ./images/CH03F29.svg
[CH03F30]: ./images/CH03F30.svg
[CH03F31]: ./images/CH03F31.svg
[CH03F32]: ./images/CH03F32.svg
[CH03F33]: ./images/CH03F33.svg
[CH04F34]: ./images/CH04F34.svg
[CH04F35]: ./images/CH04F35.svg
[CH04F36]: ./images/CH04F36.svg
[CH04F37]: ./images/CH04F37.svg
[CH04F38]: ./images/CH04F38.svg
[CH04F39a]: ./images/CH04F39a.svg
[CH04F39b]: ./images/CH04F39b.svg
[CH04F40]: ./images/CH04F40.svg
[CH05F41]: ./images/CH05F41.svg
[CH05F42]: ./images/CH05F42.svg
[CH05F43]: ./images/CH05F43.svg
[CH05F44]: ./images/CH05F44.svg
[CH05F45]: ./images/CH05F45.svg
[CH05F46]: ./images/CH05F46.svg
[CH05F47]: ./images/CH05F47.svg
[CH05F48]: ./images/CH05F48.svg
[CH05F49]: ./images/CH05F49.svg
[CH05F50]: ./images/CH05F50.svg
[CH05F51]: ./images/CH05F51.svg
[CH05F52]: ./images/CH05F52.svg
