---------------------------------------------------------------------------  
                               tniASM v0.45  
                      (c) 2000-2011 by The New Image

                      Programmed by Patriek Lesparre

                          http://tniasm.tni.nl/  
                          e-mail: tniasm@tni.nl  
---------------------------------------------------------------------------

-----------------------

# 第1章 はじめに  

## 1.1  What is it?

  tniASMはZ80、R800、GBZ80用のクロスアセンブラです。  
  機能は次のとおりです。

  - マルチパス設計  
  - 条件付きアセンブリ  
  - ローカルラベルメカニズム  
  - 優先レベルを備えた拡張32ビット式パーサー  
  - ソースファイルとバイナリファイルのインクルード  
  - ネスト可能なブロックコメント  
  - 複数ファイルの出力とファイルパッチ

## 1.2  Why?

  なぜまたアセンブラを書く必要があるのでしょうか?いい質問ですね!  
  まず、私はC言語を学ぶ必要があり、新しい言語を学ぶには、必要な  
  プログラムを書くのが一番良い方法だと思いました。それで、tniASMを書いた  
  2つ目の理由に移ります。それは、私が知っている他のクロスアセンブラには、  
  私が求めていた/必要としていた機能がなかったからです。

  そのため、そしておそらく私がこれまでアセンブラ/コンパイラを書いたことが  
  ないこともあって、tniASMは他のアセンブラとは違います。多くの独特な特徴が  
  あり、正直言って少し奇妙に感じるかもしれません。とはいえ、私の目的には  
  完璧に合致しており、皆さんにも気に入っていただけることを願っています。

## 1.3  tniASMとパス

  ほとんどのアセンブラには2つのパスがあります。  
  1つはラベルに関する情報を収集し、もう1つは前方参照を処理して出力を生成します。

  tniASM は異なる方法で処理します。  
  出力生成はそれ自体で1パスであり、その前に tniASM はすべての式を評価するのに  
  必要な回数だけパスを実行します。

  基本的に、tniASM は 2 回のパスに加えて、前方参照のレベルごとに  
  追加のパスを実行し、合計で最大 5 回のパスを実行することを意味します。

## 1.4  tniASMアセンブラ構文

  tniASM には、サポートするプロセッサ用の独自のアセンブラ構文があります。  
  心配しないでください。変更は最小限です。各章をご覧ください。  
  標準ルール間の相違点については 2.7 以降を参照してください。

## 1.5  tniASMの使用

  tniASMの使い方はとても簡単です。次のように入力するだけです。

  ```
  tniasm ファイル名
  ```

  tniASMは'ファイル名'をアセンブルし、  
  生成されたマシンコードを'tniasm.out'に出力しようとします。

  拡張子のないファイル名が指定され、エラーが発生した場合、  
  tniASMは拡張子".asm"を追加して再試行します。

  'tniasm.out' 以外の出力ファイル名を使用し、  
  FNAME 疑似命令を使用しない場合は、  
  コマンドラインに 2 番目のファイル名を追加すると、  
  tniASM はそれを出力として使用します。

### 1.5.1  tniASMの出力

  1.5章で述べたように、tniASMは通常、マシンコードを  
  「tniasm.out」というファイルに出力します。これはFNAME命令を使用  
  することで変更できます(2.5.5章を参照)。

  tniASMは'tniasm.sym'というシンボルテーブルファイルも出力します。  
  このファイルには、プログラム内のすべてのラベルの値が含まれます。  
  このファイルは'label: EQU 値'という形式なので、外部ファイルに  
  直接INCLUDEすることができます。

  これらのファイルに加えて、tniASMは一時ファイルも作成します。  
  'tniasm.tmp' は内部使用のみに限定されます。

第2章 tniASM言語  
------------------------------

## 2.1  大文字と小文字の区別

  つまり、存在しません。tniASMでは「LabelA」と「labela」は全く同じ  
  であり、「ldir」と「LdiR」も同様です。

## 2.2  tniASMソースラインのレイアウト

  これは、tniASM がほとんどのアセンブラと大きく異なる点です。  
  通常、ソース ラインは次のようにレイアウトされます。

  ```
  [ラベル:] [命令 [オペランド]] [;コメント]
  ```

  つまり、「ラベル」、「説明」、「コメント」の 3 つのフィールドを  
  任意に組み合わせることができます。

  ある意味ではtniASMも同じレイアウトを使用していますが、1行に任意の  
  数のラベル定義と命令を記述できます。コメントフィールドのみ1つしか  
  記述できません。レイアウトは次のように説明できます。  

  ```
  [ [ラベル:] | [命令 [オペランド]] ]* [;コメント]  
  ```

  つまり、tniASM は次のような行を問題なく組み立てることができます。

  ```
  start: JP begin exit: LD BC,0042h CALL dos begin: LD DE,text
  ```

  この自由度に加えて、tniASM は行内の空白スペースに制限を設けていません。  
  例えば、ラベルの前には空白スペースを置くことができ、  
  命令の前には空白スペースを置くことができません。  
  つまり、命令はラベル定義の直後に記述できます。  
  コメントについても同様です。

### 2.2.1  ラベルについて  

  ラベル定義はコロン (':') で終わる必要があります。ラベルの長さは実質的に  
  無制限です。ラベルに使用できる文字は、文字、数字、'_'、'.'、'?'、'!'、  
  '~'、'@'、および '#' です。  
  ラベルの先頭文字には数字は使用できません。

  予約語(「pop」、「ld」、「hl」など)をラベルとして定義することは可能ですが、  
  使用する場合は「&」を接頭辞として付ける必要があります。  
  つまり、次のように記述できます。

  ```
       call &pop  
       {...}  
  pop: pop hl  
       pop de  
       pop bc  
       jp [hl]
  ```

  tniASMはローカルラベルもサポートしています。  
  ローカルラベルは常に、ソースコード内の前の非ローカルラベルに対してローカルです。  
  ラベルがローカルになるのは、最初の文字が「.」の場合です。

  例を挙げると次のようになります。

  ```
  main:   ld   b,8  
  .loop:  call doSomething  
          djnz .loop

  sub:    ld   b,8  
  .loop:  call doSomething  
          djnz .loop  
  ```

  上記のコードでは4つの別々のラベルが定義されています: "main",  
  "main.loop"、"sub"、"sub.loop"。  
  この動作により、現在の非ローカルラベルのスコープ外にあるローカルラベルにも  
  アクセスできるようになります。例:。

  ```
  main:   {...}  
  .end:   ret

  sub:    {...}  
          jp   main.end  
  .end:   ret
  ```

  または逆に、現在の非ローカルラベルのスコープ外でローカルなラベルを  
  作成します。

  ```
  main:   ld      a,[.value]  
          {...}

  sub:    {...}

  main.value: db  0
  ```

### 2.2.2  行区切り

  '|' 文字は行区切り文字として使用されます。これを使用すると、1行に複数の  
  命令を記述できます。  
  実際には、tniASM は「add a,a call jump ret」という行が実際には3つの異なる  
  命令であることを自動的に認識できるため、ほとんどの場合、行区切り文字は必要  
  ありません。  
  命令を '|' で区切ると、見た目も良くなり、理解しやすくなります。  
  ただし、「add a,34 and 3 xor 255」という行では、tniASM は「add a,253」を  
  意味していると想定し、3つの別々の命令を意味しているとは想定しません。  
  tniASM が目的のコードを確実に生成するには、行区切り文字を使用してください。

### 2.2.3  コメントについて

  通常通り、セミコロン (';') がコメント文字として使用されます。  
  セミコロンは行のどこにでも置くことができ、改行されるまで、  
  それ以降の内容はすべて無視されます。

  tniASM は通常のコメントに加えて、コメントブロックもサポートしています。  
  '{' と '}' 文字はそれぞれコメントブロックの開始と終了を示します。  
  コメントブロックはファイル内の任意の場所に配置でき、その間にあるものは  
  すべて無視されます。  
  コメントブロックは実質的に無限のネスト深度でネスト可能です。

## 2.3  定数

  niASMには、数値、文字、文字列の3種類の定数があります。  
  tniASMは32ビットアセンブラなので、  
  定数は32ビットの符号付き整数値で、  
  範囲は-2147483648 (80000000h) から 2147483647 (7FFFFFFFh) です。

### 2.3.1  数値定数

  数値定数は10進数、16進数、2進数または8進数。  
  サポートされている形式は次のとおりです。

  ```
  Decimal    : 123  
               123d  
  Hexadecimal: 1234h (アルファベットで始めることはできません。「0ABCDh」などを使用してください。)  
               $1234  
               0x1234  
  Binary     : 11100100b (空白が含まれる場合があります。例:. '1110 0100 b')  
               %11100100 (            〃                     '% 1110 0100')  
  Octal      : 123o  
               123q
  ```

### 2.3.2  文字列定数

  文字列定数は、一重引用符または二重引用符で囲まれた4文字以上の文字列です。  
  DB/DW、INCLUDE、FNAMEなどのコマンドで使用されます。  
  文字列定数は正規表現では使用できません。

  例:  
  ```
    DB   "a 'double-qouted' string can contain single qoutes"  
    DB   'and a "single-qouted" string can contain double qoutes'
  ```

### 2.3.3  文字定数

  文字定数は文字列と同じ規則に従いますが、式の中で使用できる点が異なります。  
  文字定数は最大4文字で、下位バイトから順に記憶されます。  
  したがって、定数「A」は41h、「AB」は4241h(または41h,42h)、  
  「ABC」は434241h(41h,42h,43h)、  
  「ABCD」は44434241h(41h,42h,43h,44h)として扱われます。  
  DB/DWでは、式の中でない限り、文字定数は常に文字列定数として扱われます。

  例:  
  ```
    DB 'abcd'           ; 'a','b','c','d'.  
    DB +"abcd",1+'a'    ; 'a','b'.  
                        ; 両方の文字列は式の中にあるため、  
                        ; 1文字の定数として扱われます。  
    DB 'a'+1            ; これはエラーです。  
                        ; 'a'が式の中にあるとみなされないためです。  
    DB ('abcd' >> 8)    ; 'b'
  ```

## 2.4  式

  式は32ビット符号付き整数演算で評価されます。  
  式は1つ以上の定数と、0個以上の演算子の組み合わせで構成されます。  
  式では、'$'と'$$'という2つの特殊トークンを使用できます。  
  これらはそれぞれ、現在の命令の先頭におけるアセンブリ位置  
  (プログラムカウンタ)とファイル位置を表します。

  次のようにコード化できます。

  ```
  nop  
  nop  
  jr $-2  ; jump to the first nop
  ```

  サポートされているすべての演算子は、優先順位の低いものから順に以下に  
  リストされています。  
  優先順位が同じ演算子は、左から右に評価されます。

  もちろん、  
  括弧 '('と')'で優先順位を上書きできます。

### 2.4.1  優先順位レベル 0 - 関係演算子

  関係演算子は次のとおりです。

  ```
  x = y   等しい  
  x <> y  等しくない  
  x >< y   〃  
  x != y   〃  
  x < y   より小さい  
  x > y   より大きい  
  x <= y  以下  
  x =< y   〃  
  x >= y  以上  
  x => y   〃
  ```

  C言語とは異なり、関係演算子では(1と0の代わりに)  
  'true'に-1、'false'に0を使用します。  
  これにより、AND、OR、XOR演算子のbooleanバージョンは不要になります。  
  これらの演算子はビット演算演算子と全く同じように動作するからです。

  関係演算子を使用すると、次のような複雑な式を作成できます。

  ```
  x*(1+2*(x<0))
  ```

  これは 'x' の絶対値を与えます。

### 2.4.2  優先順位レベル1 - 加法演算子と(X)OR演算子

  これらはそれ自体で説明しているはずです。  
  tniASM は、'|' および '^' 文字 (C の場合) の代わりに  
  'OR' および 'XOR' キーワード (BASIC の場合) を使用することを選択します。

  ```
  x + y   加算  
  x - y   減算

  x OR y  ビット単位のOR  
  x XOR y ビット単位のXOR
  ```

### 2.4.3  優先順位レベル2 - 乗算演算子とAND演算子

  ```
  x ^ y   累乗  
  x * y   掛け算  
  x / y   除算  
  x MOD y 剰余

  x << y  左シフト  
  x >> y  右シフト(符号なし)

  x AND y ビット単位のAND
  ```

### 2.4.4  優先順位レベル3 - 単項演算子

  ```
  + x     インクリメント  
  - x     デクリメント  
  NOT x   1の補数
  ```

## 2.5  擬似命令

### 2.5.1  DB/DW

  バイト/ワードの文字列を定義します。

  ```
  DB   255  
  DB   "bla",13,10  
  DW   'AB',4000h  
  DW   "string may be odd"        ; odd strings are 0-padded
  ```

### 2.5.2  DC

  ビット 7 が設定されて終了する文字列を定義します。

  ```
  DC   "TOKEN"            ; DB "TOKE"、"N" または 128 と同じ  
  DC   "LIST","STOP"      ; 2 つの文字列を定義します。両方ともビット7で終了します。
  ```

### 2.5.3  DS

  スペースを定義します(バイト単位)。

  ```
  DS   10                 ; 10バイトの0を定義  
  DS   10,255             ; 255の10バイトを定義  
  DS   4000h-$            ; アドレス4000hまで0を埋める  
  DS   0                  ; 何もしない  
  DS   -1                 ; 負の値の場合も同様
  ```

### 2.5.4  EQU

  ラベルに値を割り当てます。  
  EQU はラベルと同じ行に続けて記述する必要があります。

  ```
  bankstart:      EQU  4000h  
                  ORG  bankstart          ; same as org 4000h
  ```

### 2.5.5  FNAME

  出力ファイルを指定します。FNAME を使用すると、  
  tniASM は 'tniasm.out' 以外のファイルに出力します。  
  ソースコード全体で FNAME を好きなだけ使用して、  
  異なる部分を異なるファイルに出力できます。  
    FNAME は FORG を 0 に設定します。

  ```
  FNAME "output.bin"      ; output file is now 'output.bin'  
  {...}
  ```

  新しいファイルを作成する代わりに、FNAME の2番目のパラメータを指定する  
  ことで、tniASM に既存のファイルに出力するように指示することもできます。  
  この2番目のパラメータは tniASM が出力するファイルの位置であり、  
  FORG にはこの値が自動的に設定されます。

  ```
  FNAME "output.bin",1024 ; 出力は既存のファイル「output.bin」の  
                          ; 1024番目の位置から始まります。  
  FNAME "output.bin",0    ; 出力は通常通り0番目の位置から始まりますが、  
                          ; 「output.bin」ファイルに存在します。
  ```

### 2.5.6  FORG

  出力ファイルの位置を設定します。  
  FORG を使用すると、tniASM は特定のファイル位置に出力します。  
  指定した位置がファイルサイズより大きい場合は、0 で埋められます。  
  FORG が指定されていない場合、ファイルの開始位置は 0 になります。

### 2.5.7  INCBIN

  バイナリファイルをインクルードします。  
  INCBIN命令は、現在のマシンコード出力にバイナリファイルを組み込みます。  
  これは、巨大なDBリストには含めたくないグラフィックや大きな表を埋め込む  
  場合に特に便利です。

  ```
  music1: INCBIN  "music1.bin"  
  .end:
  ```

  INCBINはオプションで1つまたは2つのパラメータを取ることができます。  
  1つ目は、含めるファイル内のオフセットです。  
  2つ目は、含めるデータの合計長です。

  ```
  INCBIN "basic.bin",7            ; include from offset 7  
  INCBIN "cutout.bin",1024,512    ; include 512 bytes from  
                                          ; offset 1024
  ```

### 2.5.8  INCLUDE

  INCLUDE命令は現在のソースに別のファイルをインクルードします。  
  メモリが許す限り深いネスト レベルでファイルを作成します。

  ```
  {...}  
  INCLUDE "incthis.asm"  
  {...}
  ```

### 2.5.9  ORG

  ORGは1つまたは2つの引数を許可します。  
  最初の引数はアセンブリ位置(プログラムカウンタ)をアドレスに設定し、  
  2番目の引数はこの「セクション」の最大許容アドレスを指定します。  
  アドレスが超過した場合、tniASMは警告を発します。  
  この警告はPHASE命令を無視します。  
  ORGが指定されていない場合、アセンブリ開始位置は0になります。  

  ```
  ORG  0c000h             ; 次のコードは0c000hから始まる  
  ORG  0c000h,0           ; 同上  
  ORG  4000h,7FFFh        ; 4000hから開始し、7FFFhを超えると警告する
  ```

### 2.5.10 PHASE/DEPHASE

  PHASE は、アセンブリ位置を指定されたアドレスに「フェーズ」します。  
  これは、後で再配置されるコードに特に便利です。  
  DEPHASE は、通常のアセンブリ位置に戻します。  
  新しい PHASE または ORG コマンドは、以前の PHASE を DEPHASE します。

  ; この例では、ルーチンSetS#0を現在のアドレスから  
  ; 0C000hに再配置します。PHASE/DEPHASEにより、  
  ; ラベル「SetS#0」は既に0C000hを指しています。

  ```
          ORG     8000h

          ld      hl,start  
          ld      de,SetS#0  
          ld      bc,SetS#0.end-SetS#0.start  
          ldir

          {...}

  SetS#0.start:  
          PHASE   0C000h  
  SetS#0: xor     a               ; set V9938 S#0  
          out     [99h],a  
          ld      a,15+128  
          out     [99h],a  
          ret  
          DEPHASE  
  .end:
  ```

### 2.5.11 RB/RW

  指定バイト/ワードを未初期化データとして予約します。  
  これは基本的にDSと同じですが、ファイル位置は更新されず、出力も行いません。  
  アセンブリ位置のみを更新します。  
  RBとRWは、RAM内の変数を宣言する際に便利です。

  ```
          ORG     0C000h  
  Var1:   RB      2               ; Var1 = 0C000h  
  Var2:   RW      1               ; Var2 = 0C002h  
  Var3:   RB      0               ; Var3 = 0C004h  
  Var4:   RW      -1              ; Var4 = 0C004h  
                                  ; ゼロと負の値は無視されるため
  ```

## 2.6  条件付きアセンブリ

  特定の条件が満たされた場合にのみ、特定のコード部分を  
  アセンブルすることが便利な場合があります。例えば、  
  複数のプラットフォーム(例えばZ80とR800)向けに 同時にコードを書く  
  場合や、デバッグコードを含めたり除外したりする場合などです。

  niASMはIF構文を通じてこの機能を提供します。  
  その基本形式は次のとおりです。

  ```
  IF {オペランド} [{...}] [ELSE [{...}]] ENDIF
  ```

  tniASM はマルチパスであるため、  
  IF 構文内で前方参照を使用できます。  
  また、ソースファイルの境界を越えて使用することもできます。  
  もちろん、IF 構文は実質的に無限の深さでネストできます。

### 2.6.1  IF {式}

  式が評価され、結果がゼロの場合は「偽」とみなされ、  
  ゼロ以外の場合は「真」とみなされます。

  ```
  loop:   {...}

  IF $-loop < 128  
    djnz loop  
  ELSE  
    dec b  
    jp nz,loop  
  ENDIF
  ```

### 2.6.2  IFDEF {ラベル}

  このパスで以前にラベルが宣言されたかどうかを確認します:

  ```
  R800:           ; Z80版ではコメントアウトしてください

  IFDEF R800 mulub a,b ELSE call mulub_a_b ENDIF

  IFDEF R800 ELSE  
  mulub_a_b: {...}  
  ret  
  ENDIF
  ```

### 2.6.3  IFEXIST {文字列}

  ファイルが存在するかどうかを確認します。2番目の例を見てください。  
  これは、任意の IF 命令で機能するトリックです。

  ```
  IFEXIST "test" {...} ENDIF      ; "test"が存在する場合は{...}を実行する  
  IFEXIST "test" ELSE {...} ENDIF ; "test"が存在しない場合は{...}を実行する
  ```

### 2.6.4  IFEXIST {ラベル}

  IFDEFに似ていますが、ラベルが宣言された場所やタイミングに関係なく、  
  ラベルが存在するかどうかをチェックします。これを使用すると、ラベルが  
  ソースコードのさらに先で宣言されているかどうかを確認できます。

## 2.7  マルチCPUサポート

  tniASMは、Z80、R800、そして一般的にGBZ80として知られるプロセッサなど、  
  複数のCPU向けのアセンブリコードを記述できます。  
  デフォルトでは、tniASMはR800/MSXモードで動作していると想定しています。  
  「CPU」命令を使用することで、以下のモードを切り替えることができます。  
  これは、コード内の任意の場所で、必要な回数だけ実行できます。

  モードは「Z80」、「R800」(別名「MSX」)、  
  そして「GBZ80」と呼ばれます。

  ```
  CPU Z80         ; Z80モードに切り替える  
  CPU R800        ; R800モードに切り替える  
  CPU MSX         ; R800モードに相当  
  CPU GBZ80       ; GBZ80モードに切り替える
  ```

### 2.7.1  Z80モード

  このモードではR800 MULUB/MULUWオペコードは受け付けませんが、  
  それ以外は R800/MSX モードと同じです。

  標準 Z80 構文規則との違いは次のとおりです。

  - 間接参照では、( および ) に加えて [ および ] がサポートされています。  
    メモリアドレス4000hからワードを読み出す場合は、  
    LD HL,[4000h]をLD HL,(4000h)と同等にコーディングできます。

  - ADD、ADC、SUB、SBC、AND、XOR、OR、CPの場合、アキュムレータは  
    オプション。  
    したがって、CP A、B、および CP B は同等です。

  - IN [C] または IN F,[C] を使用できます。(Z80未定義)

  - IX と IY は、それぞれ IXH、IXL、IYH、IYL に分割できます。  
    (Z80未定義)

  - SLL(別名SLIを含む)がサポートされています。(Z80未定義)

  - PUSH と POP はレジスタ リストを受け取り、左から右に評価されます。

  PUSH AF,BC,DE,HL ; AF、BC、DE、HL をこの順序でプッシュします。  
  POP  HL,BC       ; HL をポップし、次に BC をポップします。

### 2.7.2  R800またはMSXモード

  すべての Z80 および R800 オペコードが受け入れられます。

  標準 R800 構文規則との違いは次のとおりです。

  - Z80 オペコードとレジスタ名。

  - tniASM Z80ルール。(第2.7.1章)

  - SLL には R800 では異なる (文書化されていない) 機能があることに注意してください。

### 2.7.3  GBZ80

  GBZ80 オペコードと拡張機能のみが受け入れられます。

  標準 GBZ80 構文規則との違いは次のとおりです。

  - LD A,(HLI) と LD A,(HLD) (およびその逆) は  
    LDI A,[HL] および LDD A,[HL]と表記されます。  


  - LD A,(n) と LD A,(C) (およびその逆) は、LDH A,[n] および LDH A,[C]  
    と表記されます。さらに、IN A,[x] および OUT [x],A という別名も持ちます。  
    LDH A,[n] および LDH [n],A は、0~FF および FF00~FFFF(16 進数)の範囲の  
    値をとることができます。

  - ADD SP,dはLD SP,SP+dと表記されます。

  - LDHL SP,d は LD HL,SP+d と表記されます。

  - tniASM Z80ルール。(第2.7.1章)

第3章:その他  
----------------------

## 3.1  ヒントとコツ

  tniASM を使う際に私がお勧めする最良のヒントは、  
  他のすべてのファイルをインクルードするファイルを 1 つ用意しておくことです。  
  依存関係やオブジェクト関連の情報がない、いわば Makefile のようなものです。

  ```
  ; "example.asm"  
  ; this is an example 'makefile'

          fname   "example.com"  
          org     100h  
          include "frontend.asm"  
          include "main.asm"  
          include "backend.asm"

          fname   "example.dat"  
          org     0  
          incbin  "stuff.dat"  
          include "somesubs.asm"
  ```

## 3.2  更新履歴

  2011年11月2日 v0.45 Magnum mercy shot  
  - 修正: LD IXL、IXL を単純に出力するのではなく、  
    LD L、IXL (または同様のもの) のエラーを生成します。  
  - IM、RST、BIT、RES、SET命令の固定数値オペランドに  
    式を使用できるようになりました。  
    以前はエラーまたは誤った結果が生成されていました。  
  - v0.xシリーズの最終バージョンです。  
     tniASM v1.0に関する情報は、第3.3章を参照してください。

  2005年3月2日、v0.44  
  - 修正: PHASE中の$

  2005年1月22日、v0.43  
  - 演算子 != が <> のエイリアスとしてサポートされるようになりました。  
  - 修正: IF-ELSE に関するバグにより、時々エラーが発生する問題を修正しました。  
  - マニュアルの更新(第2.7.2章、第3.3章)

  2004年11月14日、v0.42  
  - 修正: IF ブロック内のネストされた IF が false として解決され、  
    無限ループが発生しました。  
  - 修正: 親ラベルなしでローカル ラベルを定義すると、エラー メッセージが  
    返されるようになりました。

  2004年9月17日、v0.41  
  - tniASM は拡張 ASCII 文字を使用してソース ファイルを処理するようになりました。

  2003年10月4日、v0.4 スペシャル #msxdev エディション  
  - 2 番目のコマンド パラメータで初期出力ファイル名が指定されるようになりました。  
    (fname ディレクティブを使用する場合と同じです。)  
  - 間接アクセスでレジスタを囲むスペースが許可できるようになりました。  
  - PUSH と POP では、左から右に評価されるレジスタのリストが  
    許可されます。  
  - DC疑似命令が追加されました。2.5.2章を参照してください。  
  - v0.35 および v0.4 の変更を反映するようにマニュアルを更新しました。

  2003年10月2日、v0.35  
  - 多くの要望により、間接参照に () を許可するバージョンがハックされ、  
    [] と () は同一になりました。

  2002年12月24日、v0.3  
  - アセンブル時間が約2.5倍速くなります。  
  - 修正された点:  
    * INCBIN のファイル エラーにより、間違ったファイル名が表示されます。  
    * GBZ80"LDI/LDD A,[HL]"でエラーが発生。  
    * 警告引数のない ORG は警告をリセットしませんでした。  
    * ローカル ラベルはパス間でスコープを変更する可能性があります。  
    * 'INCLUDE' および 'CPU' の解析がより堅牢になりました。  
    * 軽微な手動修正。

  2000 年 9 月 16 日、v0.2 MSX フェア ブッサム エディション  
  - 条件付きアセンブリについては、第2.6章を参照してください。  
  - ラベルの長さは実質的に無制限です。2.2.1 章を参照してください。  
  - 8進数値定数については、2.3.1章を参照してください。  
  - マルチCPUサポート(GBZ80を追加)、2.7章を参照  
  - 初期化されていないデータ宣言については、2.5.11章を参照してください。

  2000年8月14日 v0.1 初回リリース

## 3.3  tniASM v1.0

  tniASM v1.0 は、tniASM を完全に書き直したバージョンです。  
  全く異なるプログラムです。  
  プロセッサやアセンブリ言語に完全に依存せずカスタムプロセッサや、  
  ファイル操作などのアセンブリ言語以外の作業にも最適です。  
  tniASM の伝統を継承し、強力な機能を提供しながらも、  
  使いやすさに細心の注意を払っています。

  最も重要な特徴、すべての基礎となるのは、強力な  
  マクロプロセッサです。以下を提供します。  
  - 同じソースファイル内でも複数のCPUをサポート  
  - カスタマイズされた組み立て、お好みの(疑似)指示書を使用  
  - 他のアセンブラとの互換性がある

  tniASM v1.0には32ビットWindows版と64ビットLinux版があります、  
  また以下の用途のマクロ定義があります:  
  - Z80、R800、GBZ80、Z380 プロセッサ  
  - コード、データ、予約データセクション  
  - tniASM v0.45 との互換性

  tniASM v1.0は、The New ImageやInfiniteをはじめとする  
  すべてのプロジェクトで実稼働中です。オランダ、アルメーレの  
  Patriek Lesparreの銀行口座(BIC: INGBNL2A、IBAN: NL42INGB0006268083)に  
  15ユーロ以上を寄付することで、プライベートベータテストにご参加いただけます。  
  メールアドレスのご記入をお忘れなく!  
  PayPalをご利用の場合は、paypal@tni.nlまで寄付をお願いします。

  ベータテスターに​​は最新の開発バージョンが提供され、  
  プログラムの開発に意見を述べることができます。  
  tniASM v1.0は、一般公開が可能と判断され次第、25ユーロで販売される予定ですが、  
  ベータテスターに​​は無料で提供されます。

## 3.4  免責事項

  - すべての商標はそれぞれの所有者の財産です。  
  - tniASM v0.45 はフリーウェアであり、変更されない限り自由に配布できます。  
    このファイルはアーカイブに含まれており、  
    商用製品の一部ではありません。  
  - 自己責任でご使用ください。本ソフトウェアの使用または誤用によって生じた  
    いかなる損失または損害についても、作者は一切責任を負いません。

---------------------------------------------------------------------------